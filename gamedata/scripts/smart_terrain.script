-- -*- mode: lua; coding: windows-1251-dos -*-
--[=[
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--]=]

local check_period
if not editor() then
  check_period = game.CTime()
  check_period:setHMSms( 0, 0, 0, 50000 )
  CTime_0 = game.CTime()
end

local monster_classes
local disagreed, agreed, agreed_exclusive = 0, 1, 2
local smart_section = "smart_terrains"
local smart_terrains = {}
local smart_terrains_by_name = {}
exclusives = {}

--[=[
список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
  smart_terrains = {
    level_name = { id=obj, id=obj, ... },
    level_name = { id=obj, id=obj, ... },
    ...
  }
--]=]


--------------------------------------------------------------------------------
-- Разные полезные функции
--------------------------------------------------------------------------------
-------------- помощники для чтения ini (custom data) -------------------
-- TODO убрать их
function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end

function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- если default-ов больше, чем значений в ini, то забить
    -- недостающие последним значением из ini
    local t = parse_nums( spawn_ini:r_string( section, line ) )
    local n = table.getn( t )
    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[ 1 ], def2
    else
      return t[ 1 ], t[ 2 ]
    end
  else
    return def1, def2
  end
end


--------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
--------------------------------------------------------------------------------
class "se_smart_terrain"( cse_alife_smart_zone )
function se_smart_terrain:__init( section ) super( section )
  self.initialized = false
  self.registred   = false
end


function se_smart_terrain:detect_probability()
  return 0
end


function se_smart_terrain:print()
  log1( "NPCs:" )
  if self.npc_info then
    for id, v in pairs( self.npc_info ) do
      log2( "    %d %s", id, tostring( v.name ) )
    end
  end
end


-- сохранение
function se_smart_terrain:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )
  utils.w_CTime( packet, self.duration_end )
  utils.w_CTime( packet, self.idle_end     )
  if self.gulag_working then
    packet:w_bool( true )
    self.gulag:save_common( packet )
    local n = 0
    for id, v in pairs( self.npc_info ) do
      n = n + 1
    end
    packet:w_u8( n )
    for id, v in pairs( self.npc_info ) do
      packet:w_u16( id )
      packet:w_u8( v.o_group )
      packet:w_u8( v.o_squad )
      packet:w_bool( v.exclusive )
      utils.w_CTime( packet, v.stay_end )
      self.gulag:save_obj( packet, id )
    end
    packet:w_bool ( self.population_locked )
  else
    packet:w_bool( false )
  end
end


-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )
  self:read_params()
  -- под LevelEditor не пытаться читать из пакета ничего
  if editor() then
    return
  end
  self.duration_end  = utils.r_CTime( packet )
  self.idle_end      = utils.r_CTime( packet )
  self.gulag_working = packet:r_bool()
  -- если есть работающий гулаг
  if self.gulag_working then
    self.check_time = CTime_0
    self.gulag:load_common( packet )
    local n = packet:r_u8()
    for i = 1, n do
      local o_id = packet:r_u16()
      self.npc_info[ o_id ] = {}
      dsh.remember_mobs_smart_terrain( o_id, self, true )
      local o = self.npc_info[ o_id ]
      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
      o.stay_end  = utils.r_CTime( packet )
      self.gulag:load_obj( packet, o_id )
    end
    self.population_locked = packet:r_bool()
  end
end


-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()
    self:preserve_exclusives()
    self.gulag:reinit_job_online()
    self.initialized = true
  end
end


function se_smart_terrain:is_initialized()
  return self.initialized
end


-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
  local e = exclusives[ self:name() ]
  if e then
    self.exclusives = e
    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e
    exclusives[ self:name() ] = nil
  else
    self.exclusives = 0
  end
end


-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local del = {}
  for id, v in pairs( self.npc_info ) do
    local obj = sim:object( id )
    if obj then
      self:fill_npc_info( obj, v )
    else
      log2(
        "[smart_terrain %s] can't get server object id=%d", self:name(), id
      )
      table.insert( del, id )
    end
  end
  for _, id in ipairs( del ) do
    self.npc_info[ id ] = nil
    self.gulag:removeObject( id )
  end
end


-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end
  npc_info.se_obj       = obj
  npc_info.class_id     = obj:clsid()
  npc_info.section_name = obj:section_name()
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = self:get_obj_community( obj )
  npc_info.profile_name = obj.profile_name and obj:profile_name()
  npc_info.rank         = obj:rank()
  npc_info.group        = obj:g_group()
  npc_info.squad        = obj:g_squad()
  npc_info.team         = obj:g_team()
  if npc_info.profile_name then
    npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
  end
  npc_info.is_sniper_name = string.find( npc_info.name, "sniper" ) ~= nil
  local t               = obj.smart_terrain_conditions
  if t then
    t = t[ self:name() ]
  end
  npc_info.cond         = t
  return npc_info
end


-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community( obj )
  local cls = obj:clsid()
  if cls == clsid.script_stalker then
    return obj:community(), true
  else
    return monster_classes[ cls ], false
  end
end


-- инициализация.
-- чтение custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
  if ini:section_exist( "dsh" ) then
    self.dsh_active_profile = get_string( "dsh", "active_profile", nil, ini )
  end
  if not ini:section_exist( sect ) then
    sect = "gulag1"
    if not ini:section_exist( sect ) then
      log2( "[smart_terrain %s] no configuration!", self:name() )
      self.disabled = true
      return
    end
  end
  if not ini:line_exist( sect, "type" ) then
    abort( "[smart_terrain %s] type is not specified", self:name() )
  end
  local gp       = {}
  self.npc_info  = {}           -- group и squad для каждого npc
  self.gparams   = gp           -- настройки гулага
  gp.type        = get_string( sect, "type",   nil, ini )
  gp.preset_name = get_string( sect, "preset", nil, ini )
  -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
  gp.capacity    = get_float( sect, "capacity", 100, ini )
  gp.squad       = get_float( sect, "squad", nil, ini )
  gp.idle_min, gp.idle_max = r_2nums( ini, sect, "idle", 0, 0 )
  gp.duration_min, gp.duration_max = r_2nums(
    ini, sect, "duration", 10000, 10001
  )
  gp.stay_min, gp.stay_max = smart_terrain_params.get_stay_time_interval(
    get_string( sect, "stay", "default", ini )
  )
  gp.respawn = get_string( sect, "respawn", nil, ini )
  gp.cond    = get_string( sect, "cond",    nil, ini )
  gp.groups  = get_string( sect, "groups",  nil, ini )
  self.rank_inc_min = get_string( "smart_terrain_rank_change", "min" )
  self.rank_inc_max = get_string( "smart_terrain_rank_change", "max" )
  self.accepted_communities = nil
  self.communities = get_string( sect, "communities", nil, ini )

  self:init_idle_times()
  self:dsh_override_params()

  if gp.cond then
    gp.cond = dsh.cached_condlist(
      xr_logic.parse_condlist( nil, sect, "cond", gp.cond ), 1000
    )
  end

  if gp.groups then
    gp.groups = parse_nums( gp.groups )
  end

  if self.communities then
    local comms = parse_names( self.communities )
    self.accepted_communities = {}
    for i, v in ipairs( comms ) do
      self.accepted_communities[ v ] = true
    end
  end

  self.population_locked = false
  self.gulag = xr_gulag.gulag(
    self, self.gparams.type, self.gparams.squad, self.gparams.groups,
    self.npc_info, self.gparams.capacity
  )
  self.gulag_working = false
end


function se_smart_terrain:init_idle_times()
  function parse_idle_time( sect, name )
    local val = get_string( sect, name )
    if val then
      val = parse_nums( val )
      if table.getn( val ) < 2 then
        table.insert( val, val[ 1 ] )
      end
    end
    return val
  end
  for _, suf in ipairs({ "." .. self:name(), "" }) do
    local sect = "dsh.gulag.idle" .. suf
    if sys_ini:section_exist( sect ) then
      self.idle_time_stalker = parse_idle_time( sect, "stalker" )
      self.idle_time_monster = parse_idle_time( sect, "monster" )
      break
    end
  end
end


function se_smart_terrain:dsh_override_params()
  if not dsh.is_gulag_fixes_enabled() then return end
  local dsh_override_opts = {
    [ "capacity" ] = {
      [ "getter" ] = function( ... ) return get_float(  ... ) end,
      [ "setter" ] = function( v ) self.gparams.capacity = v end,
    },
    [ "communities" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.communities = v end,
    },
    [ "cond" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.gparams.cond = v end,
    },
    [ "stay" ] = {
      [ "getter" ] = function( ... ) return get_numbers( ... ) end,
      [ "setter" ] = function( v )
        self.gparams.stay_min = v[ 1 ]
        if table.getn( v ) > 1 then
          self.gparams.stay_max = v[ 2 ]
        else
          self.gparams.stay_max = v[ 1 ]
        end
      end,
    },
    [ "type" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.gparams.type = v end,
    },
  }
  local dsh_sect = "dsh.gulag.override." .. self:name()
  local profile  = self.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  if sys_ini:section_exist( sect ) then
    for k, v in pairs( dsh_override_opts ) do
      if sys_ini:line_exist( sect, k ) then
        local value = v.getter( sect, k )
        v.setter( value )
      end
    end
  end
end


-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )
  if preset == false then
    return true
  else
    local t = preset[ npc_community ]
    if t and ( npc_rank >= t[ 1 ] and npc_rank <= t[ 2 ] ) then
      return true
    else
      return false
    end
  end
end


-- подходит ли объект гулагу?
--
-- 1) если объект не согласен сюда идти, то smart terrain его не возьмёт
--
-- 2) если объект согласен идти куда угодно, то проверить, есть ли ещё
--    места, подходит ли он гулагу, подходит ли он хоть на одну работу
--
-- 3) если объект согласен идти только в этот смарт, то принимаем даже
--    если нету места (он вытеснит кого-то), проверить, подходит ли он
--    гулагу, подходит ли он хоть на одну работу
--
-- таблица level_groups задаёт что-то вроде карты, где локации сгруппированы в области.
--
-- Неписи пойдут в смарт с другого уровня, только если этот уровень
-- находится в одной группе со смартом.
--
-- Вероятно, надо глянуть на карту и убедиться, что эти группы заданы
-- осмысленно.  как минимум, группы должны обеспечивать связность
-- графа в пределах локаций одной группы, и также надо согласовывать
-- место спавна неписей и группы, иначе заспавненные неписи не смогут
-- попасть в свой смарт.
--
-- если локация не прописана в этой таблице, то она будет
-- автоматически изолирована.
local level_groups = {
  [ "atp_for_test22" ] = "group1",
  [ "aver"           ] = "group1",
  [ "dead_city"      ] = "group1",
  [ "generators"     ] = "group1",
  [ "hospital"       ] = "group1",
  [ "limansk"        ] = "group1",
  [ "lost_village"   ] = "group1",
  [ "puzir"          ] = "group1",
  [ "red_forest"     ] = "group1",
  [ "warlab"         ] = "group1",

  [ "l01_escape"     ] = "group1",
  [ "l02_garbage"    ] = "group1",
  [ "l03_agroprom"   ] = "group1",
  [ "l03u_agr_underground" ] = "group1",
  [ "l04_darkvalley" ] = "group1",
  [ "l04u_labx18"    ] = "group1",
  [ "l05_bar"        ] = "group1",
  [ "l06_rostok"     ] = "group1",
  [ "l07_military"   ] = "group1",
  [ "l08_yantar"     ] = "group1",
  [ "l08u_brainlab"  ] = "group1",
  [ "l10_radar"      ] = "group1",
  [ "l10u_bunker"    ] = "group1",
  [ "l11_pripyat"    ] = "group1",
  [ "marsh"          ] = "group1",

  [ "l12_stancia"    ] = "group3",
  [ "l12u_sarcofag"  ] = "group3",
  [ "l12u_control_monolith" ] = "group3",
  [ "l12_stancia_2"  ] = "group3",

  [ "jupiter"        ] = "group4",
  [ "jupiter_underground" ] = "group4",
  [ "labx8"          ] = "group4",
  [ "pripyat"        ] = "group4",
  [ "zaton"          ] = "group4",
}


function is_same_level_group( l1, l2 )
  local g1 = level_groups[ l1 ] or l1
  local g2 = level_groups[ l2 ] or l2
  return g1 == g2
end


-- Подходит ли объект гулагу.
-- Второй аргумент - результат работы функии obj_accepts_smart_terrain - тип
-- согласия объекта на вступление в этот смарт.
-- Вызывается как часть enabled
function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
  if obj_agreement == disagreed then -- объект в этот смарт идти не хочет
    return false
  end
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return false
  end

  -- в любом случае, если хочет идти только в этот, или если готов без
  -- условий и при этом гулаг не заполнен полностью
  if
    obj_agreement == agreed_exclusive
    or self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
  then
    local community, is_stalker = self:get_obj_community( obj )
    -- фантомов не принимаем никуда
    if not community then return false end
    -- мертвых не принимаем тоже
    if not obj:alive() then return false end
    --' Проверка что смарттеррейн и НПС находятся в одном кластере
    --уровней (чтобы не ходили через БАР)
    local npc_level_group = ""
    if game_graph():valid_vertex_id( obj.m_game_vertex_id ) then
      npc_level_group = object_level_name( obj )
    end
    if not is_same_level_group( self:get_level_name(), npc_level_group ) then
      return false -- с этого уровня в этот смарт идти нельзя
    end
    -- если в кастомдате смарта есть перечень допустимых группировок и
    -- непись не попадает в эту группировку
    if
      self.accepted_communities and not self.accepted_communities[ community ]
   then
      return false              -- то не подходит
    end
    -- выполнить проверку, заданную скриптом для конкретного уровня
    -- (обычно соответствие типа гулага и параметров непися)
    if not xr_gulag.checkNpc(
      community, is_stalker, self.gparams.type, obj:rank(), obj, self
    ) then
      return false
    end
    -- если есть работа
    return self.gulag:is_there_any_suitable_job(
      self:fill_npc_info( obj ), obj_agreement == agreed_exclusive
    )
  else
    -- если не эксклюзив для этого смарта и места нет, то не подходит
    return false
  end
end


-- подходит ли гулаг объекту?
--
-- у объекта в custom data прописаны условия для некоторых smart_terrains:
--         <smart_terrain_name1> = <condlist1>
--         <smart_terrain_name2> = <condlist2>
--         ...
-- Если для какого-то smart_terrain условие выполнилось, он называется
-- эксклюзивным.
-- Если у объекта появился хоть один эксклюзивный smart terrain, то он будет
-- согласен идти только в него.
-- Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
-- Функция возвращает одно из трёх значений:
-- disagreed        - в этот не идёт
-- agreed_exclusive - идёт только в этот
-- agreed           - согласен идти в этот на неэкслюзивной основе
--
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return disagreed
  end

  -- если вообще есть какие-то специальные условия насчёт смартов
  local conds = obj.smart_terrain_conditions
  if conds then
    local done = true
    -- перебираем все варианты условий из секции непися
    if xr_logic.pick_section_from_condlist(
      db.actor_proxy, obj, conds[ "none" ]
    ) then
      return disagreed -- явно прописано, что не идёт ни в какой смарт
    elseif xr_logic.pick_section_from_condlist(
      db.actor_proxy, obj, conds[ self:name() ]
    ) then
      return agreed_exclusive   -- идёт только в этот смарт
    elseif xr_logic.pick_section_from_condlist(
      db.actor_proxy, obj, conds[ "any" ]
    ) then
      done = false              -- разрешили идти в любой смарт
    end
    if done then
      return disagreed          -- в этот не идёт
    end
  end

  -- здесь имеем: эксклюзивов нет, явного запрета тоже нет
  --
  -- Если объекту запрещено переходить в online и эксклюзивные '
  -- смарты недоступны, то не пускаем его никуда. Это исключает '
  -- переброску отключенных до (или после) определённого события '
  -- людей и мутантов в другой неэксклюзивный смарт.
  if not obj:can_be_spawned() then
    if
      not (
        -- ждет, когда его примет какой-нибудь смарт
        obj.se_respawn
        and obj.se_respawn:is_waiting_register_npc( obj.id )
      )
    then
      return disagreed
    end
  end

  return agreed
end


-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в
-- группе вернут true
local reject_timers = {}
function se_smart_terrain:enabled( obj )
  -- enabled(), suitable() и register_npc() вызываются из движка одним
  -- непрерывным циклом и можно быть уверенным, что к моменту
  -- следующего апдейта он будет завершен и моб либо будет принят
  -- каким-нибудь смартом, либо не будет принят никаким.
  if not reject_timers[ obj.id ] then -- начался цикл поиска смарта для моба
    reject_timers[ obj.id ] = dsh.exec_on_update(
      -- если на следующем апдейте этот таймер сработает, значит смарт
      -- не был найден и нужно известить об этом респаунер
      function( id )
        reject_timers[ id ] = nil
        local sobj = alife():object( id )
        if
          sobj and sobj.se_respawn
          and sobj.se_respawn:is_waiting_register_npc( id )
        then
          sobj.se_respawn:on_smart_terrain_reject_npc( sobj )
        end
      end, obj.id
    )
  end

  if self.disabled then
    return false
  end
  if xr_companion.is_companion( obj.id ) then
    return false
  end

  -- если всё это делаем в первый раз проинитим ...вообще-то это
  -- должно с гарантией происходить при создании смарта движком,
  self:register_if_needed()
  self:initialize_if_needed()   -- но на всякий случай...

  -- если гулаг активен (по cond_list из кастомдаты смарта) и не
  -- заблокировано добавление персонажей
  if self:is_gulag_available() then
    -- если смарт подходит неписю
    local b = self:obj_accepts_smart_terrain( obj )
    if
      b == agreed_exclusive
      or not (
        self.population_locked
        or ( self.idle_end and self.idle_end > game.get_game_time() )
        or ogse_st_mgr.timer_exists(
          "smart_terrain." .. self:name() .. ".population_locked"
        )
      )
    then
      -- и непись подходит смарту
      return self:smart_terrain_accepts_obj( obj, b )
    end
  else
    local conds = obj.smart_terrain_conditions
    if conds then
      if
        conds[ self:name() ]
        and obj.smart_terrain_conditions_cnt == 1
        and object_level_name( obj ) ~= level.name()
      then
        obj:brain():can_choose_alife_tasks( false )
      end
    end
    return false
  end
end


-- возвращает меру подходящести персонажа смарттерейну.
--
-- вызывается для всех смарттерейнов, которые вернули true из enabled
--
-- для того, чтобы выбрать тот единственный, в который персонаж
-- всё-таки пойдёт.  критерии:
--
--   1) если объект уже бывал в других смартах, то чем больше
--   свободных работ на уровне этого смарта, тем лучше
--
--   2) иначе ближе - лучше
--
-- TODO Оптимизировать
--
-- на основе это функции принимается решение для непися (не смарта),
-- т.е. здесь непись выбирает себе смарт для какого смарта число
-- больше, туда и пойдёт
function se_smart_terrain:suitable( obj )
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return 0
  end
  -- Повысить подходящесть эксклюзивного смарттеррейна
  if self:obj_accepts_smart_terrain( obj ) == agreed_exclusive then
    -- некрасиво, уже ведь проверяли, а фунция некислая
    -- TODO: оптимизировать
    -- v = 100000 --'Так чтобы все эксклюзивные были заведомо лучше
    -- сразу возвращаем, зачем ещё что-то проверять, если это заведомо
    -- больше всех
    return 100000
  end

  local k = 1                  -- коэффициент привлекательности смарта
  local self_lname = object_level_name( self )
  if object_level_name( obj ) ~= self_lname then
    -- смарт на другой локации будет привлекательнее смарта на текущей
    -- локации непися. Полагаю, это приведет к большей движухе.
    k = 10 + math.random( 0, 10 )
  end

  local v = 0        -- посчитаем доступное на уровне количество работ
  -- перебираем все гулаги на одном уровне с этим
  for id, strn in pairs( smart_terrains[ self_lname ] ) do
    if strn:is_gulag_available() then -- если они доступны
      -- то суммируем их вакансии
      v = v + strn.gulag.capacity - strn.gulag:get_population()
    end
  end
  -- непонятен критерий! Получается, неэксклюзивный непись почти
  -- всегда пойдёт на уровень с тупо большим числом смартов, а уровни
  -- с небольшим количеством смартов заселятся в последнюю очередь.
  -- надо подумать над критерием.  Кроме того, непонятно, где
  -- прописывается ограничение по рангу/силе монстров. Может это
  -- сделать здесь?
  return v * k -- возвращаем фактически число вакансий на уровне
end


-- добавить npc в smart terrain.  если места нету или нету свободных
-- подходящих работ, то вытолкнуть из этого smart terrain с подходящей
-- работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
  -- log2(
  --   "[smart_terrain %s] register called obj=%s gulag_type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )
  if reject_timers[ obj.id ] then
    -- моб был принять смартом и нужно остановить таймер, который
    -- сработает на апдейте и уведомит респаунер, что моба никто не
    -- принял
    reject_timers[ obj.id ]:stop()
    reject_timers[ obj.id ] = nil
  end

  if obj.se_respawn then
    obj.se_respawn:on_smart_terrain_register_npc( obj, self )
  end

  local npc_info = {
    -- старые squad и group
    o_group   = obj:g_group(),
    o_squad   = obj:g_squad(),
    exclusive = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,
    stay_end  = game.get_game_time()
  }
  self:fill_npc_info( obj, npc_info )

  if
    self.gulag_working
    and not self.gulag:is_there_any_suitable_job( npc_info, false )
  then
    log2(
      "get_population = %d, capacity = %d",
      self.gulag:get_population(), self.gulag.capacity
    )
    log2(
      "is_there_any_suitable_job = %s",
      tostring( self.gulag:is_there_any_suitable_job( npc_info, false ) )
    )
    print_table( self.npc_info )
    self:kick_someone_non_exclusive( npc_info )
  end

  self:update_obj_rank( obj )
  obj.was_in_smart_terrain = true
  self.npc_info[ obj.id ] = npc_info

  if not self.gulag_working then
    self:create_gulag()
  end
  self.gulag:addObject( obj.id )
  self.gulag:update()

  if db.actor and self.gulag:dsh_is_full() then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_full_smart_terrain", self )
  end
  -- log2(
  --   "[smart_terrain %s] added %s to gulag type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )
end


-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
  -- Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить
  -- счетчик эксклюзивности
  if obj.smart_terrain_conditions then
    local any_exclusive = false
    for name, condlist in pairs( obj.smart_terrain_conditions ) do
      local s = xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, condlist
      )
      if s ~= nil then
        if name == self:name() then
          -- уменьшаем счетчик
          self.exclusives = self.exclusives - 1
          self.gulag.capacity_non_exclusive =
            self.gulag.capacity_non_exclusive + 1
        end
      end
    end
  end

  local n = self.npc_info[ obj.id ]
  if not n then
    log1( debug.traceback() )
    log2( "self.npc_info[obj.id] = nil !!! obj.id=%d", obj.id )
    self:print()
    self.gulag:print()
  end

  self.gulag:removeObject( obj.id )
  obj.squad = n.o_squad
  obj.group = n.o_group
  self.npc_info[ obj.id ] = nil
  obj:clear_smart_terrain()
  dsh.remember_mobs_smart_terrain( obj.id, self, false )

  if self:is_empty() and db.actor then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_empty_smart_terrain", self )
  end
  -- log2(
  --   "[smart_terrain %s] removed %s from gulag type=%s, strn_id=%s",
  --   self:name(), obj:name() or "<<<nil>>>", self.gparams.type, obj:smart_terrain_id()
  -- )
end


function se_smart_terrain:is_empty()
  for id, v in pairs( self.npc_info ) do
    return false
  end
  return true
end


-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( obj )
  local community, is_stalker = self:get_obj_community( obj )
  if is_stalker then
    local old_rank = obj:rank()
    obj:set_rank(
      old_rank + math.random( self.rank_inc_min, self.rank_inc_max )
    )
    -- log2(
    --   "[smart_terrain %s] obj=%s rank %d -> %d",
    --   self:name(), obj:name(), old_rank, obj:rank()
    -- )
  end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного
-- персонажа, который занимает работу, подходящую новому персонажу.
--
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
  for obj_id, npc_info in pairs( self.npc_info ) do
    if
      ( not npc_info.exclusive )
      and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info )
    then
      log2( "[smart_terrain %s] kicking %s", self:name(), npc_info.name )
      self:unregister_npc( npc_info.se_obj )
      return
    end
  end
  abort(
    "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs",
    self:name()
  )
end

-- выдать объекту задание.
function se_smart_terrain:task( obj )
  if xr_companion.is_companion( obj.id ) then -- и как он здесь оказался?
    self:unregister_npc( obj )
    return CALifeSmartTerrainTask( "simulation_default_path" )
  end
  ASSERT(
    ( not dsh.is_free_logic_mob( obj ) ),
    "smart_terrain %s is trying to assign task to %s",
    self:name(), obj:name()
  )
  local path_name = self.gulag:get_obj_job_path_name( obj.id )
  if not path_name then
    -- log2(
    --   "[smart_terrain %s] task: obj=%s job_path=nil, CLEARING",
    --   self:name(), obj:name()
    -- )
    self:unregister_npc( obj )  --'Затычка против вылета.
    return CALifeSmartTerrainTask( "simulation_default_path" )
  end
  return CALifeSmartTerrainTask( path_name )
end


-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
  if self.gparams.cond then
    return self.gparams.cond
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  else
    return true
  end
end


-- установка/снятие блокировки приёма персонажей
function se_smart_terrain:lock_population( need_lock )
  self.population_locked = need_lock
end


-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
  self.duration_end = game.CTime()
  self.duration_end:setHMSms(
    math.random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0
  )
  self.duration_end:add( game.get_game_time() )
  self.check_time = CTime_0
  self.gulag:initialize()
  self.gulag_working = true
end


-- всех освободить, убить гулаг, создать новый нерабочий гулаг,
-- зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
  self.disabled = disable
  if not self.gulag_working then
    return
  end
  -- log2(
  --   "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type
  -- )
  -- освободить всех персонажей
  for id, npc_info in pairs( self.npc_info ) do
    self:unregister_npc( npc_info.se_obj )
  end
  self.gulag = xr_gulag.gulag(
    self, self.gparams.type, self.gparams.squad, self.gparams.groups,
    self.npc_info, self.gparams.capacity
  )
  self.gulag:load_jobs()
  self.gulag_working = false
  self.gulag.capacity_non_exclusive =
    self.gulag.capacity_non_exclusive - self.exclusives
end


-- заполняет таблицу monster_classes
function se_smart_terrain:fill_monster_classes()
  if not monster_classes then
    monster_classes = {
      [clsid.bloodsucker_s ] = "bloodsucker",
      [clsid.boar_s        ] = "boar",
      [clsid.burer_s       ] = "burer",
      [clsid.cat_s         ] = "cat",
      [clsid.chimera_s     ] = "chimera",
      [clsid.controller_s  ] = "controller",
      [clsid.pseudodog_s   ] = "pseudodog",
      [clsid.psy_dog_s     ] = "psy_dog",
      [clsid.dog_s         ] = "dog",
      [clsid.flesh_s       ] = "flesh",
      [clsid.fracture_s    ] = "fracture",
      [clsid.poltergeist_s ] = "poltergeist",
      [clsid.gigant_s      ] = "pseudo_gigant",
      [clsid.snork_s       ] = "snork",
      [clsid.tushkano_s    ] = "tushkano",
      [clsid.zombie_s      ] = "zombie"
    }
  end
end


-- возвращает название уровня, на котором находится smart terrain
function se_smart_terrain:get_level_name()
  return object_level_name( self )
end

-- регистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
  cse_alife_smart_zone.on_register( self )
  self:register_if_needed()
  self:initialize_if_needed()
end


function se_smart_terrain:register_if_needed()
  --' Если уже зарегистрены то ничего не делать.
  if self.registred == true then
    return
  end
  self.registred = true
  -- log2( "%s register called", self:name() )
  if self.disabled then
    return
  end
  self:fill_monster_classes()
  local level_name = self:get_level_name()
  if not self.gparams.preset_name then
    self.gparams.preset_name = level_name
  end
  if not smart_terrains[ level_name ] then
    smart_terrains[level_name] = {}
  end
  smart_terrains[ level_name ][ self.id ] = self
  smart_terrains_by_name[ self:name() ]   = self
  if self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = self
  end
  self.gulag:load_jobs()
  if self.gulag_working then
    self.gulag:initialize()
  end
  -- Регистрация в таскменеджере
  task_manager.get_random_task():register_target( self )
end


-- дерегистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
  cse_alife_smart_zone.on_unregister( self )
  -- log2( "[smart_terrain %s] on_unregister called", self:name() )
  local lvl_smarts = smart_terrains[ self:get_level_name() ]
  if lvl_smarts then
    lvl_smarts[ self.id ] = nil
  end
  smart_terrains_by_name[ self:name() ] = nil
  if self.gparams and self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = nil
  end
  db.actor_proxy:deinit()
end


-- вызвать спавнер, если настроен.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end


-- возвращает строку с принимаемыми группировками и рангами
function se_smart_terrain:stat_get_accepted_communities()
  local comms = {}
  -- from preset
  local iniFileName = "misc\\" .. self.gparams.type .. ".ltx"
  local preset_name = self.gparams.preset_name
  if iniLineSectionExist( preset_name, iniFileName ) then
    local n = iniLinesCount( preset_name, iniFileName )
    for i = 0, n - 1 do
      local result, field, str = getIniLine(
        preset_name, i, "", "", iniFileName
      )
      if
        ( not self.accepted_communities )
        or self.accepted_communities[field]
      then
        comms[ field ] = str
      end
    end
  end
  -- from custom data
  if self.accepted_communities then
    for comm, v in pairs( self.accepted_communities ) do
      if not comms[ comm ] then
        comms[ comm ] = "all"
      end
    end
  end
  -- prepare return
  local s = ""
  for comm, ranks in pairs( comms ) do
    s = s .. comm .. "(" .. ranks .. "),"
  end
  return s
end


-- вывод статистики смарта
function se_smart_terrain:stat()
  local s     = self:get_level_name() .. " " .. self:name()
  local pop   = self.gulag:get_population()
  local cap   = self.gulag.capacity
  local avail = self:is_gulag_available()
  if avail then
    s = s .. " enabled "
  else
    s = s .. " disabled "
  end
  s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()
  log1( s )
  for id, npc_info in pairs( self.npc_info ) do
    log2( "    %s", npc_info.name )
  end
  return avail, pop, cap
end


-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования
-- гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
  cse_alife_smart_zone.update( self )
  if not self.gulag_working then
    return
  end
  if self:is_gulag_available() then
    if self.check_time < game.get_game_time() then
      self.check_time = game.get_game_time() + check_period
      --' проверять, не собрался ли кто-то к этому времени уже уходить
      for id, npc_info in pairs( self.npc_info ) do
        if
          npc_info.cond
          and xr_logic.pick_section_from_condlist(
            db.actor_proxy, npc_info.se_obj, npc_info.cond
          ) == nil
        then
          -- log2( "[smart_terrain %s] leaving %s", self:name(), npc_info.name )
          self:unregister_npc( npc_info.se_obj )
        end
      end
      if self.gulag:get_population() == 0 then
        self:remove_gulag( self.id )
      else
        self.gulag:update()
      end
    end
  else
    self:remove_gulag()
  end
end


function se_smart_terrain:dsh_begin_job( id )
  local t = game.CTime()
  t:setHMSms(
    math.random( self.gparams.stay_min, self.gparams.stay_max ),
    math.random( 0, 59 ), 0, 0
  )
  t:add( game.get_game_time() )
  self.npc_info[ id ].stay_end = t
end


function se_smart_terrain:set_idle_timer( hours, not_exists )
  local tname  = "smart_terrain." .. self:name() .. ".population_locked"
  if ogse_st_mgr.timer_exists( tname ) then
    if not_exists then
      return false
    end
    local t = ogse_st_mgr.get_timer( tname )
    t:stop()
  end
  local t = dsh.start_gtimerDHMS(
    tname, 0, hours, 0, 0, script_name() .. ".on_after_idle_timer", self.id
  )
  self.idle_end = t:get_end_time()
  return true
end


function on_after_idle_timer( strn_id )
  if strn_id then
    strn_id = tonumber( strn_id )
    local strn = alife():object( strn_id )
    ASSERT( strn, "smart_terrain id = %s not found", strn_id )
    strn.idle_end = CTime_0
  end
end


function se_smart_terrain:try_set_idle_timer( last_sobj )
  if self.idle_time_monster or self.idle_time_stalker then
    ASSERT(
      ( IsStalker( last_sobj ) or IsMonster( last_sobj ) ),
      "unknown last_sobj: %s", last_sobj:name()
    )
    local t_min, t_max
    if IsStalker( last_sobj ) and last_sobj:community() ~= "zombied" then
      if self.idle_time_stalker then
        t_min, t_max = unpack( self.idle_time_stalker )
      end
    else
      if self.idle_time_monster then
        t_min, t_max = unpack( self.idle_time_monster )
      end
    end
    if t_min and t_max then
      local hours = ( t_min == t_max ) and t_max or math.random( t_min, t_max )
      if hours > 0 then
        -- блокировать смарт на hours часов, если он еще не заблокирован.
        if self:is_empty() then
          self:set_idle_timer( hours, true )
        else
          -- если не смарт не опустел, то дадим время ему опустеть. Не будем
          -- некоторое время никого принимать. А то есть вероятность, что
          -- кто-нибудь немедленно в нем зарегистрируется и тогда он уже не
          -- опустеет.
          self.idle_end = game.CTime()
          self.idle_end:setHMSms( hours, 0, 0, 0 )
          self.idle_end:add( game.get_game_time() )
        end
      end
    end
  end
end


function on_death( id )
  -- log2( "on_death id=%d", id )
  if alife() then
    local sobj = alife():object( id )
    if sobj and sobj.smart_terrain_id then
      local strn_id       = sobj:smart_terrain_id()
      local free_logic_id = dsh.is_free_logic_mob( sobj )
      if free_logic_id then
        strn_id = free_logic_id
      end
      if strn_id ~= 65535 then
        -- обертка для фикса кривых smart_terrain
        local strn = alife():object( strn_id )
        if strn then
          if strn:clsid() == clsid.smart_terrain then
            strn.gulag:clear_dead( id )
            -- clear_dead() вызовет strn:unregister_npc(), а он
            -- вызовет событие on_empty_smart_terrain, обработчик
            -- которого тоже может заблокировать этот смарт на
            -- время. Поэтому, здесь смарт будет блокироваться
            -- только в том случае, если его еще никто другой не
            -- заблокировал.
            strn:try_set_idle_timer( sobj )
          else
            log1(
              "load ~~~ smart_terrain.on_death: Обнаружена привязка к несуществующему smart_terrain: "..sobj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
            )
            sobj:clear_smart_terrain()
          end
        end
      end
    end
  end
end


--' Удаляет объект из смарттеррейнов.
function unregister_npc( npc )
  local sim = alife()
  if sim then
    local obj           = sim:object( npc.id )
    local strn_id       = obj:smart_terrain_id()
    local free_logic_id = dsh.is_free_logic_mob( npc )
    if free_logic_id then
      strn_id = free_logic_id
    end
    if strn_id ~= 65535 then
      -- обертка для фикса кривых smart_terrain
      local strn = sim:object( strn_id )
      if strn then
        if strn:clsid() == clsid.smart_terrain then
          strn:unregister_npc( obj )
        else
          log1(
            "smart_terrain.unregister_npc: Обнаружена привязка к несуществующему smart_terrain: "..obj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
          )
          obj:clear_smart_terrain()
        end
      end
    end
  end
end


-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
  local ini      = self.ini
  local sect     = smart_section
  local dsh_sect = "dsh.se_stalker." .. self:name() .. ".smart_terrains"
  if sys_ini:section_exist( dsh_sect ) then
    ini  = sys_ini
    sect = dsh_sect
  else
    if
      ini
      and ( not ini:section_exist( sect ) )
      and ini:section_exist( "logic" )
    then
      local cfg = get_string( "logic", "cfg", nil, ini )
      if cfg then
        ini = dsh.cached_ini_file( cfg )
      end
    end
  end
  if ini and ini:section_exist( sect ) then
    local conds = {}
    local n     = ini:line_count( sect )
    if n > 0 then
      for i = 0, n - 1 do
        local result, field, str = ini:r_line( sect, i, "", "" )
        str = string.gsub( str, "{\-aes_arrive_to}", "true" )
        conds[ field ] = xr_logic.parse_condlist( self, sect, field, str )
      end
      return conds
    end
  end
end


-- Вывод статистики по всем смартам в симуляции
function stat()
  log1(
    "--------------- Smart terrains statistics START ----------------------"
  )
  local jobs, jobs_in_avail, occupied
  local level_stats = {}
  for level_name, t in pairs( smart_terrains ) do
    jobs, jobs_in_avail, occupied = 0, 0, 0
    for id, strn in pairs( t ) do
      local avail, pop, cap = strn:stat()
      jobs     = jobs     + cap
      occupied = occupied + pop
      if avail then
        jobs_in_avail = jobs_in_avail + cap
      end
    end
    local l = {}
    level_stats[ level_name ] = l
    l.jobs          = jobs
    l.occupied      = occupied
    l.jobs_in_avail = jobs_in_avail
  end
  jobs, jobs_in_avail, occupied = 0, 0, 0
  log1( "" )
  for level_name, l in pairs( level_stats ) do
    log2( "Level %s :", level_name )
    log2( "    Jobs in all smart terrains : %d",       l.jobs )
    log2( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
    log2( "    Occupied jobs : %d",                    l.occupied )
    jobs          = jobs          + l.jobs
    jobs_in_avail = jobs_in_avail + l.jobs_in_avail
    occupied      = occupied      + l.occupied
  end
  log1( "All levels:" )
  log2( "    Jobs in all smart terrains : %d",       jobs )
  log2( "    Jobs in available smart terrains : %d", jobs_in_avail )
  log2( "    Occupied jobs : %d",                    occupied )
  log1(
    "--------------- Smart terrains statistics END ------------------------"
  )
end


function get_smart_terrain_by_name( name )
  local obj = smart_terrains_by_name[ name ]
  if obj then
    return alife():object( obj.id )
  end
end


function iterate_smart_terrains( f )
  for name, _ in pairs( smart_terrains_by_name ) do
    local sobj = get_smart_terrain_by_name( name )
    if sobj then
      f( sobj )
    end
  end
end


function get_monster_classes()
  return monster_classes
end


function se_smart_terrain:get_gulag_type()
  return self.gparams.type
end
