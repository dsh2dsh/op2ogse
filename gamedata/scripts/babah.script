-- -*- mode: lua; coding: windows-1251-dos -*-
local math_random = math.random

-- функция для запуска таймера при ондропе
function timeBombOut(id, sect)
  amk.start_timer("babah_drop_timeBomb", 0.2, {id = id, sect = sect})
end

-- функция для запуска таймера при ондропе
function mineOut(id, sect)
  amk.start_timer("babah_drop_mine", 0.2, {id = id, sect = sect})
end

-- функция для запуска таймера при ондропе
function detonatorOut(id, sect)
  amk.start_timer("babah_drop_detonator", 0.2, {id = id, sect = sect})
end

local bombs = {
  ["sect"] = {
    ["bomba"] = {
      ["onLevels"] = {},
      ["inInventory"] = {},
      ["ids"] = {}
    },
    ["bomba_small"] = {
      ["onLevels"] = {},
      ["inInventory"] = {},
      ["ids"] = {}
    },
    ["bomba_big"] = {
      ["onLevels"] = {},
      ["inInventory"] = {},
      ["ids"] = {}
    }
  },
  ["func"] = bombOut
}

timeBombs = {
  ["sect"] = {
    ["bomba_timer_n_10"] = {
      ["activated"] = "bomba_timer_n_10_activated",
      ["base"] = "bomba_timer_n_10_base"
    },
    ["bomba_timer_b_10"] = {
      ["activated"] = "bomba_timer_b_10_activated",
      ["base"] = "bomba_timer_b_10_base"
    },
    ["bomba_timer_n_30"] = {
      ["activated"] = "bomba_timer_n_30_activated",
      ["base"] = "bomba_timer_n_30_base"
    },
    ["bomba_timer_b_30"] = {
      ["activated"] = "bomba_timer_b_30_activated",
      ["base"] = "bomba_timer_b_30_base"
    }
  },
--  ["func"] = timeBombOut
}

local timeBombsBase = {
  ["bomba_timer_n_10_base"] = {
    ["inventory"] = "bomba_timer_n_10"
  },
  ["bomba_timer_b_10_base"] = {
    ["inventory"] = "bomba_timer_b_10"
  },
  ["bomba_timer_n_30_base"] = {
    ["inventory"] = "bomba_timer_n_30"
  },
  ["bomba_timer_b_30_base"] = {
    ["inventory"] = "bomba_timer_b_30"
  }
}

local timeBombsActivated = {
  ["bomba_timer_n_10_activated"] = {
    ["delay"] = 10
  },
  ["bomba_timer_n_10_activated"] = {
    ["delay"] = 10
  },
  ["bomba_timer_n_30_activated"] = {
    ["delay"] = 30
  },
  ["bomba_timer_b_30_activated"] = {
    ["delay"] = 30
  }
}

mines = {
  ["count"] = 0,
  ["sect"] = {
    ["bomba_mina_n"] = {
      ["delay"] = 5,
      ["onLevels"] = {},
      ["inInventory"] = {},
      ["ids"] = {}
    },
    ["bomba_mina_b"] = {
      ["delay"] = 5,
      ["onLevels"] = {},
      ["inInventory"] = {},
      ["ids"] = {}
    }
  },
--      ["func"] = mineOut
}

local detonators = {
  ["sect"] = {
    ["detonator"] = {
      ["probability"] = 0.75, -- вероятность удачного срабатывания, если нет секции - 1
      ["delay"] = 2, -- задержка в секундах, если нет секции - 0
      ["distance"] = 100,
      ["id"] = -1,
      ["name"] = "NK-32beta RUS",
      ["has"] = false,
      ["activated"] = false
    },
    ["detonator_2"] = {
      ["distance"] = 300,
      ["id"] = -1,
      ["name"] = "NK-37 RUS",
      ["has"] = false,
      ["activated"] = false
    }
  },
--      ["func"] = detonatorOut
}

local ignored_items = {
  ["device_torch"] = true,
  ["device_pda"]   = true,
  ["hand_radio"]   = true,
  ["guitar_a"]     = true,
  ["balalaika_a"]  = true,
  ["harmonica_a"]  = true,
  ["binocular_a"]  = true,
  ["wpn_knife"]    = true,
  ["wpn_binoc"]    = true,
  ["bolt"]         = true,
  ["yad"]          = true,
  ["player"]       = true,
}

local transferredBombs = {}
local explosivesAll

local funcBySect = {}
function collectFuncBySect(t)
  for k,v in pairs(t["sect"]) do
    funcBySect[k] = t["func"]
  end
end

collectFuncBySect(timeBombs)
collectFuncBySect(mines)
--collectFuncBySect(bombs) -- будем искать бомбы только при срабатывании детонатора
collectFuncBySect(detonators)
--amk.dump_table(funcBySect)

function messg(news_text, header)
  if not news_text or not header then return end
  local player=xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
  if player then
    player:play(db.actor, 0, sound_object.s2d)
    local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
    if db.actor then
      db.actor:give_game_news(news_text, "ui\\ui_VDGicon", Frect():set(0,47,83,47), 0, 5000)
    else
      get_console():execute("load ~~~ function messg(news_text, header) - db.actor == nil")
    end
  else
    get_console():execute("load ~~~ function messg(news_text, header) - sound not found: "..[[device\pda\pda_tip]])
  end
end

function li(ob)
  if ob and not has_alife_info( "biznes_remove_special_item" ) then
    local id = ob:id()
    local sect = ob:section()
    local f = funcBySect[ sect ]
    if f then
      f( id, sect )
    end
  end
end

function useDetonator(sect)
  if level.main_input_receiver() then
    level.start_stop_menu(level.main_input_receiver(), true)
  end
  if detonators["sect"][sect]["delay"] then
    -- запускаем таймер отсрочки активации детонатора
    amk.start_timer("babah_activateDetonator", detonators["sect"][sect]["delay"], sect)
  else
    explodeBombsByDetonator(sect)
  end
end

function explodeBombsByDetonator(sect)
  local detonator = detonators["sect"][sect]
  if detonator then
    local probability = detonator["probability"]
    if probability then
      if math_random() > probability then
        messg("Ошибка детонатора!", detonator["name"])
        return
      end
    end
    local actor = db.actor
    local sim = alife()
    local ggraph = game_graph()
    local level_object_by_id = level.object_by_id
    local radius = detonator["distance"]
    local anyBombsExploded = false
    local actorPos = actor:position()
    local invBoxExploded
    if actor and sim and ggraph:valid_vertex_id(actor:game_vertex_id()) then
      collectExplosivesAll()
      local levelName = sim:level_name(ggraph:vertex(actor:game_vertex_id()):level_id())
      explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelName]
      if explosivesOnLevel then
        for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
          if invBoxId ~= 0 then -- не подрываем у себя в рюкзаке
            invBox = level_object_by_id(invBoxId)
            if invBox and invBox:position():distance_to(actorPos) <= radius then
              invBoxExploded = false
              for explSect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
                if bombs["sect"][explSect] and explIds then
                  for j = #explIds, 1, -1 do
                    if explIds[j] then
                      explosive = level_object_by_id(explIds[j])
                      table.remove(explIds, j)
                      if explosive then
                        explode_r(explosive)
                        anyBombsExploded = true
                        invBoxExploded = true
                        break
                      end
                    end
                  end
                  if invBoxExploded then
                    explosivesOnLevel[invBoxId] = nil
                    break
                  end
                end
              end
            end
          end
        end
      end
      explosivesOnLevel = explosivesAll["online"]["onLevels"][levelName]
      if explosivesOnLevel then
        for explSect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
          if bombs["sect"][explSect] and explIds then
            for j = #explIds, 1, -1 do
              if explIds[j] then
                explosive = level_object_by_id(explIds[j])
                if explosive and explosive:position():distance_to(actorPos) <= radius then
                  table.remove(explIds, j)
                  explode_r(explosive)
                  anyBombsExploded = true
                end
              end
            end
          end
        end
      end
      if anyBombsExploded then
        messg("Взрывчатка взорвана!", detonator["name"])
      else
        messg("Ничего не взорвано!", detonator["name"])
      end
    end
  end
end

function dropMine(tbl)
  if level.main_input_receiver() then
    level.start_stop_menu(level.main_input_receiver(), true)
  end
  -- запускаем таймер активации мины
  amk.start_timer("babah_activateMine", mines["sect"][tbl.sect]["delay"], tbl)
end

function dropTimeBomb(tbl)
  -- превращаем инвентарную бомбу в обычную
  if level.main_input_receiver() then
    level.start_stop_menu(level.main_input_receiver(), true)
  end
  if timeBombs["sect"][tbl.sect] then
    local obj = level.object_by_id(tbl.id)
    if obj then
      local sim = alife()
      local actor = db.actor
      local sect = timeBombs["sect"][tbl.sect]["base"]
      local pos = obj:position()
      local lv = obj:level_vertex_id()
      local gv = obj:game_vertex_id()
      if not game_graph():valid_vertex_id(gv) then
        gv = actor:game_vertex_id()
        if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
          messg("Здесь странное место...", "Локальная сеть")
          return
        end
      end
      sim:release(sim:object(tbl.id), true)
      sim:create(sect, pos, lv, gv)
    end
  end
end

function relocateTimeBomb(tbl)
  -- превращаем обычную бомбу в инвентарную
  if transferredBombs[tbl.id] then
    transferredBombs[tbl.id] = nil
  elseif timeBombs["sect"][tbl.sect] then -- переложили из своего инвентаря
    local sim = alife()
    local obj = level.object_by_id(tbl.id)
    local se_obj = sim:object(tbl.id)
    if obj and se_obj then
      local parent = obj:parent()
      local se_parent = sim:object(se_obj.parent_id)
      if parent then
        local sect = timeBombs["sect"][tbl.sect]["base"]
        local pos = se_parent.position
        local lv = se_parent.m_level_vertex_id
        local gv = se_parent.m_game_vertex_id
        if not game_graph():valid_vertex_id(gv) then
          gv = db.actor:game_vertex_id()
          if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
            messg("Здесь странное место...", "Локальная сеть")
            return
          end
        end
        local parent_id = se_parent.id
        sim:release(se_obj, true)
        local new_se_obj = sim:create(sect, pos, lv, gv, parent_id)
        if parent:clsid() == clsid.inventory_box then
          -- ящики совсем охренели
          amk.start_timer("babah_timeBomb_transfer", 0.2, new_se_obj.id)
        end
      end
    end
  end
end

function transferTimeBomb(id)
  local obj = level.object_by_id(id)
  if obj and db.actor then
    local invBox = obj:parent()
    if invBox then
      transferredBombs[id] = true
      invBox:transfer_item(obj, db.actor)
      db.actor:transfer_item(obj, invBox)
    end
  end
end

function on_item_take(obj)
  -- превращаем обычную бомбу в инвентарную
  local id = obj:id()
  if transferredBombs[id] then
    transferredBombs[id] = nil
  elseif obj then
    local sect = obj:section()
    local timeBombBase = timeBombsBase[sect]
    if timeBombBase then -- переложили в свой инвентарь бомбу с таймером
      local sim = alife()
      local parent = obj:parent()
      if parent then
        local newSect = timeBombBase["inventory"]
        local pos = parent:position()
        local lv = parent:level_vertex_id()
        local gv = parent:game_vertex_id()
        if not game_graph():valid_vertex_id(gv) then
          gv = db.actor:game_vertex_id()
          if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
            messg("Здесь странное место...", "Локальная сеть")
            return
          end
        end
        local parent_id = parent:id()
        sim:release(sim:object(id), true)
        sim:create(newSect, pos, lv, gv, parent_id)
      end
    end
  end
end

function useTimeBomb(tbl)
  if level.main_input_receiver() then
    level.start_stop_menu(level.main_input_receiver(), true)
  end
  if transferredBombs[tbl.id] then
    transferredBombs[tbl.id] = nil
  elseif db.actor then
    local actor = db.actor
    local newSect = timeBombs["sect"][tbl.sect]["activated"]
    local delay = timeBombsActivated[newSect]["delay"]
    local pos = actor:position()
    local lv = actor:level_vertex_id()
    local gv = actor:game_vertex_id()
    if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
      messg("Здесь странное место...", "Локальная сеть")
      return
    end
    se_obj = alife():create(newSect, pos, lv, gv, actor:id())
    amk.start_timer("babah_timeBomb_activated", delay, se_obj.id)
    messg("Таймер запущен! Нужно срочно выложить взрывчатку и отойти на безопасное расстояние.", "Взрывчатка")
  end
end

function explosiveExplode(id)
  local sim = alife()
  local level_object_by_id = level.object_by_id
  local se_obj = sim:object(id)
  if se_obj then
    local obj = level_object_by_id(id)
    if obj then
      -- проверка на то, что взрывчатку кто-то подобрал
      if se_obj.parent_id and se_obj.parent_id ~= 65535 then
        -- перемещаем её к хозяину
        local sect = obj:section()
        local parent = level_object_by_id(se_obj.parent_id)
        if parent then
          if parent:clsid() == clsid.inventory_box then
            collectExplosivesAll()
            explode_r(obj)
          else
            local pos = parent:position()
            local lv = parent:level_vertex_id()
            local gv = parent:game_vertex_id()
            if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
              messg("Здесь странное место...", "Локальная сеть")
              return
            end
            sim:release(se_obj, true)
            se_obj = sim:create(sect, pos, lv, gv, parent:id())
            amk.start_timer("babah_explode_moved_timeBomb", 0.2, se_obj.id)
          end
        end
      else
        collectExplosivesAll()
        explode_r(obj)
        amk.send_tip("Взрывчатка взорвана", nil, 4)
      end
    else -- объект на другой территории или в оффлайне
      collectExplosivesAll()
      explodeOffline(se_obj, true)
    end
  end
end

function collectExplosivesAll()
        -- собираем информацию о взрывчатках
  explosivesAll = {
    ["online"] = {
      ["onLevels"] = {},
      ["onLevelsInInventory"] = {},
    },
    ["offline"] = {
      ["onLevels"] = {},
      ["onLevelsInInventory"] = {},
    },
  }
  local explOnlineOnLevels = explosivesAll["online"]["onLevels"]
  local explOnlineOnLevelsInInventory = explosivesAll["online"]["onLevelsInInventory"]
  local explOfflineOnLevels = explosivesAll["offline"]["onLevels"]
  local explOfflineOnLevelsInInventory = explosivesAll["offline"]["onLevelsInInventory"]
  local sim = alife()
  local ggraph = game_graph()
  local level_object_by_id = level.object_by_id
  local levelName
  local correct
  local parent_id
  local obj, se_obj, p_obj
  local explTmp
  local t
  local sect
  for i = 1, 65534 do
    se_obj = sim:object(i)
    if se_obj and se_obj:clsid() == clsid.obj_explosive then
      sect = se_obj:section_name()
      correct = false
      parent_id = se_obj.parent_id
      if parent_id and parent_id ~= 65535 then
        -- в коллекцию по инвентарям
        p_obj = sim:object(parent_id)
        if p_obj and ggraph:valid_vertex_id(p_obj.m_game_vertex_id) then
          levelName = sim:level_name(ggraph:vertex(p_obj.m_game_vertex_id):level_id())
          obj = level_object_by_id(parent_id)
          if obj then
            explTmp = explOnlineOnLevelsInInventory
          else
            explTmp = explOfflineOnLevelsInInventory
          end
          if not explTmp[levelName] then
            explTmp[levelName] = {}
          end
          if not explTmp[levelName][parent_id] then
            explTmp[levelName][parent_id] = {}
          end
          if not explTmp[levelName][parent_id][sect] then
            explTmp[levelName][parent_id][sect] = {}
          end
          t = explTmp[levelName][parent_id][sect]
          table.insert(t, i)
          correct = true
        end
      elseif ggraph:valid_vertex_id(se_obj.m_game_vertex_id) then
        -- в коллекцию по уровням
        levelName = sim:level_name(ggraph:vertex(se_obj.m_game_vertex_id):level_id())
        obj = level_object_by_id(i)
        if obj then
          explTmp = explOnlineOnLevels
        else
          explTmp = explOfflineOnLevels
        end
        if not explTmp[levelName] then
          explTmp[levelName] = {}
        end
        if not explTmp[levelName][sect] then
          explTmp[levelName][sect] = {}
        end
        t = explTmp[levelName][sect]
        table.insert(t, i)
        correct = true
      end
      if correct then
        -- в общую коллекцию
      else
        get_console():execute("load ~~~ FAILED collectExplosivesAll(): "..se_obj.id.." sect - "..se_obj:section_name()..", parent_id - "..tostring(se_obj.parent_id))
      end
    end
  end
end

function explodeMovedTimeBomb(id)
  local se_obj = alife():object(id)
  local obj = level.object_by_id(se_obj.id)
  if obj and se_obj then
    collectExplosivesAll()
    explode_r(obj)
  end
end

local itemsTransferBack = {}

function explode_r(ob)
  if ob then
    hitExplosive(ob)
    local level_object_by_id = level.object_by_id
    local obj = ob
    local parent_id
    if ob:parent() then
      parent_id = ob:parent():id()
      if parent_id and parent_id ~= 65535 then
        obj = level_object_by_id(parent_id) -- получаем объект хозяина
      end
    end
    local id = ob:id()
    local pos = obj:position()
    local sect = ob:section()
    local sim = alife()
    local ggraph = game_graph()
    if obj:id() ~= id then -- взрывчатка в инвентаре
      if (obj.character_community and obj:character_community() == "trader") or
        rx_utils.read_from_ini(nil, obj:section(), "immunities_sect", "", 1) == "stalker_immunities_sakharov"
      then -- чтобы не трясли торговцев и бессмертных неписей
        local h = hit()
        h.power = 100
        h.impulse = 0
        h.draftsman = db.actor
        h.direction = vector():set(0,0,0)
        h.type = hit.fire_wound
        obj:hit(h)
        db.actor:set_character_community("monolith", 0, 0)
        return
      end
      pos.y = pos.y + 0.5
      local lv = obj:level_vertex_id()
      local gv = obj:game_vertex_id()
      if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
        messg("Здесь странное место...", "Локальная сеть")
        return
      end
      -- удаляем всё из инвентаря
      local isNPC = IAmAStalker[obj:clsid()] or IAmAMonster[obj:clsid()]
      itemsTransferBack = {}
      if isNPC and obj:alive() then
        db.actor:give_info_portion("biznes_remove_special_item")
        obj:iterate_inventory(
          function(dummy,item)
            if item:id() ~= id and not ignored_items[item:section()] then
              obj:drop_item(item)
            end
          end,
          obj
        )
        db.actor:disable_info_portion("biznes_remove_special_item")
      else -- для тайников и трупов
        if db.actor then
          local packet
          local sect, se_obj
          local items = {}
          local inv_obj
          for i = 1, 65534 do
            if i ~= id then
              se_obj = sim:object(i)
              if se_obj and se_obj.parent_id == parent_id then
                inv_obj = level_object_by_id(se_obj.id)
                if inv_obj then
                  if isNPC then
                    obj:drop_item(inv_obj)
                  else
                    if se_obj.online then
                      sect = inv_obj:section()
                      if timeBombs["sect"][sect] or timeBombsActivated[sect] or timeBombsBase[sect] then
                        transferredBombs[i] = true
                      end
                      obj:transfer_item(inv_obj, db.actor)
                      -- собираем предметы для следующей переброски обратно в тайник, иначе - вылет, если какой-то из предметов подходит в пустой слот оружия и ГГ не имеет в данный момент активного предмета в руках
                      table.insert(itemsTransferBack, se_obj.id)
                      -- сработает через некоторое время таймером
                    end
                  end
                else
                  amk.send_tip("babah obj == nil: id "..se_obj.id..", name "..se_obj:name())
                  get_console():execute("load ~~~ function explode_r(ob) - babah obj == nil: id "..se_obj.id..", name "..se_obj:name())
                end
              end
            end
          end
        end
      end
      if #itemsTransferBack > 0 then
        amk.start_timer("babah_transfer_items", 0.1, {invId = obj:id(), explId = id, itemsTransferBack = itemsTransferBack})
      else
        hitExplosive(ob)
        local levelName = sim:level_name(ggraph:vertex(obj:game_vertex_id()):level_id())
        amk.start_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
      end
    else
      hitExplosive(ob)
      local levelName = sim:level_name(ggraph:vertex(obj:game_vertex_id()):level_id())
      amk.start_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
    end
  else
    amk.send_tip("Взрывчатка не взорвана. Она не найдена.", nil, 2)
  end
end

function itemsTransferBackToInventory(tbl)
  local level_object_by_id = level.object_by_id
  local inventory = level_object_by_id(tbl.invId)
  if inventory then
    local pos = inventory:position()
    pos.y = pos.y + 0.5
    local lv = inventory:level_vertex_id()
    local gv = inventory:game_vertex_id()
    if not game_graph():valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
      messg("Здесь странное место...", "Локальная сеть")
      return
    end
    local sim = alife()
    local obj, se_obj
    local packet
    local sect
    db.actor:give_info_portion("biznes_remove_special_item")
    for i = 1, #tbl.itemsTransferBack do
      obj = level_object_by_id(tbl.itemsTransferBack[i])
      se_obj = sim:object(tbl.itemsTransferBack[i])
      if obj and se_obj and obj:parent() and obj:parent():id() == 0 then
        sect = obj:section()
        db.actor:transfer_item(obj, inventory)
        packet = net_packet() -- создаём пустой пакет
        se_obj:STATE_Write(packet) -- загрузили в наш пакет состояние серверного объекта
        -- используя методы класса net_packet меняем нужные нам значения.
        sim:release(se_obj, true)
        se_obj = sim:create(sect, pos, lv, gv)
        se_obj:STATE_Read(packet, packet:w_tell()) -- записали в объект изменённое состояние обратно, имитируя процесс его загрузки
      end
    end
    db.actor:disable_info_portion("biznes_remove_special_item")
    itemsTransferBack = {}
    local explosive = level_object_by_id(tbl.explId)
    if explosive then
      hitExplosive(explosive)
    end
    local levelName = sim:level_name(game_graph():vertex(inventory:game_vertex_id()):level_id())
    amk.start_timer("babah_explode_biside_explosives", 0.5, {id = explosive:id(), sect = explosive:section(), x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = levelName})
  else
    get_console():execute("load ~~~ function itemsTransferBackToInventory(tbl) - inventory == nil: id "..tostring(tbl.invId))
  end
end

function explodeBisideExplosives(tbl)
  local sim = alife()
  local ggraph = game_graph()
  local level_object_by_id = level.object_by_id
  local explosivesOnLevel
  local explosive
  local explId = tbl.id
  local levelNameExplosive = tbl.lvl
  local explPos = vector():set(tbl.x, tbl.y, tbl.z)
  local infoExplosive = collectExplosiveInfo(tbl.sect)
  local radius = infoExplosive["blast_r"]
  -- подрываем взрывчатку рядом
  local invBox
  local invBoxExploded
  explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelNameExplosive]
  if explosivesOnLevel then
    for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
      invBox = level_object_by_id(invBoxId)
      invBoxExploded = false
      if invBox and invBox:position():distance_to(explPos) <= radius then
        for sect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
          if explIds then
            for j = #explIds, 1, -1  do -- а здесь можно и с предметами в инвентаре что-то сделать, если их запомнить вместе со взрывчаткой перед этим
              if explIds[j] then
                if explIds[j] ~= explId then
                  explosive = level_object_by_id(explIds[j])
                  table.remove(explIds, j)
                  if explosive then
                    invBoxExploded = true
                    explode_r(explosive)
                    break
                  end
                else
                  table.remove(explIds, j)
                end
              end
            end
          end
          if invBoxExploded then
            explosivesOnLevel[invBoxId] = nil
            break
          end
        end
      end
    end
  end
  explosivesOnLevel = explosivesAll["online"]["onLevels"][levelNameExplosive]
  if explosivesOnLevel then
    for sect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
      if explIds then
        for j = #explIds, 1, -1 do
          if explIds[j] then 
            if explIds[j] ~= explId then
              explosive = level_object_by_id(explIds[j])
              if explosive and explosive:position():distance_to(explPos) <= radius then
                table.remove(explIds, j)
                explode_r(explosive)
              end
            else
              table.remove(explIds, j)
            end
          end
        end
      end
    end
  end
end


function hitExplosive( ob )
  if ob and ob:is_explosive() then
    ob:explode()
  end
end


function collectBombs()
  local sim = alife()
  local se_obj, sect
  for i = 1, 65534 do
    se_obj = sim:object(i)
    if se_obj and se_obj.parent_id == 65535 then -- лежит на земле
      sect = se_obj:section_name()
      if mines["sect"][sect] then
        addMine(se_obj)
      end
    end
  end
end

function addMine(se_obj)
  if se_obj then
    local sect = se_obj:section_name()
    local mine = mines["sect"][sect]
    if mine then
      local sim = alife()
      local ggraph = game_graph()
      local levelName
      local correct = false
      local parent_id = se_obj.parent_id
      if parent_id == 65535 and ggraph:valid_vertex_id(se_obj.m_game_vertex_id) then
        -- в коллекцию по уровням
        levelName = sim:level_name(ggraph:vertex(se_obj.m_game_vertex_id):level_id())
        if not mine["onLevels"][levelName] then
          mine["onLevels"][levelName] = {}
        end
        local t = mine["onLevels"][levelName]
        table.insert(t, se_obj.id)
        correct = true
      end
      if correct then
        -- в общую коллекцию
        local t = mine["ids"]
        table.insert(t, se_obj.id)
        mines["count"] = mines["count"] + 1
      else
        get_console():execute("load ~~~ FAILED addMine(): "..se_obj.id.." sect - "..sect..", parent_id - "..tostring(se_obj.parent_id))
      end
    end
  end
end


function update(delta)
  if mines["count"] > 0 then
    local npcOnline  = db.storage
    local npcOffline = {}
    if npcOnline and npcOffline then
      local npcObj, mineObj
      local level_object_by_id = level.object_by_id
      local onLevels, inInventory, ids
      local mineId, parentId
      local minePos
      local sim = alife()
      local found = false
      local levelOfflineData, offlineNPCs
      local ggraph = game_graph()
      local actorLevelName
      if ggraph:valid_vertex_id(db.actor:game_vertex_id()) then
        actorLevelName = sim:level_name(ggraph:vertex(db.actor:game_vertex_id()):level_id())
      end
      -- проверяем на расстояние между минами и онлайновыми неписями
      for k,v in pairs(mines["sect"]) do
        onLevels = v["onLevels"]
        for levelName, levelData in pairs(onLevels) do
          if levelData then
            for i = #levelData, 1, -1 do
              mineId = levelData[i]
              if mineId then
                mineObj = sim:object(mineId)
                if mineObj then
                  parentId = mineObj.parent_id
                  -- если кто-то поднял мину (ловкий парень :))
                  if parentId and parentId ~= 65535 then
                    -- перемещаем мину в список по инвентарям и не взрываем
                    inInventory = v["inInventory"]
                    table.insert(inInventory, mineId)
                    table.remove(levelData, i)
                  else
                    minePos = mineObj.position
                    -- поиск в онлайне
                    if actorLevelName == levelName then
                      for npcId, npc in pairs(npcOnline) do
                        npcObj = level_object_by_id(npcId)
                        if npcObj and (IAmAStalker[npcObj:clsid()] or IAmAMonster[npcObj:clsid()]) and npcObj:alive() and npcObj:position():distance_to(minePos) <= 1.5 then
                          found = true
                          break
                        end
                      end
                    end
                    -- поиск в оффлайне
                    levelOfflineData = npcOffline[levelName]
                    if levelOfflineData then
                      if not found then
                        offlineNPCs = levelOfflineData["monsters"]
                        if offlineNPCs then
                          for j = 1, #offlineNPCs do
                            if offlineNPCs[j]["id"] then
                              npcObj = sim:object(offlineNPCs[j]["id"])
                              if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1.5 then
                                found = true
                                break
                              end
                            end
                          end
                        end
                      end
                      if not found then
                        offlineNPCs = levelOfflineData["stalkers"]
                        if offlineNPCs then
                          for j = 1, #offlineNPCs do
                            if offlineNPCs[j]["id"] then
                              npcObj = sim:object(offlineNPCs[j]["id"])
                              if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1.5 then
                                found = true
                                break
                              end
                            end
                          end
                        end
                      end
                    end
                    if found then
                      -- удаляем мину из таблицы
                      table.remove(levelData, i)
                      ids = v["ids"]
                      for j = #ids, 1, -1 do
                        if ids[j] == mineId then
                          table.remove(ids, j)
                          break
                        end
                      end
                      mines["count"] = mines["count"] - 1
                      found = false
                      -- взрываем мину
                      explosiveExplode(mineId)
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end

-- подрыв в оффлайне
function explodeOffline(se_obj, first)
  if se_obj then
    local infoExplosive = collectExplosiveInfo(se_obj:section_name())
    local radius = infoExplosive["blast_r"]
    if infoExplosive["frags"] > 0 then
      radius = math.max(radius, infoExplosive["frags_r"])
    end
    local sim = alife()
    local obj = se_obj
    local parent_id = se_obj.parent_id
    if parent_id and parent_id ~= 0 and parent_id ~= 65535 then
      obj = sim:object(parent_id) -- получаем объект хозяина
    end
    local ggraph = game_graph()
    if ggraph:valid_vertex_id(obj.m_game_vertex_id) then
      local infoVictimsOffline = collectExplosiveVictimsOffline(obj, radius)
      damageVictimsOffline(infoVictimsOffline, infoExplosive)
      if first then
        --local packet
        local explosivesOnLevel
        local explosive
        local explId = se_obj.id
        local explPos = obj.position
        local levelNameExplosive = sim:level_name(ggraph:vertex(obj.m_game_vertex_id):level_id())
        -- взрывчатка отработала
        sim:release(se_obj, true)
        -- подрываем взрывчатку рядом
        local invBox
        explosivesOnLevel = explosivesAll["offline"]["onLevelsInInventory"][levelNameExplosive]
        if explosivesOnLevel then
          for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
            invBox = sim:object(invBoxId)
            if invBox and invBox.position:distance_to(explPos) <= radius then
              for sect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
                if explIds then
                  for j = #explIds, 1, -1 do -- а здесь можно и с предметами в инвентаре что-то сделать, если их запомнить вместе со взрывчаткой перед этим
                    if explIds[j] then
                      if explIds[j] ~= explId then
                        explosive = sim:object(explIds[j])
                        table.remove(explIds, j)
                        if explosive then
                          explodeOffline(explosive, true)
                        end
                      else
                        table.remove(explIds, j)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        explosivesOnLevel = explosivesAll["offline"]["onLevels"][levelNameExplosive]
        if explosivesOnLevel then
          for sect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
            if explIds then
              for j = #explIds, 1, -1 do
                if explIds[j] then
                  if explIds[j] ~= explId then
                    explosive = sim:object(explIds[j])
                    if explosive and explosive.position:distance_to(explPos) <= radius then
                      table.remove(explIds, j)
                      explodeOffline(explosive, true)
                    end
                  else
                    table.remove(explIds, j)
                  end
                end
              end
            end
          end
        end
      else
        sim:release(se_obj, true)
      end
      if first then
        messg("Взорвано на другой территории.", "Взрывчатка")
      end
    else
      if first then
        amk.send_tip("Взрывчатка НЕ взорвана! Она в кривом месте...", nil, 2)
      end
    end
  end
end

-- для кеширования данных
local explosivesInfo = {}

function collectExplosiveInfo(section)
  if not explosivesInfo[section] then
    local explosive = {
      ["blast"] = 1.5,
      ["blast_r"] = 2,
      ["blast_impulse"] = 200,
      ["blast_impulse_factor"] = 1,
      ["frags"] = 0,
      ["frags_r"] = 15,
      ["frag_hit"] = 0.25,
      ["frag_hit_impulse"] = 150,
      ["hit_type_blast"] = "explosion",
      ["hit_type_frag"] = "burn"
    }
    for k, v in pairs(explosive) do
      local varType = type(explosive[k])
      if varType == "number" then
        explosive[k] = getIniValueFloat(section, k, v, nil)
      elseif varType == "string" then
        explosive[k] = getIniValueString(section, k, v, nil)
      end
    end
    explosivesInfo[section] = explosive
  end
  return explosivesInfo[section]
end

-- собираем информацию о жертвах
-- код повзаимствован из amk_offline_alife.offline_alife()
function collectExplosiveVictimsOffline(se_obj, radius)
  local sim = alife()
  local vdata = {}
  local ggraph = game_graph()
  if ggraph:valid_vertex_id(se_obj.m_game_vertex_id) then
    local map = sim:level_name(ggraph:vertex(se_obj.m_game_vertex_id):level_id())
    local off_npcs = amk_offline_alife.off_npcs
    local explPos = se_obj.position
    -- по сталкерам
    local function collectNPCs(offNPCs)
      if offNPCs then
        local offNPC
        local victim
        local sect
        local dist
        for a = 1, #offNPCs do
          offNPC = offNPCs[a]
          if offNPC then
            victim = sim:object(offNPC.id)
            if victim and victim.health and victim:health() > 0
              and victim.can_switch_online and victim:can_switch_online()
            and victim:name() == offNPC.name then
              sect = victim:section_name()
              dist = explPos:distance_to(victim.position)
              if dist <= radius then
                table.insert(vdata, {["id"] = victim.id, ["dist"] = dist, ["squere"] = getVictimSquare(sect)})
              end
            end
          end
        end
      end
    end
    collectNPCs(off_npcs[map].stalkers)
    collectNPCs(off_npcs[map].monsters)
  end
  return vdata
end

-- для кеширования данных
local victimsSquare = {}

function getVictimSquare(sect)
  if not victimsSquare[sect] then
    local victimSize = {0.5, 0.9, 0.5}
    local tmp = parse_nums(getIniValueString(sect, "ph_box0_size", table.concat(victimSize,", "), nil))
    if #tmp == 3 then
      victimSize = tmp
    end
    victimsSquare[sect] = (victimSize[1] + victimSize[3]) / 2 * victimSize[2]
  end
  return victimsSquare[sect]
end

function damageVictimsOffline(infoVictimsOffline, infoExplosive)
  local sim = alife()
  local se_obj
  local damage
  local health
  for i = 1, #infoVictimsOffline do
    se_obj = sim:object(infoVictimsOffline[i].id)
    if se_obj then
      damage = calcDamageForVictim(infoVictimsOffline[i], infoExplosive)
      if damage > 0 then
        health = se_obj:health() - damage
        if health < 0 then
          health = 0
        end
        amk_offline_alife.set_npc_health(se_obj, health)
      end
    end
  end
end

function calcDamageForVictim(victimInfo, infoExplosive)
  local rNorm = victimInfo["dist"] / infoExplosive["blast_r"]
  local damage = 0
  if victimInfo["dist"] < infoExplosive["blast_r"] then
    damage = infoExplosive["blast"] * (1 - rNorm * rNorm) * victimInfo["squere"]
    -- (1 - x ^ 2) http://yotx.ru/default.aspx?clr0=000000&exp0=1+-+x*x&mix=0&max=1&asx=on&u=mm&nx=X&aiy=on&asy=on&ny=Y&iw=600&ih=400&ict=png&aa=on
  end
  if infoExplosive["frags"] > 0 and victimInfo["dist"] < infoExplosive["frags_r"] then
    -- вероятность попадания
    local sphereSquere = 4 * math.pi * victimInfo["dist"] * victimInfo["dist"]
    local prob = victimInfo["squere"] / sphereSquere
    for i = 1, infoExplosive["frags"] do
      if math_random() < prob then
        damage = damage + infoExplosive["frag_hit"]
      end
    end
  end
  -- его величество Случай
  damage = damage * (1 - math_random()*math_random()*math_random()*math_random())
  return damage
end
