table_group = {
	["Diary"]=game.translate_string("bind_stalker_table_group_1_text"),
	["Mutants"]=game.translate_string("bind_stalker_table_group_2_text"),
	["Social"]=game.translate_string("bind_stalker_table_group_3_text"),
	["Artifacts"]=game.translate_string("bind_stalker_table_group_4_text"),
	["Klondike_Artifacts"]=game.translate_string("bind_stalker_table_group_4_text"),
	["Anomalies"]=game.translate_string("bind_stalker_table_group_5_text"),
	["Locations"]=game.translate_string("bind_stalker_table_group_6_text"),
	["Zone-story"]=game.translate_string("bind_stalker_table_group_7_text"),
	["Stories"]=game.translate_string("bind_stalker_table_group_8_text"),
	["memuars"]=game.translate_string("bind_stalker_table_group_9_text"), 
	["Found_PDA"]=game.translate_string("bind_stalker_table_group_10_text"), 
	["st_operation_agroprom"]=game.translate_string("bind_stalker_table_group_1_text"),
	["LabX18_information"]=game.translate_string("bind_stalker_table_group_1_text"), 
	["aes_military_task"]=game.translate_string("bind_stalker_table_group_1_text"),
	["Vehicles"]=game.translate_string("bind_stalker_table_group_1_text"),
	["Hunter_tips"]=game.translate_string("bind_stalker_table_group_1_text"),
}

function init(obj)
	xr_motivator.AddToMotivator(obj)
end

function actor_init(npc)
	npc:bind_object(actor_binder(npc))
end

local game_difficulty_by_num = {
	[0] = "gd_novice",
	[1] = "gd_stalker",
	[2] = "gd_veteran",
	[3] = "gd_master"
	}

lasthealth  = 0
lasttime	= 0
post_process = 0
local weapon_hide = false

local sim = alife()
----------------------------------------------------------------------------------------------------------------------
class "actor_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function actor_binder:__init(obj) super(obj)
	self.object:disable_info_portion("ui_inventory")
	sim = alife()
	self.bCheckStart = false
	self.actor_detector = xr_detector.actor_detector()
	self.am = ogse_signals.get_mgr()
	self.am:call("on_load_before_all")
	self.am:call("on_init", obj)
	event("actor_init"):trigger({object = obj})
end
function actor_binder:__finalize()
	self.am:call("on_finalize", obj)
	event("actor_finalize"):trigger()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_spawn(data)
	ogse_debug.process_actor("a_spw", 1)
	
	get_console():execute("r2_dof_control off")
	
	level.show_indicators()
	xr_gulag.make_restrictors_registry()
	
	-->>!! Убрать это безобразие в релизе, это затычки проблем
--[[	for i = 1,65535 do
		local sobj = alife():object(i)
		if sobj and (sobj:name() == "bar_restrictor" or sobj:name() == "val_bandits_weaponry_restr") then
			local pk = xs_netpk.space_restrictor(sobj)
			if pk:isOk() then
				local data = pk:get()
				if data.restrictor_type ~= 3 then
					data.restrictor_type = 3
					pk:set(data)
					log1("!!WRITE_BAR_RESTRICTOR_SUCCESS")
				end
			end
		elseif sobj and string.find(sobj:name(), "pri_wave") and has_alife_info("pri_stadium_scene_start") then
			local pk = xs_netpk.smart_terrain(sobj)
			if pk:isOk() then
				local data = pk:get()
				print_table_inlog_v2(data, "!!PKT_"..sobj:name())
				local str = data.custom_data:getString()
				if not string.find(str, "cond") then
					str = str.."\ncond = {-pri_stadium_scene_start}"
					data.custom_data:setString(str)
					pk:set(data)
					log1("!!"..sobj:name().."WRITE_SMTR_SUCCESS")
				end
			end						
		end
	end
	local sobj_safe_petrenko = alife():story_object(story_ids.lockedsafe_2)
	if not sobj_safe_petrenko then
		local spawn_db = ogse_spawn_db.script_spawn_registry.jekan_quests
		ogse.spawn_object(spawn_db.safe2_shron)
		log1("!!REANIMATE_PETRENKO_SAFE_SUCCESS")
	end]]
	---<<---
	
	ogse_debug.process_actor("a_spw", 2)
	
	self.bCheckStart = true
	self.weapon_hide = false -- спрятано или нет оружие при разговоре.
	weapon_hide = false -- устанавливаем глобальный дефолтовый флаг.
	
	ogse_debug.process_actor("a_spw", 3)

	--[[if object_binder.net_spawn(self,data) == false then
		ogse_debug.process_actor("a_spw", 0)
		return false
	end]]
	
	ogse_debug.process_actor("a_spw", 4)

	db.add_actor(self.object)
	
	ogse_debug.process_actor("a_spw", 5)
	
	set_extensions_flags(15)
	
	ogse_debug.process_actor("a_spw", 6)

	if self.st.disable_input_time == nil then
		level.enable_input()
	end
	
	ogse_debug.process_actor("a_spw", 7)

	ogse_debug.process_actor("a_spw", 8)

	if(actor_stats.add_to_ranking~=nil)then
		actor_stats.add_to_ranking(self.object:id())
	end
	
	ogse_debug.process_actor("a_spw", 9)

	--' Загружаем настройки дропа
	death_manager.init_drop_settings()
	
	ogse_debug.process_actor("a_spw", 10)
	
	
	ogse_debug.process_actor("a_spw", 11)
	
    ogse.on_game_load()
	
	ogse_debug.process_actor("a_spw", 12)

	-- инициализация дополнительных схем
	if xrs_ai then
		xrs_ai.actor_net_spawn(self)
	end
	
	ogse_debug.process_actor("a_spw", 13)
   
	if rx_ai then
		rx_ai.actor_net_spawn()
	end
	
	ogse_debug.process_actor("a_spw", 14)
	
	local screen = device()
	local scr_width = screen.width
	local scr_height = screen.height

	if scr_width > 0 and scr_height > 0 then
		ui_rad.orig_aspect = scr_width / scr_height
	end	
	
	ogse_debug.process_actor("a_spw", 15)
	
-------- пауза при загрузке ---------------
	ui_main_menu.start()
-------------------------------------------

	ogse_debug.process_actor("a_spw", 0)

	self.am:call("on_spawn", data)
	event("actor_spawn"):trigger({data = data})
	return true
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_destroy()
	if(actor_stats.remove_from_ranking~=nil)then
		actor_stats.remove_from_ranking(self.object:id())
	end
--	game_stats.shutdown ()
	set_extensions_flags(0)
	db.del_actor(self.object)

    sr_light.clean_up ()

	self.object:set_callback(callback.inventory_info, nil)
	self.object:set_callback(callback.article_info, nil)
	self.object:set_callback(callback.on_item_take, nil)
	self.object:set_callback(callback.on_item_drop, nil)
	--self.object:set_callback(callback.actor_sleep, nil)
	self.object:set_callback(callback.task_state, nil)
	self.object:set_callback(callback.level_border_enter, nil)
	self.object:set_callback(callback.level_border_exit, nil)
	self.object:set_callback(callback.take_item_from_box, nil)
	self.object:set_callback(callback.use_object, nil)
	
	self.object:set_callback(callback_ex.on_key_press, nil)
	self.object:set_callback(callback_ex.on_key_release, nil)
	self.object:set_callback(callback_ex.on_key_hold, nil)
	self.object:set_callback(callback_ex.on_mouse_wheel, nil)
	self.object:set_callback(callback_ex.on_mouse_move, nil)
	self.object:set_callback(callback_ex.on_belt, nil)
	self.object:set_callback(callback_ex.on_ruck, nil)
	self.object:set_callback(callback_ex.on_slot, nil)
	self.object:set_callback(callback_ex.on_hud_animation_end, nil)
	self.object:set_callback(callback.hit, nil)
	
	self.object:set_callback(callback_ex.on_goodwill_change, nil)
--	self.object:set_callback(callback_ex.on_release_npc, nil)
	
	self.object:set_callback(callback.death, nil)

	self.object:set_callback(callback_ex.dbg_gg_distance_failed, nil)

	self.object:set_callback(callback_ex.entity_alive_before_hit, nil)
	self.object:set_callback(callback_ex.on_before_use_item, nil)

	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:destroy()
		sr_psy_antenna.psy_antenna = false
	end

	xr_sound.stop_all_sound_object()
	
	ogse_dynamic_hud.switch_shader_effects("off")
	cmd("r2_render_mode normal")

	ogse.on_net_destroy()
	self.am:call("on_destroy")
	event("actor_destroy"):trigger()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:reinit()
	local npc_id = self.object:id()

	db.storage[npc_id] = { }

	self.st = db.storage[npc_id]
	self.st.pstor = nil

	self.next_restrictors_update_time = -10000

	self.object:set_callback(callback.inventory_info, self.info_callback, self)
	self.object:set_callback(callback.article_info, self.article_callback, self)
	self.object:set_callback(callback.on_item_take, self.on_item_take, self)
	self.object:set_callback(callback.on_item_drop, self.on_item_drop, self)
	self.object:set_callback(callback.trade_sell_buy_item, self.on_trade, self) -- for game stats
	--self.object:set_callback(callback.actor_sleep, self.sleep_callback, self) -- сна в движке нет
	self.object:set_callback(callback.task_state, self.task_callback, self)
	--self.object:set_callback(callback.map_location_added, self.map_location_added_callback, self)
	self.object:set_callback(callback.level_border_enter, self.level_border_enter, self)
	self.object:set_callback(callback.level_border_exit, self.level_border_exit, self)
	self.object:set_callback(callback.take_item_from_box, self.take_item_from_box, self)
	self.object:set_callback(callback.use_object, self.use_inventory_item, self)
	self.object:set_callback(callback.hit, self.actor_hit_callback, self)
	
	self.object:set_callback(callback.death, self.actor_death_callback, self)

	self.object:set_callback(callback_ex.on_key_press, self.on_key, self)			-- нажатие клавиши
	self.object:set_callback(callback_ex.on_key_release, self.on_key_free, self)		-- отпускание клавиши
	self.object:set_callback(callback_ex.on_key_hold, self.on_key_hold, self)		-- удержание клавиши
	self.object:set_callback(callback_ex.on_mouse_wheel, self.on_wheel_rotation, self)	-- вращение колесика мыши
	self.object:set_callback(callback_ex.on_mouse_move, self.on_mouse_move, self)		-- движение мыши
	self.object:set_callback(callback_ex.on_belt, self.item_to_belt, self)		-- перемещение предмета на пояс
	self.object:set_callback(callback_ex.on_ruck, self.item_to_backpack, self)	-- перемещение предмета в рюкзак
	self.object:set_callback(callback_ex.on_slot, self.item_to_slot, self)		-- перемещение предмета в слот
	self.object:set_callback(callback_ex.on_hud_animation_end, self.hud_animation_end, self) -- вызывается в конце проигрывания анимации худа (только если используем play_hud_animation)
	self.object:set_callback(callback_ex.on_goodwill_change, self.on_goodwill_change, self)		-- изменение отношений
--	self.object:set_callback(callback_ex.on_release_npc, self.on_release_npc, self)		-- удаление серверного объекта непися или монстра
	--
	self.object:set_callback(callback_ex.entity_alive_before_hit, self.before_hit_callback, self)
	self.object:set_callback(callback_ex.on_before_use_item, self.before_use, self)
	
	--self.object:set_callback(callback_ex.dbg_gg_distance_failed,					self.debug_monster_follow_path,		self)
	--
	self.am:call("on_reinit")
	event("actor_reinit"):trigger()
end

function actor_binder:hud_animation_end(a1, blend_addr)
	local addr = sum_args_ex(blend_addr, 56)
	local value = db.actor:get_memory_int("", addr)

	--log3("[actor_binder:hud_animation_end] blend_addr = %x, v = %d, a1 = %d", blend_addr, value, a1)
end
function actor_binder:on_goodwill_change(from, to)
	self.am:call("on_goodwill_change", from, to)
end

--function actor_binder:on_release_npc(npc_id)
--	self.am:call("on_release_npc", npc_id)
--end

controllerSoundPresentOnDeath = false
function actor_binder:actor_death_callback(victim, who)
	controllerSoundPresentOnDeath = false
	local actorPosition = self.object:position()
	local kontrikSoundAuraDistance = get_float("m_controller_e", "PsyAura_Fake_MaxAddDist", 90.0)
	kontrikSoundAuraDistance = kontrikSoundAuraDistance*kontrikSoundAuraDistance
	for k,v in pairs(db.creature) do
		if v == false then		-- монстры
			local obj = level.object_by_id(k)
			if obj and obj:clsid() == clsid.controller_s and obj:position():distance_to_sqr(actorPosition) <= kontrikSoundAuraDistance then
				controllerSoundPresentOnDeath = true
				get_console():execute("cfg_save user.ltx")
				get_console():execute("unbind quick_load")
				get_console():execute("unbind_sec quick_load")
				break
			end
		end
	end
end

function actor_binder:debug_monster_follow_path(id, params)
	local g0 = bit_and(params, 65535)
	local g1 = bit.rshift(params, 16)
	
	log3("id = %d, g0 = %d, g1 = %d", id, g0, g1)
	local obj = alife():object(id)
	if obj then
		log3("actor_binder:debug_monster_follow_path: %s", obj:name())
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:take_item_from_box(box, item)
	local story_id = box:story_id()
	if story_id == nil then
		return
	end

	treasure_manager.take_item_from_box(box, story_id)
--[[
	local respawner = se_respawn.get_respawner_by_parent(story_id)
	if respawner == nil then
		return
	end

	--' Необходимо уменьшить счетчик в респавнере
	respawner:remove_spawned(item:id())

	local smart_terrain = db.strn_by_respawn[respawner:name()]
	if smart_terrain == nil then
		return
	end

	local npc = smart_terrain.gulag:get_nearest_online_obj(db.actor:position())
    if npc ~= nil then
	    xr_sound.set_sound_play(npc, "reac_box")
	    xr_gulag.setGulagEnemy(smart_terrain:name() , db.actor)
    end
]]
	self.am:call("on_take_from_box", box, item, sim:object(item:id()))
	event("actor_take_item_from_box"):trigger({from = box, what = item})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_enter(npc, info_id)
	self.actor_detector:actor_enter()
	self.am:call("on_level_border_enter", npc, info_id)
	event("actor_level_border_enter"):trigger({who = npc, info = info_id})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_exit(npc, info_id)
	self.actor_detector:actor_exit()
	self.am:call("on_level_border_exit", npc, info_id)
	event("actor_level_border_exit"):trigger({who = npc, info = info_id})
end
----------------------------------------------------------------------------------------------------------------------
local info2call = {
	ui_pda                   = "on_pda_open",
	ui_pda_hide              = "on_pda_hide",
	ui_pda_contacts          = "on_pda_contacts_open",
	ui_pda_contacts_hide     = "on_pda_contacts_hide",
	ui_pda_map_local         = "on_pda_map_local",
	ui_pda_map_global        = "on_pda_map_global",
	ui_pda_news              = "on_pda_news_open",
	ui_pda_news_hide         = "on_pda_news_hide",
	ui_pda_jobs_failed       = "on_pda_jobs_failed",
	ui_pda_jobs_accomplished = "on_pda_jobs_accomplished",
	ui_pda_jobs_current      = "on_pda_jobs_current",
	ui_pda_jobs              = "on_pda_jobs_open",
	ui_pda_jobs_hide         = "on_pda_jobs_hide",
	ui_pda_diary             = "on_pda_diary_open",
	ui_pda_diary_hide        = "on_pda_diary_hide",
	ui_pda_encyclopedia      = "on_pda_encyclopedia_open",
	ui_pda_encyclopedia_hide = "on_pda_encyclopedia_hide",
	ui_pda_actor_info        = "on_pda_actor_info",
	ui_pda_ranking           = "on_pda_ranking",
	ui_pda_events            = "on_pda_events",
	ui_inventory             = "on_inventory_open",
	ui_inventory_hide        = "on_inventory_hide",
	ui_talk                  = "on_talk_open",
	ui_talk_hide             = "on_talk_hide",
	ui_trade                 = "on_trade_open",
	ui_trade_hide            = "on_trade_hide",
	ui_car_body              = "on_body_open",
	ui_car_body_hide         = "on_body_hide",
}
function actor_binder:info_callback(npc, info_id)
	ogse_debug.process_actor("inf", 1)
	--' Сюжет
	level_tasks.proceed(self.object)
	
	ogse_debug.process_actor("inf", 2)
	-- Отметки на карте
	level_tasks.process_info_portion(info_id)
	
	ogse_debug.process_actor("inf", 3)
	
	ogse.on_info_update(info_id)
	
	ogse_debug.process_actor("inf", 4)
	
	self.am:call("on_info", npc, info_id)
	event("actor_info"):trigger({who = npc, info = info_id})
	
	local sc = info2call[info_id]
	if sc then
		self.am:call(sc, npc)
		event(sc):trigger({who = npc})
	end
	ogse_debug.process_actor("inf", 0)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_trade(item, sell_bye, money)
	--game_stats.money_trade_update(sell_bye and money or -money)
	self.am:call("on_trade", item, sell_bye, money)
	event("actor_trade"):trigger({what = item, money = money, item_is_sold = sell_bye})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:article_callback(npc, group, name, article_type)
	if device().precache_frame >1 then return end

	if table_group[group] ~= nil then -- yes, old school.. we use "~= nil"
		news_manager.send_encyclopedy(group == "Diary" and "diary" or "encyclopedy", group)
		ogse.send_tip(game.translate_string(name), table_group[group], nil, 7)
	end
	
	self.am:call("on_article", npc, group, name, article_type)
	event("actor_article"):trigger({who = npc, article_group = group, article_name = name, article_type = article_type})
end
----------------------------------------------------------------------------------------------------------------------
debug_item_id = nil
debug_item_name = nil


local remove_this_shit_immediately = {
	["fake_grenades_base"] = true,
	["grenade_f1_fake"] = true,
	["grenade_rgd5_fake"] = true,
	["grenade_gd-05_fake"] = true,
	["grenade_light_fake"] = true,
	["grenade_f1_test"] = true,
	["grenade_rgd5_test"] = true,
	["grenade_gd-05_test"] = true,
	["grenade_light_test"] = true,
	["gl_test_shell"] = true,
	["wpn_fake_missile"] = true,
	["gl_test_shell_ammo_vog-25"] = true,
	["gl_test_shell_ammo_vog-25p"] = true,
	["gl_test_shell_ammo_m209"] = true,
	["gl_test_shell_ammo_m208a"] = true,
	["gl_fake_missile"] = true,
	["gl_fake_missile_ammo_vog-25"] = true,
	["gl_fake_missile_ammo_vog-25p"] = true,
	["gl_fake_missile_ammo_m209"] = true,
	["gl_fake_missile_ammo_m208a"] = true,
}

function check_pickup_fake_gren(obj, srv_obj)
	local section = srv_obj:section_name()
	if remove_this_shit_immediately[section] then
		log1("!!DEBUG! Removing fake item begin")
		death_manager.shedule_release(obj)
		log1("!!DEBUG! Removing fake item end")
		return true	
	end	
	return false
end

function actor_binder:on_item_take(obj)

	ogse_debug.process_actor("itm_t", 1)
	
	local sobj = nil
	
	if not obj then 
		ogse_debug.process_actor("itm_t", 0)
		return 
	else	
		local id = obj:id()
		sobj = alife():object(id)
		if not sobj then
			if obj:section() ~= "bolt" then
				db.actor:drop_item(obj)
			end
			ogse_debug.process_actor("itm_t", 0)
			return
		end
	end	

	ogse_debug.process_actor("itm_t", 2)
	
	local need_return = check_pickup_fake_gren(obj, sobj)
	
	if need_return then
		ogse_debug.process_actor("itm_t", 0)
		return
	end

	ogse_debug.process_actor("itm_t", 26662)
	
    if xrs_ai then xrs_ai.actor_item_take(obj) end	

	ogse_debug.process_actor("itm_t", 3)
	
    if rx_ai then
	   rx_ai.actor_item_take(obj)
    end	

	ogse_debug.process_actor("itm_t", 4)
	
    level_tasks.proceed(self.object)
	remkit_main.skip_updates = 3

	ogse_debug.process_actor("itm_t", 5)	
	
    --game_stats.update_take_item (obj, self.object)
    ogse.on_item_take(obj)

	ogse_debug.process_actor("itm_t", 6)

    if obj:clsid() == clsid.wpn_ammo then
        dunin_ammo.on_take(obj)
    end

	ogse_debug.process_actor("itm_t", 7)
		
	ogse_debug.process_actor("itm_t", 8)
	
	--if obj:section() ~= "bolt" then
		local sobj = sim:object(obj:id()) 
		if sobj then -- такое бывает, если до этого объект был удалён в on_ruck
--		log1(obj:section())
			self.am:call("on_take", obj, sobj)
			event("actor_item_take"):trigger({what = obj})
		end
	--end
	
	ogse_debug.process_actor("itm_t", 0)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_drop(obj)

	ogse_debug.process_actor("itm_d", 1)
	
	if not obj then 
		ogse_debug.process_actor("itm_d", 0)
		return 
	else	
		local id = obj:id()
		local sobj = alife():object(id)
		if not sobj then
			ogse_debug.process_actor("itm_d", 0)
			return
		end
	end

    level_tasks.proceed(self.object)
	ogse_debug.process_actor("itm_d", 2)
	ogse.on_item_drop(obj)
	ogse_debug.process_actor("itm_d", 0)
	
	local sobj = sim:object(obj:id())
	if sobj then
		self.am:call("on_drop", obj, sobj)
		event("actor_item_drop"):trigger({what = obj})
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:before_use(item)
	self.am:call("on_actor_before_use", item, sim:object(item:id()))
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:use_inventory_item(obj)
	ogse_debug.process_actor("itm_u", 1)
	
	if not obj then 
		ogse_debug.process_actor("itm_u", 0)
		return 
	else	
		local id = obj:id()
		local sobj = alife():object(id)
		if not sobj then
			ogse_debug.process_actor("itm_u", 0)
			return
		end
	end	
	
	ogse.use_inventory_item(obj)
	ogse_debug.process_actor("itm_u", 0)
	self.am:call("on_use", obj, sim:object(obj:id()))
	event("actor_use_inventory_item"):trigger({what = obj})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:before_hit_callback(p_s_hit, p_ignore_flags)
	local hit_data = read_hit_data(p_s_hit)
	self.am:call("on_actor_before_hit", hit_data, p_s_hit, p_ignore_flags)
end

function actor_binder:actor_hit_callback(obj, amount, local_direction, who, bone_index)

	ogse_critical_hit.check_critical(amount, bone_index, who)
	checker_minefield.on_act_hit()
	self.am:call("on_hit", obj, amount, local_direction, who, bone_index)
	event("actor_hit"):trigger({victim = obj, amount = amount, dir = local_direction, who = who, bone = bone_index})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:task_callback(_task, _objective, _state)
	ogse_debug.process_actor("tsk", 1)
	task_manager.task_callback(_task:get_id(), _objective:get_idx(), _state)
	ogse_debug.process_actor("tsk", 2)
	if _objective:get_idx() == 0 then
		ogse_debug.process_actor("tsk", 3)
		if _state == task.fail then
			news_manager.send_task(db.actor, "fail", _task, _objective)
		elseif _state == task.completed then
			task_manager.reward_by_task(_task)
			news_manager.send_task(db.actor, "complete", _task, _objective)
		else
			news_manager.send_task(db.actor, "new", _task, _objective)
		end
	else
		ogse_debug.process_actor("tsk", 4)
		if _task:get_objective(0):get_state() == task.in_progress then
			news_manager.send_task(db.actor, "update", _task, _objective)
		end
	end
	ogse_debug.process_actor("tsk", 0)
	self.am:call("on_task", _task, _objective, _state)
	event("actor_task"):trigger({task = _task, objective = _objective, state = _state})
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:map_location_added_callback(spot_type_str, object_id)
	if (false==app_ready()) or (device().precache_frame>1) then return end
	--'news_manager.send_task(db.actor, "new")
	self.am:call("on_add_map_location", spot_type_str, object_id)
	event("actor_add_map_location"):trigger({spot_type = spot_type_str, object_id = object_id})
end
----------------------------------------------------------------------------------------------------------------------
local cnt = 0
local update_was_never_called = true
----------------------------------------------------------------------------------------------------------------------
function actor_binder:update(delta)
	--// Для персональных функций, в обновлениях. Phoenix
	personal_update.main()
	--//End
	
	if cnt == 0 then
		for k, v in pairs(xr_companion.companions) do
			if xr_companion.companions[k] == "companion" then
				if not ogse_car_control.current_car then
					xr_companion.check_teleport(k)
				end
			end
		end
		cnt = 1
	end

	ogse_debug.check_npc()
	ogse_debug.check_monsters()	
	ogse_debug.check_gulag()	
	
	ogse_debug.process_actor("upd", 1)
	
	local time = time_global()

	ogse_debug.process_actor("upd", 2)
	
	jekan_update.watchdog_quest()
	
	ogse_debug.process_actor("upd", 3)

	-- апдейт схемы детектора
	self.actor_detector:update()
	
	ogse_debug.process_actor("upd", 4)

	-- апдейт звуковой схемы актера
	xr_sound.update_actor()
	
	ogse_debug.process_actor("upd", 5)
	
	--' Проверка потери жизни
--[[
	if self.object.health - lasthealth > 0.001 or
	   self.object.health - lasthealth < -0.001 then
		lasthealth = self.object.health
		lasttime = game.time()
	end
]]
	-- Обновление отключения ввода с клавиатуры.
	if self.st.disable_input_time ~= nil and
	   game.get_game_time():diffSec(self.st.disable_input_time) >= self.st.disable_input_idle
	then
		level.enable_input()
		self.st.disable_input_time = nil
	end
	
	ogse_debug.process_actor("upd", 6)
	
	-- Обновление сна с переносом чувака в указанную позицию
	if self.st.sleep_relocate_time ~= nil and
	   game.get_game_time():diffSec(self.st.sleep_relocate_time) >= self.st.sleep_relocate_idle
	then
		self.object:set_actor_position(self.st.sleep_relocate_point)
		local dir = self.st.sleep_relocate_point:sub(self.st.sleep_relocate_look)
		self.object:set_actor_direction(dir:getH())
		self.st.sleep_relocate_time = nil
	end

	ogse_debug.process_actor("upd", 7)
	
	-- Апдейт прятание оружия игрока во время диалога
	if weapon_hide == true or self.object:is_talking() then
		if self.weapon_hide == false then
			self.object:hide_weapon()
			self.weapon_hide = true
		end
	else
		if self.weapon_hide == true then
			self.object:restore_weapon()
			self.weapon_hide = false
		end
	end

	ogse_debug.process_actor("upd", 8)
	
	-- обновление рестрикторов, которые под логикой, срабатывает через интервалы времени
	if self.next_restrictors_update_time < time then
		ogse_debug.process_actor("upd", 811)
		bind_restrictor.actor_update(delta)
		ogse_debug.process_actor("upd", 812)
		-- Апдейтим наш телепорт
		bind_mteleport.actor_update(delta)
		ogse_debug.process_actor("upd", 813)
		self.next_restrictors_update_time = time + 200
		task_manager.actor_update()
		ogse_debug.process_actor("upd", 814)
		ogse_water_restrictor.actor_update(delta)
	end

	ogse_debug.process_actor("upd", 9)
	
	-- обновление постпроцессов
	if post_process ~= 0 then
		if post_process:update () == true then
		   post_process = 0
		end
	end
	
	ogse_debug.process_actor("upd", 10)

	-- обновление пси-антенны
	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:update(delta)
	end

	ogse_debug.process_actor("upd", 11)
	
	--' Вывод сообщения о большой радиации
	if self.object.radiation >= 0.7 then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("cs_radiation_danger")
		if custom_static == nil then
			hud:AddCustomStatic("cs_radiation_danger", true)
			hud:GetCustomStatic("cs_radiation_danger"):wnd():SetTextST("st_radiation_danger")
		end
	else
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("cs_radiation_danger")
		if custom_static ~= nil then
			hud:RemoveCustomStatic("cs_radiation_danger")
		end
	end

	ogse_debug.process_actor("upd", 12)

 	if self.bCheckStart then
		if not has_alife_info("storyline_actor_start") and
		   (level.name() == "l01_escape")
		then
	        self.am:call("on_storyline_start")
			self.object:give_info_portion("storyline_actor_start")
		end

--		if not has_alife_info("encyclopedy") then
--			self.object:give_info_portion("encyclopedy")
--		end

		if not has_alife_info("global_dialogs") then
			self.object:give_info_portion("global_dialogs")
		end

		if not has_alife_info("level_changer_icons") then
			self.object:give_info_portion("level_changer_icons")
		end

		--level_tasks.add_lchanger_location()
		ogse_lc_mngr.lc_restore_location()

		self.bCheckStart = false
	end
	
	ogse_debug.process_actor("upd", 13)
	
	-- Обновление актора
	ogse.on_actor_update()
	
	ogse_debug.process_actor("upd", 14)
	
	_sdata.vis_int()
	
	ogse_debug.process_actor("upd", 15)
	
	self.am:call("on_update", delta)
	
	ogse_debug.process_actor("upd", 16)
	
	if update_was_never_called then
		self.am:call("on_first_update")
		update_was_never_called = false
	end
	
	ogse_debug.process_actor("upd", 17)

	event("actor_update"):trigger({delta = delta})
	
	ogse_debug.process_actor("upd", 18)
	
	-- Обновление упаковщика патронов -- должно быть предпоследним на апе актора!
	dunin_ammo.on_update()	
	
	ogse_debug.process_actor("upd", 19)
	
	-- Отложенное удаление патронов -- должно быть последним на апе актора!
	
	death_manager.release_deferred_ammo()
	
	ogse_debug.process_actor("upd", 0)

end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key(key)
	ogse_debug.process_actor("key", 1)
	ogse.on_key(key, dik_to_bind(key))
	ogse_debug.process_actor("key", 0)
	self.am:call("on_key_down", key, dik_to_bind(key))
	event("key_down"):trigger({key = key, bind = dik_to_bind(key)})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key_free(key)
	ogse_debug.process_actor("key_f", 1)
	ogse.on_key_free(key, dik_to_bind(key))
	ogse_debug.process_actor("key_f", 0)
	self.am:call("on_key_up", key, dik_to_bind(key))
	event("key_up"):trigger({key = key, bind = dik_to_bind(key)})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key_hold(key)
	ogse_debug.process_actor("key_h", 1)
	ogse.on_key_hold(key, dik_to_bind(key))
	ogse_debug.process_actor("key_h", 0)
	self.am:call("on_key_hold", key, dik_to_bind(key))
	event("key_hold"):trigger({key = key, bind = dik_to_bind(key)})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_wheel_rotation(vol)
	ogse_debug.process_actor("key", 1)
	ogse.on_wheel_rotation(vol-100000)
	ogse_debug.process_actor("key", 0)
	self.am:call("on_wheel", vol-100000)
	event("mouse_wheel"):trigger({val = vol-100000})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_mouse_move(velx, vely)
	ogse_debug.process_actor("key", 1)
	ogse.on_mouse_move(velx, vely)
	ogse_debug.process_actor("key", 0)
	self.am:call("on_mouse_move", velx-100000, vely-100000)
	event("mouse_move"):trigger({ x = velx-100000, y = vely-100000})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:item_to_belt(obj)
	ogse.on_item_to_belt(obj)
	local sobj = sim:object(obj:id())
	if sobj then
		self.am:call("on_item_to_belt", obj, sobj)
		event("actor_item_to_belt"):trigger({what = obj})
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:item_to_backpack(obj)
	ogse.on_item_to_backpack(obj)
	local sobj = sim:object(obj:id())
	if sobj then -- такое бывает, когда спавним в инвентарь предмет, а потом его тут же удаляем ещё выхода в онлайн
		self.am:call("on_item_to_ruck", obj, sobj)
		event("actor_item_to_ruck"):trigger({what = obj})
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:item_to_slot(obj)
	ogse.on_item_to_slot(obj)
	local sobj = sim:object(obj:id())
	if sobj then
		self.am:call("on_item_to_slot", obj, sobj)
		event("actor_item_to_slot"):trigger({what = obj})
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:save(packet)

	ogse.on_game_save(packet)

	if rx_ai then rx_ai.actor_save(packet) end

	local pk1 = fake_net_packet.fake_net_packet()
	self:save_old(pk1)
	
	log1("~~Actor netpacket size "..pk1:w_tell())
	get_console():execute("flush")
	
	if pk1:w_tell() > 7500 then
		task_manager.cleanup_actor()
	end	
	
	if pk1:w_tell() > 7700 then
		task_manager.cleanup_actor()
	end
	
	
	self:save_old(packet)
	self.am:call("on_save", packet)
	event("actor_save"):trigger({packet = packet})
	self.am:call("on_save_after_all")
end 

function actor_binder:save_old(packet)
	local save_treasure_manager = true

	--' Сохраняем уровень сложности
	if save_treasure_manager == true then
		packet:w_u8(level.get_game_difficulty() + 128)
	else
		packet:w_u8(level.get_game_difficulty())
	end


	--' Сохраняем данные об отключенном вводе
	if self.st.disable_input_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)  ---- fixed by Kamikazze
		utils.w_CTime(packet, self.st.disable_input_time)
	end

	xr_logic.pstor_save_all(self.object, packet)

	sr_psy_antenna.save( packet )

	if save_treasure_manager == true then
		treasure_manager.save(packet)
	end

	task_manager.save(packet)
	self.actor_detector:save(packet)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:load(reader)

	--' Загружаем уровень сложности
	local game_difficulty = reader:r_u8()

	local load_treasure_manager = false
	if game_difficulty >= 128 then
		game_difficulty = game_difficulty - 128
		load_treasure_manager = true
	end

	if game_difficulty_by_num[game_difficulty] ~= nil then -- изменено KamikaZze с целью отладки 25/02/2009
		get_console():execute("g_game_difficulty "..game_difficulty_by_num[game_difficulty])
	else 	
		get_console():execute("g_game_difficulty ".."gd_master")
	end

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	local stored_input_time = reader:r_u8()
	if stored_input_time == true then
		self.st.disable_input_time = utils.r_CTime(reader)
	end

	xr_logic.pstor_load_all(self.object, reader)

	sr_psy_antenna.load(reader)

	if load_treasure_manager == true then
		treasure_manager.load(reader)
	end

	task_manager.load(reader)
	self.actor_detector:load(reader)
	self.am:call("on_load", reader)
	event("actor_load"):trigger({packet = reader})
end
----------------------------------------------------------------------------------------------------------------------

-- Weapon functions
function hide_weapon()
	weapon_hide = true
end
function restore_weapon()
	weapon_hide = false
end
