-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

off_npcs = {}
items    = {}
always_keep_item = {}

-- Как часто генерить события в оффлайн (реальные секунды)
local alife_freq = 60

local maps = {
  "atp_for_test22",
  "aver",
  "dead_city",
  "generators",
  "hospital",
  "jupiter",
  -- "jupiter_underground",
  -- "labx8",
  "l01_escape",
  "l02_garbage",
  "l03_agroprom",
  "l03u_agr_underground",
  "l04_darkvalley",
  -- "l04u_labx18",
  "l05_bar",
  "l06_rostok",
  "l07_military",
  "l08_yantar",
  -- "l08u_brainlab",
  "l10_radar",
  -- "l10u_bunker",
  "l11_pripyat",
  -- "l12_stancia",
  -- "l12_stancia_2",
  -- "l12u_control_monolith",
  -- "l12u_sarcofag",
  "limansk",
  "lost_village",
  "marsh",
  "puzir",
  "pripyat",
  "red_forest",
  "warlab",
  "zaton",
}

protected = {
  names     = {}, -- имена объектов (стоит добавлять только уникальные имена!)
  ids       = {}, -- ID объектов
  story_ids = {   -- story ID объектов
    [ 573  ] = true,
    [ 5008 ] = true,
    [ 5013 ] = true,
    [ 5014 ] = true,
    [ 5041 ] = true,
    [ 5065 ] = true,
    [ 5084 ] = true,
    [ 5104 ] = true,
    [ 5205 ] = true,
    [ 5222 ] = true,
    [ 5226 ] = true,
    [ 5237 ] = true,
    [ 5238 ] = true,
    [ 5243 ] = true,
    [ 5244 ] = true,
    [ 5245 ] = true,
    [ 5246 ] = true,
    [ 5247 ] = true,
    [ 5248 ] = true,
    [ 5249 ] = true,
    [ 5250 ] = true,
    [ 5254 ] = true,
    [ 5255 ] = true,
    [ 5408 ] = true,
    [ 5413 ] = true,
    [ 5428 ] = true,
    [ 5433 ] = true,
    [ 5434 ] = true,
    [ 5444 ] = true,
    [ 5446 ] = true,
    [ 5470 ] = true,
    [ 5471 ] = true,
    [ 5472 ] = true,
    [ 5473 ] = true,
    [ 5474 ] = true,
  },
  sections = {    -- секции объектов
    [ "computer_flash"   ] = true,
    [ "disk_flash"       ] = true,
    [ "dyak_mines_box"   ] = true,
    [ "keis_key_box"     ] = true,
    [ "notebook_flash"   ] = true,
    [ "pda_flash"        ] = true,
    [ "radiodetail_box2" ] = true,
    [ "radiodetail_box4" ] = true,
    [ "taynik_kuznec7"   ] = true,
    [ "taynik_podarok"   ] = true,
    [ "volna_shron"      ] = true,
  },
}

-- радиус "обзора"
local look_radius        = 50
-- Вещи дешевле продает торговцам
local sell_limit         = 3000
local rate_art_found     = 100
local to_actor           = 150
local look_radius_box    = 20

local friends_comm = {
  [ "dolg"    ] = true,
  [ "ecolog"  ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
}

-- Имена профилей торговцев.
local trader_profiles = {
  [ "Sak"                    ] = true,
  [ "aaz_upi"                ] = true,
  [ "agro_adrenalin"         ] = true,
  [ "agro_mobil_torgash"     ] = true,
  [ "amk_artem_kulinar"      ] = true,
  [ "amk_vitek_voron"        ] = true,
  [ "atp_mobil_torgovetz"    ] = true,
  [ "bar_barman"             ] = true,
  [ "bar_dolg_petrenko"      ] = true,
  [ "bibliofrend_talk"       ] = true,
  [ "bibliofrend_talk_black" ] = true,
  [ "dcity2_dok2_bolot2_vid" ] = true,
  [ "doktor"                 ] = true,
  [ "esc_akim"               ] = true,
  [ "escape_trader"          ] = true,
  [ "marsh_ariadna2"         ] = true,
  [ "marsh_remont"           ] = true,
  [ "mil_Svoboda_trader"     ] = true,
  [ "otshelnik"              ] = true,
  [ "pri_dimak"              ] = true,
  [ "prip_dok_arh"           ] = true,
  [ "yan_general_ecolog"     ] = true,
}


local food = {
  [ "bread"     ] = 0.1,
  [ "conserva"  ] = 0.1,
  [ "kolbasa"   ] = 0.1,
  [ "sandwich"  ] = 0.05,
  [ "sweetness" ] = 0.05,
}


function is_trader( sobj )
  return trader_profiles[ sobj:profile_name() ]
end


function is_npc_can_trade( sobj )
  return IsStalker( sobj )
    and sobj:alive() and sobj:health() > 0
    and sobj:community() ~= "zombied"
    and ( sobj.m_story_id == 4294967296 or not is_trader( sobj ) )
    and ( not xr_companion.is_companion( sobj.id ) )
    and ( not protected_items.is_no_offline_alife_npc( sobj:section_name() ) )
    and sobj:can_be_spawned()
end


function add_fresh_meat( obj )
  if
    db.actor:id() == obj.id or obj.parent_id == db.actor:id()
    or protected_items.is_no_offline_alife_npc( obj:section_name() )
    or item_keep( obj )
  then
    return
  end
  local map = object_level_name( obj )
  ASSERT(
    map,
    "[%s]: unknown level name of %s: m_game_vertex_id = %s",
    script_name(), obj:name(), tostring( obj.m_game_vertex_id )
  )
  if not off_npcs[ map ] then
    off_npcs[ map ] = {
      artefacts = {},
      inv_boxes = {},
      monsters  = {},
      stalkers  = {},
      weapons   = {},
    }
  end
  if is_npc_can_trade( obj ) then
    table.insert(
      off_npcs[ map ].stalkers, { id = obj.id, name = obj:name() }
    )
  elseif dsh.is_artefact( obj:section_name() ) and obj.parent_id == 65535 then
    table.insert(
      off_npcs[ map ].artefacts, { id = obj.id, name = obj:name() }
    )
  elseif
    (
      obj:clsid() == clsid.inventory_box
      and not box_is_protected( obj )
    )
    or (
      obj:section_name() == "dsh_treasure_item"
      and not protected.ids[ obj.id ]
    )
  then
    table.insert(
      off_npcs[ map ].inv_boxes, { id = obj.id, name = obj:name() }
    )
  elseif obj.parent_id ~= 65535 and obj.m_story_id == 4294967296 then
    local zz = alife():object( obj.parent_id )
    if zz then
      if not protected.ids[ obj.parent_id ] then
        if not items[ obj.parent_id ] then items[ obj.parent_id ] = {} end
        table.insert(
          items[ obj.parent_id ],
          {
            id    = obj.id,
            lname = map,
            name  = obj:name(),
          }
        )
      end
      -- Idler++-- корректируем хабар в помеченных тайниках
      gps_habar.insert_item( obj.parent_id, obj )
    end
  end
end


function update_npc_tables()
  items    = {}
  off_npcs = {}
  dsh_alife.iterate_items( function( sobj ) add_fresh_meat( sobj ) end )
  dsh.timeout( math.random( alife_freq ) * 1000, function()
    offline_alife_timer():start()
  end )
end


local weapon_repair_allowed = false
function update_trade()
  if
    ogse_st_mgr.timer_exists( "amk_offline_alife.weapon_repair.forbidden" )
  then
    weapon_repair_allowed = false
  else
    weapon_repair_allowed = true
  end
  local pt  = profile_timer()
  pt:start()
  for id, sobj in pairs( se_stalker.stalkers ) do
    process_trade( sobj )
  end
  pt:stop()
  log2( "[%s]: trade updated: %s", script_name(), pt:time() )
  if weapon_repair_allowed then
    dsh.start_gtimerDHMS(
      "amk_offline_alife.weapon_repair.forbidden",
      0, math.random( 20, 24 ), 0, 0,
      "amk_offline_alife.process_weapon_repair_allowed"
    )
    weapon_repair_allowed = false
  end
end


class "offline_alife_timer" ( ogse_qt.quick_timer )
function offline_alife_timer:__init() super()
  self.lname    = maps[ math.random( table.getn( maps ) ) ]
  self.stalkers = {}
  if off_npcs[ self.lname ] then
    for _, v in ipairs( off_npcs[ self.lname ].stalkers ) do
      table.insert( self.stalkers, v )
    end
    if table.getn( self.stalkers ) > 1 then
      dsh.shuffle( self.stalkers )
    end
  end
end

function offline_alife_timer:condition()
  return table.getn( self.stalkers ) == 0
end

function offline_alife_timer:action()
  dsh.timeout( alife_freq * 1000, function()
    offline_alife_timer():start()
  end )
end

function offline_alife_timer:update()
  if table.getn( self.stalkers ) == 0 then return end
  local st     = table.remove( self.stalkers )
  local victim = alife():object( st.id )
  if
    victim and victim:name() == st.name
    and object_level_name( victim ) == self.lname
    and ( not victim.online ) and victim:alive()
    and victim:can_be_spawned()
  then
    local vdata = collect_info( victim, self.lname )
    if table.getn( vdata.artefacts ) > 0 then
      -- есть арты
      on_artifacts_found( victim, vdata )
    end
    if table.getn( vdata.inv_boxes ) > 0 then
      -- есть контейнеры. Надо обыскать.
      on_inv_boxes_found( victim, vdata )
    end
  end
end


--собираем инфу о неписе
function collect_info( victim, map )
  local vdata = {}
  vdata.rank      = victim:rank()
  vdata.health    = victim:health()
  vdata.community = victim:community()

  --составляем список артов в зоне "видимости"
  vdata.artefacts = {}
  if off_npcs[ map ].artefacts then
    for _, v in ipairs( off_npcs[ map ].artefacts ) do
      local artefact = alife():object( v.id )
      if
        artefact and object_level_name( artefact ) == map
        and artefact.can_switch_online and artefact:can_switch_online()
        and artefact:name() == v.name
        and artefact.parent_id == 65535
        and victim.position:distance_to( artefact.position ) < look_radius
        and sobj_is_far( artefact, to_actor )
      then
        local zdist = victim.position:distance_to( artefact.position ) / look_radius
        if math.random() > zdist then
          table.insert(
            vdata.artefacts, { id = artefact.id, name = artefact:name() }
          )
        end
      end
    end
  end

  --составляем список контейнеров в зоне "видимости"
  vdata.inv_boxes = {}
  if off_npcs[ map ].inv_boxes then
    for _, v in ipairs( off_npcs[ map ].inv_boxes ) do
      local inv_box = alife():object( v.id )
      if
        inv_box
        and inv_box.can_switch_online and inv_box:can_switch_online()
        and inv_box:name() == v.name
        and inv_box.parent_id == 65535
        and victim.position:distance_to( inv_box.position ) < look_radius_box
        and sobj_is_far( inv_box, to_actor )
        and not treasure_manager.is_active( inv_box )
      then
        local zdist = victim.position:distance_to( inv_box.position ) / look_radius_box
        if math.random() > zdist then
          table.insert(
            vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() }
          )
        end
      end
    end
  end

  return vdata
end


-- Моя прелесссть
function on_artifacts_found( victim, vdata )
  for _, v_obj in ipairs( vdata.artefacts ) do
    local object = alife():object( v_obj.id )
    if object then
      local obj = pick_item( victim, object )
      victim:set_rank( victim:rank() + rate_art_found )
    end
  end
end


-- О, нычка - это гуд.  Idler ++ проверим, а сможет ли непись долезть
-- до тайника.  если есть аномалии в радиусе 20м, меньше шансов или
-- если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail( victim, box )
  -- отсекаем сюжетные тайники
  if
    transparent_treasure.IsTaken( box:section_name(), box:name() )
    and box:section_name() ~= "m_inventory_box"
  then
    return false
  end
  local n_rnd = math.random( 3, 10 )
  if math.abs( box.position.y - victim.position.y ) > n_rnd then
    return false
  end
  if object_level_name( box ) == level.name() then
    local anom_list = amk_anoms.get_anomaly_list_for_pos( box.position, 20 )
    local n_anoms   = table.getn( anom_list )
    local n_rnd     = math.random( 100 )
    -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При
    -- 5 - точно до ящика не доберется
    if n_rnd < n_anoms * 20 then return false end
  end
  return true
end


function on_inv_boxes_found( victim, vdata )
  for _, v_obj in ipairs( vdata.inv_boxes ) do
    local object = alife():object( v_obj.id )
    if object then
      -- Idler ++-- если нычка доступна - можно шмонать
      if inv_box_is_avail( victim, object ) then
        if object:section_name() == "dsh_treasure_item" then
          dsh_rukzak.on_inv_box_found( object.id, victim )
        elseif items[ v_obj.id ] then
          for _, v_itA in ipairs( items[ v_obj.id ] ) do
            local itA = alife():object( v_itA.id )
            if
              itA
              and itA.parent_id == v_obj.id
              and itA:name() == v_itA.name
            then
              -- Решим, подбираем или нет?
              if is_valuable( itA ) then
                pick_item( victim, itA )
              end
            end
          end
        end
        victim:set_rank( victim:rank() + rate_art_found )
      end
    end
  end
end


function pick_item( npc, obj )
  local section = obj:section_name()
  local new     = alife():create(
    section,
    npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
    npc.id
  )
  new = alife():object( new.id )
  ASSERT( new, "can't create new %s", section )
  local pk = get_netpk( obj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", obj:name() )
  local data = pk:get()
  local cd   = data.custom_data:getString()
  if cd and cd ~= "" then
    local new_pk = get_netpk( new, 1 )
    ASSERT(
      ( new_pk and new_pk:isOk() ), "can't read netpacket of %s", new:name()
    )
    local new_data = pk:get()
    new_data.custom_data:setString( cd )
    new_pk:set( new_data )
  end
  if not items[ npc.id ] then items[ npc.id ] = {} end
  table.insert(
    items[ npc.id ],
    {
      id    = new.id,
      lname = object_level_name( new ),
      name  = new:name(),
    }
  )
  -- Idler++-- корректируем хабар в помеченных тайниках
  gps_habar.insert_item( npc.id, new )
  if
    obj.parent_id
    and items[ obj.parent_id ] and table.getn( items[ obj.parent_id ] ) > 0
  then
    for z = 1, table.getn( items[ obj.parent_id ] ) do
      if items[ obj.parent_id ][ z ].id == obj.id then
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] )
        table.remove( items[ obj.parent_id ], z )
        break
      end
    end
  end
  alife():release( obj )
  return new
end


function get_item_cost( item )
  return get_float( item:section_name(), "cost", 0 )
end


local cached_item = {}
function item_keep( sobj )
  -- проверка на предметы, тела с которыми нужно оставить
  local sect = sobj:section_name()
  if cached_item[ sect ] == nil then
    cached_item[ sect ] = always_keep_item[ sect ]
      or protected_items.actor_items_keep( sect )
      or protected_items.is_grab_body_item_keep( sect )
      or get_bool( sect, "watcher_act.bad_item", false )
  end
  return cached_item[ sect ]
end


-- Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.
-- Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
-- Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class
-- Оставили одно, которое лучше (а), но патронов нет (б) (%)
-- Одно, которое лучше (а), но хуже (б) - в новости на продажу
-- Остальное на продажу
-- Патроны оставили только те, что подходят к (а), остальные на продажу
-- Для вояк - только родной калаш надо бы... Не продавать вобще?
-- Оставляем не более 2 аптечек и бинтов, антирада
-- Оставляем 1-2 гранаты (%)
-- Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
-- Еда, водка - не более 1-2 шт (%)
-- Броники наверное продаем...
-- Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
function process_trade( npc )
  -- Имеет смысл проверять на наличие trade в секции [logic]...
  if is_npc_can_trade( npc ) then
    local b_friend = false
    local m_comm   = npc:community()
    if friends_comm[ m_comm ] then
      if npc.name and npc:name() ~= "agr_ratcatcher" then
        b_friend = true
      end
    elseif m_comm == "zombied" then
      return
    end

    -- Фильтруем квестовые items - always_keep_item
    local item_list = {}
    dsh_alife.iterate_items(
      function( sobj )
        if not item_keep( sobj ) then
          table.insert( item_list, sobj )
        end
      end,
      npc.id
    )

    local sell_list = {}
    if table.getn( item_list ) > 0 then
      table.sort(
        item_list,
        function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
      )
      -- Выберем, что за оружие оставит себе NPC.
      local cnt_medkit    = 0
      local cnt_antirad   = 0
      local cnt_bandage   = 0
      local cnt_grenade   = 0
      local cnt_food      = 0
      local cnt_drink     = 0
      local cnt_torch     = 0
      local cnt_pda       = 0
      local cnt_radio     = 0
      local cnt_guitar    = 0
      local cnt_binocular = 0
      local cnt_knife     = 0
      local cnt_arts      = 0
      local cnt_detector  = 0
      local cnt_mparts    = 0
      local cnt_sigaret   = 0
      local cnt_gl        = {}
      local weapons       = {}
      local ammo          = {}
      local death_items   = death_manager.get_death_items()
      for _, v in ipairs( item_list ) do
        local sect = v:section_name()
        if isWeaponGrenade( v ) then
          cnt_grenade = cnt_grenade + 1
          if cnt_grenade > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "ammo_m209" then
          cnt_gl[ sect ] = ( cnt_gl[ sect ] or 0 ) + 1
          if cnt_gl[ sect ] > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "ammo_vog-25" or sect == "ammo_vog-25p" then
          cnt_gl[ "ammo_vog-25" ] = ( cnt_gl[ "ammo_vog-25" ] or 0 ) + 1
          if cnt_gl[ "ammo_vog-25" ] > 1 then
            table.insert( sell_list, v )
          end
        elseif
          string.find( sect, "wpn_addon_scope", 1, true )
          or string.find( sect, "wpn_addon_silencer", 1, true )
          or string.find( sect, "wpn_addon_grenade_launcher", 1, true )
        then
          table.insert( sell_list, v )
        elseif sect == "wpn_knife" then
          cnt_knife = cnt_knife + 1
          if cnt_knife > 1 then
            table.insert( sell_list, v )
          end
        elseif isWeapon( v ) then
          local ac = get_string( sect, "ammo_class" )
          if ac and ac ~= "" then
            table.insert( weapons, {
              obj         = v,
              ammo        = parse_names( ac ),
              sorted_ammo = sort_ammo_classes( ac ),
            })
          else
            table.insert( weapons, { obj = v } )
          end
        elseif string.find( sect, "ammo_", 1, true ) then
          if ammo[ sect ] then
            table.insert( ammo[ sect ].objs, v )
          else
            ammo[ sect ] = { objs = { v } }
          end
        elseif
          dsh.is_artefact( sect )
          or string.find( sect, "mutant_af_", 1, true )
        then
          -- артефакты продаем, но не сразу
          if math.random() < 0.1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_torch" then
          cnt_torch = cnt_torch + 1
          if cnt_torch > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_pda" then
          cnt_pda = cnt_pda + 1
          if cnt_pda > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "hand_radio" then
          cnt_radio = cnt_radio + 1
          if cnt_radio > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "guitar_a" or sect == "harmonica_a"
          or sect == "balalaika_a"
        then
          cnt_guitar = cnt_guitar + 1
          if cnt_guitar > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "sigaret" or sect == "cigara" then
          cnt_sigaret = cnt_sigaret + 1
          if cnt_sigaret > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "binocular_a" or sect == "wpn_binoc" then
          cnt_binocular = cnt_binocular + 1
          if cnt_binocular > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "yad"
          or sect == "medkit"
          or sect == "medkit_army"
          or sect == "medkit_scientic"
        then
          cnt_medkit = cnt_medkit + 1
          if cnt_medkit > 4 then
            table.insert( sell_list, v )
          end
        elseif sect == "antirad" then
          cnt_antirad = cnt_antirad + 1
          if cnt_antirad > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "bandage" then
          cnt_bandage = cnt_bandage + 1
          if cnt_bandage > 3 then
            table.insert( sell_list, v )
          end
        elseif food[ sect ] then
          cnt_food = cnt_food + 1
          if cnt_food > 4 then
            table.insert( sell_list, v )
          end
        elseif
          sect =="vodka" or sect == "energy_drink" or sect == "flaska"
          or sect == "beer_a"
        then
          cnt_drink = cnt_drink + 1
          if cnt_drink > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "detector_simple"
          or sect =="detector_advances"
          or sect == "detector_elite"
        then
          cnt_detector = cnt_detector + 1
          if cnt_detector > 1 then
            table.insert( sell_list, v )
          end
        elseif get_bool( sect, "monster_part", false ) then
          if cnt_mparts > 2 then
            table.insert( sell_list, v )
          else
            if math.random() < 0.1 then
              table.insert( sell_list, v )
            else
              cnt_mparts = cnt_mparts + 1
            end
          end
        elseif string.find( sect, "outfit" ) or string.find( sect, "exo" ) then
          table.insert( sell_list, v )
        elseif death_items[ sect ] then
          table.insert( sell_list, v )
        end
      end

      local modes = rx_wmgr.read_wm_modes(
        npc:community(), ranks.get_obj_rank_name( npc ), npc:section_name()
      )
      local weapons_types = {}
      for _, i in ipairs( modes.types ) do
        weapons_types[ i.t ] = {}
      end
      for _, t in ipairs( weapons ) do
        local sect   = t.obj:section_name()
        local params = rx_wmgr.read_wpn_params( sect )
        t.ammo_mag_size = params.mag
        t.prm = 0
        if modes.mode1 == "1" then
          t.prm = params.cst + modes.addcost
        elseif modes.mode1 == "2" then
          local dst = params.bullet_speed -- params.dst
          local kf  = rx_wmgr.wm_modes.koeffs[ modes.koeffs ]
          t.prm = ( params.dmg * kf.dmg )
            + ( params.rpm * kf.rpm )
            + ( dst * kf.dst )
            + ( ( 50 / params.dsp ) * kf.dsp )
        elseif modes.mode1 == "3" then
          t.prm = rx_wmgr.wm_modes.priors[ modes.priors ][ sect ] or 0
        end
        local pk = get_netpk( t.obj, 1 )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s",
          script_name(), t.obj:name()
        )
        local data = pk:get()
        t.pk           = pk
        t.pk_data      = data
        t.cond         = data.condition
        t.has_gl       = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.gl
        ) ~= 0
        t.has_scope    = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.scope
        ) ~= 0
        t.has_silencer = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.silencer
        ) ~= 0
        local pr = 0
        if t.has_gl then
          pr = pr + t.prm * modes.grenadelauncher / 100
        end
        if t.has_scope then
          pr = pr + t.prm * modes.scope / 100
        end
        if t.has_silencer then
          pr = pr + t.prm * modes.silencer / 100
        end
        for _, v in ipairs( modes.types ) do
          if v.t == params.typ then
            pr = pr + t.prm * v.p / 100
            break
          end
        end
        t.prm = t.prm + pr + t.obj.id / 100000 + t.cond * t.prm / 50
        if weapons_types[ params.typ ] then
          table.insert( weapons_types[ params.typ ], t )
        else
          weapons_types[ params.typ ] = { t }
        end
      end

      local our_weapons = {}
      for k, v in pairs( weapons_types ) do
        table.sort(
          v, function( a, b ) return a.prm > b.prm end
        )
        -- Так, теперь у нас отсортированны все пушки НПС. Найдем ту,
        -- для которой есть патроны...
        local b_self = false
        local b_best = false
        for _, w in ipairs( v ) do
          local b_ammo = false
          local vac    = w.ammo
          if vac and table.getn( vac ) > 0 then
            for kk, vv in ipairs( vac ) do
              if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
                -- Так, патроны есть.
                b_ammo = true
                break
              end
            end
          end
          if is_broken_wpn( w ) then
            table.insert( sell_list, w.obj )
          elseif ( not b_self ) and b_ammo then
            b_self = true
            table.insert( our_weapons, w )
          elseif not b_best then
            if b_self then
              -- если собственное оружие у нас самое лучшее, т.е. оно
              -- было первым в списке, то запасное нам не нужно.
              table.insert( sell_list, w.obj )
            else
              -- к самому лучшему оружию нет патронов. Сохраним его и
              -- подождем, когда появятся патроны.
              b_best = true
              table.insert( our_weapons, w )
            end
          else
            table.insert( sell_list, w.obj )
          end
        end
      end

      process_ammo_trade( sell_list, ammo, npc, our_weapons )
      if weapon_repair_allowed then
        process_weapon_repair( our_weapons )
      end
      for _, w in ipairs( our_weapons ) do
        if w.commit then
          w.pk:set( w.pk_data )
          w.commit = nil
        end
      end

      if
        dsh_lc_fixes.has_level_changed()
        and object_level_name( npc ) == level.name()
      then
        if cnt_food == 0 then
          for sect, n in pairs( food ) do
            if math.random() < n then
              local sobj = alife():create(
                sect,
                npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
                npc.id
              )
              sobj = alife():object( sobj.id )
              dsh_alife.add_item( sobj )
              cnt_food = cnt_food + 1
              if cnt_food == 3 then break end
            end
          end
        end
      end

      -- Так, с оружием закончили...
      -- Все, что осталось - надо продать.
      -- 1 самое дорогое можно попробовать через новости...
      -- ... ну и когда-нибудь, как фишка ляжет, наконец от него избавиться.
      local money = 0
      if b_friend and table.getn( sell_list ) > 0 and math.random() < 0.9 then
        table.sort(
          sell_list,
          function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
        )
        local zz = sell_list[ 1 ]
        if get_item_cost( zz ) >= sell_limit then
          -- Продадим через новости.
          news_main.on_offline_trade( npc, zz )
          table.remove( sell_list, 1 )
        end
      end
      for _, sobj in ipairs( sell_list ) do
        local cost = get_item_cost( sobj )
        if cost > 0 then
          local coeff = math.random( 30, 50 ) / 100
          local price = math.floor( cost * coeff )
          money = money + price
          -- Почистим items
          -- Idler++-- корректируем хабар в помеченных тайниках
          gps_habar.remove_item( npc.id, sobj )
          dsh_alife.release( sobj )
        end
      end
      if money > 0 then
        local pk = get_netpk( npc, 1 )
        if pk:isOk() then
          local data = pk:get()
          if data.money then money = money + data.money end
          data.money = money
          pk:set( data )
        end
      end
    end
  end
end


function process_ammo_trade( sell_list, ammo, npc, our_weapons )
  for _, w in ipairs( our_weapons ) do
    local data = w.pk_data
    if data.ammo_elapsed < w.ammo_mag_size then
      -- log2(
      --   "[%s]: %s has no enough ammo in mag for %s: %s < %s, fixed",
      --   script_name(), npc:name(), w.obj:section_name(), data.ammo_elapsed,
      --   w.ammo_mag_size
      -- )
      data.ammo_elapsed = w.ammo_mag_size
      w.commit          = true
    end
    local vac, sorted_ammo = w.ammo, w.sorted_ammo
    if vac and table.getn( vac ) > 0 then
      local params = {}
      for _, t in ipairs( sorted_ammo ) do
        params[ t.sect ] = t
      end
      local has_ammo
      for i = table.getn( sorted_ammo ), 1, -1 do
        local sect = sorted_ammo[ i ].sect
        if ammo[ sect ] and table.getn( ammo[ sect ].objs ) > 0 then
          if has_ammo then
            if not ammo[ sect ].inuse then
              ammo[ sect ].sell = true
              -- log2(
              --   "[%s]: %s has extra ammo type for %s: %s < %s, marked for sell",
              --   script_name(), npc:name(), w.obj:section_name(), sect, has_ammo
              -- )
            end
          else
            local loaded_sect = vac[ data.ammo_type + 1 ]
            if params[ loaded_sect ].hit < sorted_ammo[ i ].hit then
              -- log2(
              --   "[%s]: %s uses weak ammo for %s: %s(%s) < %s(%s), changed",
              --   script_name(), npc:name(), w.obj:section_name(),
              --   loaded_sect, params[ loaded_sect ].hit,
              --   sorted_ammo[ i ].sect, sorted_ammo[ i ].hit
              -- )
              data.ammo_type = sorted_ammo[ i ].ammo_class - 1
              w.commit       = true
            end
            ammo[ sect ].inuse = true
            ammo[ sect ].sell  = false
            has_ammo = sect
          end
        end
      end
      if not has_ammo then
        local ammo_class = data.ammo_type + 1
        local sect       = vac[ ammo_class ]
        -- log2(
        --   "[%s]: %s has no ammo in inv for %s, spawned %s",
        --   script_name(), npc:name(), w.obj:section_name(), sect
        -- )
        local sobj = alife():create(
          sect,
          npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
          npc.id
        )
        sobj = alife():object( sobj.id )
        dsh_alife.add_item( sobj )
        ammo[ sect ] = {
          [ "inuse" ] = true,
          [ "objs"  ] = { sobj },
        }
      end
    end
  end
  for sect, v in pairs( ammo ) do
    if v.sell then
      if table.getn( v.objs ) > 0 then
        -- log2(
        --   "[%s]: %s has marked %s ammo box(es) of %s, sold",
        --   script_name(), npc:name(), table.getn( v.objs ), sect
        -- )
        for _, sobj in ipairs( v.objs ) do
          table.insert( sell_list, sobj )
        end
      end
    else
      if table.getn( v.objs ) > 1 then
        log2(
          "[%s]: %s has %s/%s extra ammo box(es) of %s, sold",
          script_name(), npc:name(),
          table.getn( v.objs ) - 1, table.getn( v.objs ), sect
        )
        for i = 2, table.getn( v.objs ) do
          local sobj = v.objs[ i ]
          table.insert( sell_list, sobj )
        end
      end
    end
  end
end


function is_broken_wpn( w )
  return w.cond < rx_wmgr.wm_modes.min_cond
end


function process_weapon_repair( our_weapons )
  for _, w in ipairs( our_weapons ) do
    if w.cond < 1 and not is_broken_wpn( w ) then
      local data = w.pk_data
      if data.condition < 0.9 then
        data.condition = data.condition + 0.1
      else
        data.condition = 1
      end
      w.cond   = data.condition
      w.commit = true
    end
  end
end
function process_weapon_repair_allowed() end


function sobj_is_far( obj, distance )
  local result = true
  -- на одном ли уровне?
  if object_level_name( obj ) == level.name() then
    -- Достаточно ли далеко?
    if obj.position:distance_to( db.actor:position() ) < distance then
      result = false
    end
  end
  return result
end


function box_is_protected( v )
  return protected.ids[ v.id ]
    or protected.names[ v:name() ]
    or protected.story_ids[ v.m_story_id ]
    or protected.sections[ v:section_name() ]
    or false
end


function is_valuable( item )
  local result = false
  local cost   = get_item_cost( item )
  if IAmAWeapon[ item:clsid() ] and cost >= 1000 then
    result = true
  elseif cost >= 800 then
    result = true
  end
  return result
end


local sorted_ammo_classes = {}
function sort_ammo_classes( ac )
  if not sorted_ammo_classes[ ac ] then
    local sorted = {}
    for i, sect in ipairs( parse_names( ac ) ) do
      local k_hit     = get_float( sect, "k_hit",     1 )
      local buck_shot = get_float( sect, "buck_shot", 1 )
      table.insert( sorted, {
        ammo_class = i,
        hit        = k_hit * buck_shot,
        sect       = sect,
      })
    end
    table.sort(
      sorted, function( a, b ) return a.hit < b.hit end
    )
    sorted_ammo_classes[ ac ] = sorted
  end
  return sorted_ammo_classes[ ac ]
end
