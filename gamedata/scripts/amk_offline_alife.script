-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

off_npcs = {}
items    = {}
always_keep_item = {}

-- Как часто делать апдейты, реальные минуты
local iFreq       = 0 --12
-- Как часто генерить события в оффлайн (реальные секунды)
local alife_freq  = 48

local maps = {
  "atp_for_test22",
  "aver",
  "dead_city",
  "generators",
  "hospital",
  "jupiter",
  -- "jupiter_underground",
  -- "labx8",
  "l01_escape",
  "l02_garbage",
  "l03_agroprom",
  "l03u_agr_underground",
  "l04_darkvalley",
  -- "l04u_labx18",
  "l05_bar",
  "l06_rostok",
  "l07_military",
  "l08_yantar",
  -- "l08u_brainlab",
  "l10_radar",
  -- "l10u_bunker",
  "l11_pripyat",
  -- "l12_stancia",
  -- "l12_stancia_2",
  -- "l12u_control_monolith",
  -- "l12u_sarcofag",
  "limansk",
  "lost_village",
  "marsh",
  "puzir",
  "pripyat",
  "red_forest",
  "warlab",
  "zaton",
}

protected = {
  names     = {}, -- имена объектов (стоит добавлять только уникальные имена!)
  ids       = {}, -- ID объектов
  story_ids = {   -- story ID объектов
    5008,
    5013,
    5014,
    5041,
    5065,
    5084,
    5104,
    5205,
    5222,
    5226,
    5237,
    5238,
    5243,
    5244,
    5245,
    5246,
    5247,
    5248,
    5249,
    5250,
    5254,
    5255,
    5408,
    5413,
    5428,
    5433,
    5434,
    5444,
    5446,
    5470,
    5471,
    5472,
    5473,
    5474,
    573,
  },
  sections = {    -- секции объектов
    "volna_shron",
    "taynik_kuznec7",
    "dyak_mines_box",
    "radiodetail_box2",
    "radiodetail_box4",
    "keis_key_box",
    "computer_flash",
    "notebook_flash",
    "disk_flash",
    "pda_flash",
    "taynik_podarok",
  },
}

-- радиус "обзора"
local look_radius        = 50
-- Вещи дешевле продает торговцам
local sell_limit         = 3000
local rate_art_found     = 100
local to_actor           = 150
local look_radius_box    = 20

local stalkers_comm = {
  [ "bandit"  ] = true,
  [ "dolg"    ] = true,
  [ "ecolog"  ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
}


function schedule_update()
  if iFreq == 0 then return end
  dsh.timeout( iFreq * 60 * 1000, function()
    off_npcs = {}
    items    = {}
    offline_update_timer():start( true )
  end )
end


class "offline_update_timer" ( ogse_qt.quick_timer )
function offline_update_timer:__init() super()
  self.cur_id = 1
end

function offline_update_timer:condition()
  return self.cur_id == 65535
end

function offline_update_timer:action()
  schedule_update()
end

function offline_update_timer:update()
  local sobj = alife():object( self.cur_id )
  if sobj then
    add_fresh_meat( sobj )
  end
  self.cur_id = self.cur_id + 1
end


function add_fresh_meat( obj )
  if
    obj and obj.m_game_vertex_id
    and game_graph():valid_vertex_id( obj.m_game_vertex_id )
    and db.actor and (
      db.actor:id() ~= obj.id
      and obj.parent_id ~= db.actor:id()
    )
    and ( not always_keep_item[ obj:section_name() ] )
    and ( not protected_items.actor_items_keep( obj:section_name() ) )
    and ( not protected_items.is_grab_body_item_keep( obj:section_name() ) )
    and ( not protected_items.is_no_offline_alife_npc( obj:section_name() ) )
    and ( not get_bool( obj:section_name(), "quest_item", false ) )
    and ( not get_bool( obj:section_name(), "watcher_act.bad_item", false ) )
  then
    local map = object_level_name( obj )
    if not off_npcs[ map ] then
      off_npcs[ map ] = {
        artefacts = {},
        inv_boxes = {},
        monsters  = {},
        stalkers  = {},
        weapons   = {},
      }
    end
    if
      IsStalker( obj ) and obj:alive() and obj:health() > 0
      and obj.m_story_id == 4294967296
      and obj:community() ~= "zombied"
      and not xr_companion.is_companion( obj.id )
    then
      table.insert(
        off_npcs[ map ].stalkers, { id = obj.id, name = obj:name() }
      )
    elseif dsh.is_artefact( obj:section_name() ) and obj.parent_id == 65535 then
      table.insert(
        off_npcs[ map ].artefacts, { id = obj.id, name = obj:name() }
      )
    elseif
      (
        obj:clsid() == clsid.inventory_box
        and not box_is_protected( obj )
      )
      or (
        obj:section_name() == "dsh_treasure_item"
        and not protected.ids[ obj.id ]
      )
    then
      table.insert(
        off_npcs[ map ].inv_boxes, { id = obj.id, name = obj:name() }
      )
    elseif obj.parent_id ~= 65535 and obj.m_story_id == 4294967296 then
      local zz = alife():object( obj.parent_id )
      if zz then
        if not protected.ids[ obj.parent_id ] then
          if not items[ obj.parent_id ] then items[ obj.parent_id ] = {} end
          table.insert(
            items[ obj.parent_id ],
            {
              id    = obj.id,
              lname = map,
              name  = obj:name(),
            }
          )
        end
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.insert_item( obj.parent_id, obj )
      end
    end
  end
end


function update_npc_tables()
  items    = {}
  off_npcs = {}
  for a = 1, 65534 do
    local sobj = alife():object( a )
    if sobj then
      add_fresh_meat( sobj )
    end
  end
  schedule_update()
  dsh.timeout( math.random( alife_freq ) * 1000, function()
    offline_alife_timer():start()
  end )
end


local weapon_repair_allowed = false
function update_trade()
  if
    ogse_st_mgr.timer_exists(
      script_name() .. ".weapon_repair.forbidden"
    )
  then
    weapon_repair_allowed = false
  else
    weapon_repair_allowed = true
  end
  for a = 1, 65534 do
    local sobj = alife():object( a )
    if sobj then
      process_trade( sobj )
    end
  end
  if weapon_repair_allowed then
    dsh.start_gtimerDHMS(
      script_name() .. ".weapon_repair.forbidden",
      0, math.random( 20, 24 ), 0, 0,
      script_name() .. ".process_weapon_repair_allowed"
    )
    weapon_repair_allowed = false
  end
end


function update_tables( level )
  cleanup_this_level_items( level )
  local ggraph = game_graph()
  local sim    = alife()
  for a = 1, 65534 do
    local obj = sim:object( a )
    if obj then
      if
        ggraph:valid_vertex_id( obj.m_game_vertex_id )
        and object_level_name( obj ) == level
      then
        add_fresh_meat( obj )
      elseif obj.parent_id then
        local p_obj = sim:object( obj.parent_id )
        if
          p_obj
          and ggraph:valid_vertex_id( p_obj.m_game_vertex_id )
          and object_level_name( p_obj ) == level
        then
          add_fresh_meat( obj )
        end
      end
    end
  end
end


function cleanup_this_level_items( lname )
  off_npcs[ lname ] = {
    monsters = {}, stalkers = {}, weapons = {}, artefacts = {}, inv_boxes = {}
  }
  local remove = {}
  for k, v in pairs( items ) do
    if table.getn( v ) > 0 then
      if v[ 1 ].lname == lname then
        remove[ k ] = true
      end
    else
      remove[ k ] = true
    end
  end
  for k, v in pairs( remove ) do
    items[ k ] = nil
  end
end


class "offline_alife_timer" ( ogse_qt.quick_timer )
function offline_alife_timer:__init() super()
  self.lname    = maps[ math.random( table.getn( maps ) ) ]
  self.stalkers = {}
  if off_npcs[ self.lname ] then
    for _, v in ipairs( off_npcs[ self.lname ].stalkers ) do
      table.insert( self.stalkers, v )
    end
    if table.getn( self.stalkers ) > 1 then
      dsh.shuffle( self.stalkers )
    end
  end
end

function offline_alife_timer:condition()
  return table.getn( self.stalkers ) == 0
end

function offline_alife_timer:action()
  dsh.timeout( alife_freq * 1000, function()
    offline_alife_timer():start()
  end )
end

function offline_alife_timer:update()
  if table.getn( self.stalkers ) == 0 then return end
  local st     = table.remove( self.stalkers )
  local victim = alife():object( st.id )
  if
    victim and victim:name() == st.name
    and object_level_name( victim ) == self.lname
    and ( not victim.online ) and victim:alive()
    and can_be_spawned( victim )
  then
    local vdata = collect_info( victim, self.lname )
    if table.getn( vdata.artefacts ) > 0 then
      -- есть арты
      on_artifacts_found( victim, vdata )
    end
    if table.getn( vdata.inv_boxes ) > 0 then
      -- есть контейнеры. Надо обыскать.
      on_inv_boxes_found( victim, vdata )
    end
  end
end


--собираем инфу о неписе
function collect_info( victim, map )
  local vdata = {}
  vdata.rank      = victim:rank()
  vdata.health    = victim:health()
  vdata.community = victim:community()

  --составляем список артов в зоне "видимости"
  vdata.artefacts = {}
  if off_npcs[ map ].artefacts then
    for _, v in ipairs( off_npcs[ map ].artefacts ) do
      local artefact = alife():object( v.id )
      if
        artefact and object_level_name( artefact ) == map
        and artefact.can_switch_online and artefact:can_switch_online()
        and artefact:name() == v.name
        and artefact.parent_id == 65535
        and victim.position:distance_to( artefact.position ) < look_radius
        and sobj_is_far( artefact, to_actor )
      then
        local zdist = victim.position:distance_to( artefact.position ) / look_radius
        if math.random() > zdist then
          table.insert(
            vdata.artefacts, { id = artefact.id, name = artefact:name() }
          )
        end
      end
    end
  end

  --составляем список контейнеров в зоне "видимости"
  vdata.inv_boxes = {}
  if off_npcs[ map ].inv_boxes then
    for _, v in ipairs( off_npcs[ map ].inv_boxes ) do
      local inv_box = alife():object( v.id )
      if
        inv_box
        and inv_box.can_switch_online and inv_box:can_switch_online()
        and inv_box:name() == v.name
        and inv_box.parent_id == 65535
        and victim.position:distance_to( inv_box.position ) < look_radius_box
        and sobj_is_far( inv_box, to_actor )
        and not treasure_manager.is_active( inv_box )
      then
        local zdist = victim.position:distance_to( inv_box.position ) / look_radius_box
        if math.random() > zdist then
          table.insert(
            vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() }
          )
        end
      end
    end
  end

  return vdata
end


-- Моя прелесссть
function on_artifacts_found( victim, vdata )
  for _, v_obj in ipairs( vdata.artefacts ) do
    local object = alife():object( v_obj.id )
    if object then
      local obj = pick_item( victim, object )
      victim:set_rank( victim:rank() + rate_art_found )
    end
  end
end


-- О, нычка - это гуд.  Idler ++ проверим, а сможет ли непись долезть
-- до тайника.  если есть аномалии в радиусе 20м, меньше шансов или
-- если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail( victim, box )
  -- отсекаем сюжетные тайники
  if
    transparent_treasure.IsTaken( box:section_name() )
    and box:section_name() ~= "m_inventory_box"
  then
    return false
  end
  local n_rnd = math.random( 3, 10 )
  if math.abs( box.position.y - victim.position.y ) > n_rnd then
    return false
  end
  if object_level_name( box ) == level.name() then
    local anom_list = amk_anoms.get_anomaly_list_for_pos( box.position, 20 )
    local n_anoms   = table.getn( anom_list )
    local n_rnd     = math.random( 100 )
    -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При
    -- 5 - точно до ящика не доберется
    if n_rnd < n_anoms * 20 then return false end
  end
  return true
end


function on_inv_boxes_found( victim, vdata )
  for _, v_obj in ipairs( vdata.inv_boxes ) do
    local object = alife():object( v_obj.id )
    if object then
      -- Idler ++-- если нычка доступна - можно шмонать
      if inv_box_is_avail( victim, object ) then
        if object:section_name() == "dsh_treasure_item" then
          dsh_rukzak.on_inv_box_found( object.id, victim )
        elseif items[ v_obj.id ] then
          for _, v_itA in ipairs( items[ v_obj.id ] ) do
            local itA = alife():object( v_itA.id )
            if
              itA
              and itA.parent_id == v_obj.id
              and itA:name() == v_itA.name
            then
              -- Решим, подбираем или нет?
              if is_valuable( itA ) then
                pick_item( victim, itA )
              end
            end
          end
        end
        victim:set_rank( victim:rank() + rate_art_found )
      end
    end
  end
end


function pick_item( npc, obj )
  local section = obj:section_name()
  local new     = alife():create(
    section,
    npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
    npc.id
  )
  ASSERT( new, "can't create new %s", section )
  local pk = get_netpk( obj, 1 )
  if pk:isOk() then
    local data = pk:get()
    local cd   = data.custom_data:getString()
    if cd and cd ~= "" then
      local new_pk = get_netpk( new, 1 )
      if new_pk:isOk() then
        local new_data = pk:get()
        new_data.custom_data:setString( cd )
        new_pk:set( new_data )
      end
    end
  end
  if not items[ npc.id ] then items[ npc.id ] = {} end
  table.insert(
    items[ npc.id ],
    {
      id    = new.id,
      lname = object_level_name( new ),
      name  = new:name(),
    }
  )
  -- Idler++-- корректируем хабар в помеченных тайниках
  gps_habar.insert_item( npc.id, new )
  if
    obj.parent_id
    and items[ obj.parent_id ] and table.getn( items[ obj.parent_id ] ) > 0
  then
    for z = 1, table.getn( items[ obj.parent_id ] ) do
      if items[ obj.parent_id ][ z ].id == obj.id then
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] )
        table.remove( items[ obj.parent_id ], z )
        break
      end
    end
  end
  alife():release( alife():object( obj.id ), true )
  return new
end


function get_item_cost(item)
  local result = 0
  if item and item.section_name then
    result = get_float(item:section_name(), "cost", 0 )
    local params = m_net_utils.get_item_data( item )
    if params.condition > 0 then
      result = result * params.condition
    else
      result = 1
    end
  end
  return result
end


-- Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.
-- Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
-- Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class
-- Оставили одно, которое лучше (а), но патронов нет (б) (%)
-- Одно, которое лучше (а), но хуже (б) - в новости на продажу
-- Остальное на продажу
-- Патроны оставили только те, что подходят к (а), остальные на продажу
-- Для вояк - только родной калаш надо бы... Не продавать вобще?
-- Оставляем не более 2 аптечек и бинтов, антирада
-- Оставляем 1-2 гранаты (%)
-- Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
-- Еда, водка - не более 1-2 шт (%)
-- Броники наверное продаем...
-- Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
function process_trade( npc )
  local item_list = {}
  local sell_list = {}
  -- Имеет смысл проверять на наличие trade в секции [logic]...
  if
    npc and IsStalker( npc ) and npc:alive()
    and npc.m_story_id ~= nil and npc.m_story_id == 4294967296
    and ( not xr_companion.is_companion( npc.id ) )
    and items[ npc.id ] and table.getn( items[ npc.id ] ) > 0
    and ( not protected_items.is_no_offline_alife_npc( npc:section_name() ) )
  then
    local b_stalker = false
    local m_comm    = npc:community()
    if stalkers_comm[ m_comm ] then
      if npc.name and npc:name() ~= "agr_ratcatcher" then
        b_stalker = true
      end
    elseif m_comm == "zombied" then
      return
    end

    --Фильтруем квестовые items - always_keep_item
    for _, ov in ipairs( items[ npc.id ] ) do
      local obj = alife():object( ov.id )
      if obj and obj.parent_id == npc.id and obj:name() == ov.name then
        if
          not (
            always_keep_item[ obj:section_name() ]
            or protected_items.actor_items_keep( obj:section_name() )
          )
        then
          table.insert( item_list, obj )
        end
      end
    end

    if item_list and table.getn( item_list ) > 0 then
      table.sort(
        item_list,
        function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
      )
      -- Выберем, что за оружие оставит себе NPC.
      local cnt_medkit    = 0
      local cnt_antirad   = 0
      local cnt_bandage   = 0
      local cnt_grenade   = 0
      local cnt_food      = 0
      local cnt_drink     = 0
      local cnt_torch     = 0
      local cnt_pda       = 0
      local cnt_radio     = 0
      local cnt_guitar    = 0
      local cnt_harmonica = 0
      local cnt_binocular = 0
      local cnt_knife     = 0
      local cnt_arts      = 0
      local cnt_detector  = 0
      local cnt_addons    = 0
      local cnt_mparts    = 0
      local weapons       = {}
      local ammo          = {}
      for _, v in ipairs( item_list ) do
        local sect = v:section_name()
        if
          sect == "grenade_f1"
          or sect =="grenade_gd-05"
          or sect == "grenade_rgd5"
          or sect == "grenade_flash"
          or sect == "grenade_f1_double"
          or sect == "grenade_m61"
        then
          cnt_grenade = cnt_grenade + 1
          if cnt_grenade > 3 then
            table.insert( sell_list, v )
          end
        elseif
          string.find( sect, "^wpn_addon_scope" )
          or string.find( sect, "^wpn_addon_silencer" )
          or string.find( sect, "^wpn_addon_grenade_launcher" )
        then
          cnt_addons = cnt_addons + 1
          if cnt_addons > 2 then
            table.insert( sell_list, v )
          end
        elseif sect == "wpn_knife" then
          cnt_knife = cnt_knife + 1
          if cnt_knife > 1 then
            table.insert( sell_list, v )
          end
        elseif isWeapon( v ) then
          local ac = get_string( sect, "ammo_class" )
          if ac and ac ~= "" then
            table.insert( weapons, { obj = v, ammo = parse_names( ac ) } )
          else
            table.insert( weapons, { obj = v } )
          end
        elseif string.find( sect, "^ammo_" ) then
          if ammo[ sect ] then
            table.insert( ammo[ sect ].objs, v )
          else
            ammo[ sect ] = { objs = { v } }
          end
        elseif
          dsh.is_artefact( sect )
          or string.find( sect, "mutant_af_", 1, true )
        then
          -- артефакты продаем
          table.insert( sell_list, v )
        elseif sect == "device_torch" then
          cnt_torch = cnt_torch + 1
          if cnt_torch > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_pda" then
          cnt_pda = cnt_pda + 1
          if cnt_pda > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "hand_radio" then
          cnt_radio = cnt_radio + 1
          if cnt_radio > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "harmonica_a" then
          cnt_harmonica = cnt_harmonica + 1
          if cnt_harmonica > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "guitar_a" then
          cnt_guitar = cnt_guitar + 1
          if cnt_guitar > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "binocular_a" or sect == "wpn_binoc" then
          cnt_binocular = cnt_binocular + 1
          if cnt_binocular > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "yad"
          or sect == "medkit"
          or sect == "medkit_army"
          or sect == "medkit_scientic"
        then
          cnt_medkit = cnt_medkit + 1
          if cnt_medkit > 4 then
            table.insert( sell_list, v )
          end
        elseif sect == "antirad" then
          cnt_antirad = cnt_antirad + 1
          if cnt_antirad > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "bandage" then
          cnt_bandage = cnt_bandage + 1
          if cnt_bandage > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "bread_a"
          or sect =="bread"
          or sect == "kolbasa"
          or sect == "kolbasa_a"
          or sect == "conserva"
        then
          cnt_food = cnt_food + 1
          if cnt_food > 4 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "vodka_a"
          or sect =="vodka"
          or sect == "energy_drink"
        then
          cnt_drink = cnt_drink + 1
          if cnt_drink > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "detector_simple"
          or sect =="detector_advances"
          or sect == "detector_elite"
        then
          cnt_detector = cnt_detector + 1
          if cnt_detector > 1 then
            table.insert( sell_list, v )
          end
        elseif get_bool( sect, "monster_part", false ) then
          cnt_mparts = cnt_mparts + 1
          if cnt_mparts > 2 then
            table.insert( sell_list, v )
          end
        elseif string.find( sect, "outfit" ) or string.find( sect, "exo" ) then
          table.insert( sell_list, v )
        end
      end

      local modes = rx_wmgr.read_wm_modes(
        npc:community(), ranks.get_obj_rank_name( npc ), npc:section_name()
      )
      local weapons_types = {}
      for _, i in ipairs( modes.types ) do
        weapons_types[ i.t ] = {}
      end
      for _, w in ipairs( weapons ) do
        local sect   = w.obj:section_name()
        local params = rx_wmgr.read_wpn_params( sect )
        local t      = { obj = w.obj, ammo = w.ammo, prm = 0 }
        if modes.mode1 == "1" then
          t.prm = params.cst + modes.addcost
        elseif modes.mode1 == "2" then
          local kf = rx_wmgr.wm_modes.koeffs[ modes.koeffs ]
          t.prm = ( params.dmg * kf.dmg )
            + ( params.rpm * kf.rpm )
            + ( params.dst * kf.dst )
            + ( ( 100 / params.dsp ) * kf.dsp )
        elseif modes.mode1 == "3" then
          t.prm = rx_wmgr.wm_modes.priors[ modes.priors ][ sect ] or 0
        end
        local pk = get_netpk( t.obj, 1 )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s",
          script_name(), t.obj:name()
        )
        local data = pk:get()
        t.cond   = data.condition
        t.has_gl = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.gl
        ) ~= 0
        t.has_scope = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.scope
        ) ~= 0
        t.has_silencer = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.silencer
        ) ~= 0
        local pr = 0
        if t.has_gl then
          pr = pr + t.prm * modes.grenadelauncher / 100
        end
        if t.has_scope then
          pr = pr + t.prm * modes.scope / 100
        end
        if t.has_silencer then
          pr = pr + t.prm * modes.silencer / 100
        end
        for _, v in ipairs( modes.types ) do
          if v.t == params.typ then
            pr = pr + t.prm * v.p / 100
            break
          end
        end
        t.prm = t.prm + pr + w.obj.id / 100000 + t.cond * t.prm / 50
        if weapons_types[ params.typ ] then
          table.insert( weapons_types[ params.typ ], t )
        else
          weapons_types[ params.typ ] = { t }
        end
      end

      local our_weapons = {}
      for k, v in pairs( weapons_types ) do
        table.sort(
          v, function( a, b ) return a.prm > b.prm end
        )
        -- Так, теперь у нас отсортированны все пушки НПС. Найдем ту,
        -- для которой есть патроны...
        local b_self = false
        local b_best = false
        for _, w in ipairs( v ) do
          local b_ammo = false
          local vac    = w.ammo
          if vac and table.getn( vac ) > 0 then
            for kk, vv in ipairs( vac ) do
              if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
                -- Так, патроны есть.
                b_ammo = true
                break
              end
            end
          end
          if is_broken_wpn( w ) then
            table.insert( sell_list, w.obj )
          elseif ( not b_self ) and b_ammo then
            b_self = true
            table.insert( our_weapons, w )
          elseif not b_best then
            if b_self then
              -- если собственное оружие у нас самое лучшее, т.е. оно
              -- было первым в списке, то запасное нам не нужно.
              table.insert( sell_list, w.obj )
            else
              -- к самому лучшему оружию нет патронов. Сохраним его и
              -- подождем, когда появятся патроны.
              b_best = true
              table.insert( our_weapons, w )
            end
          else
            table.insert( sell_list, w.obj )
          end
        end
      end
      process_ammo_trade( sell_list, ammo, npc, our_weapons )
      if weapon_repair_allowed then
        process_weapon_repair( our_weapons )
      end

      -- Так, с оружием закончили...
      -- Все, что осталось - надо продать.
      -- 1 самое дорогое можно попробовать через новости...
      -- ... ну и когда-нибудь, как фишка ляжет, наконец от него избавиться.
      local money = 0
      if b_stalker and table.getn( sell_list ) > 0 and math.random() < 0.9 then
        table.sort(
          sell_list,
          function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
        )
        local zz = sell_list[ 1 ]
        if get_item_cost( zz ) >= sell_limit then
          -- Продадим через новости.
          news_main.on_offline_trade( npc, zz )
          table.remove( sell_list, 1 )
        end
      end
      for _, vv in ipairs( sell_list ) do
        local cost = get_item_cost( vv )
        if cost > 0 then
          local coeff = math.random( 30, 50 ) / 100
          local price = math.floor( cost * coeff )
          money = money + price
          -- Почистим items
          if items[ npc.id ] and table.getn( items[ npc.id ] ) > 0 then
            for z, item in ipairs( items[ npc.id ] ) do
              if item.id == vv.id then
                table.remove( items[ npc.id ], z )
                -- Idler++-- корректируем хабар в помеченных тайниках
                gps_habar.remove_item( npc.id, item )
                break
              end
            end
          end
          alife():release( alife():object( vv.id ), true )
        end
      end
      if money > 0 then
        local pk = get_netpk( npc, 1 )
        if pk:isOk() then
          local data = pk:get()
          if data.money then money = money + data.money end
          data.money = money
          pk:set( data )
        end
      end
    end
  end
end


function process_ammo_trade( sell_list, ammo, npc, our_weapons )
  for _, w in ipairs( our_weapons ) do
    local vac = w.ammo
    if vac and table.getn( vac ) > 0 then
      local has_ammo = false
      for _, vv in ipairs( vac ) do
        if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
          ammo[ vv ].inuse = true
          has_ammo = true
        end
      end
      if not has_ammo then
        local sect = vac[ 1 ]
        local data = m_net_utils.get_weapon_data( w.obj )
        log2(
          "dsh: [%s]: %s has no ammo for %s: %s",
           script_name(), npc:name(),  w.obj:section_name(), data.ammo_elapsed
        )
        local need_boxes = data.ammo_elapsed > 0 and 1 or 2
        for i = 1, need_boxes do
          local sobj = alife():create(
            sect,
            npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
            npc.id
          )
          table.insert(
            items[ npc.id ],
            {
              id    = sobj.id,
              lname = object_level_name( npc ),
              name  = sobj:name(),
            }
          )
          ammo[ sect ] = {
            [ "inuse" ] = true,
            [ "objs"  ] = { sobj },
          }
        end
      end
    end
  end
  for sect, v in pairs( ammo ) do
    if table.getn( v.objs ) > 2 then
      table.sort(
        v.objs,
        function( a, b )
          return get_ammo_size( a ) > get_ammo_size( b )
        end
      )
      while table.getn( v.objs ) > 2 do
        table.insert( sell_list, table.remove( v.objs ) )
      end
    end
    if table.getn( v.objs ) > 0 then
      if v.inuse then
        local box_size = get_u32( sect, "box_size" )
        for _, sobj in ipairs( v.objs ) do
          local data = m_net_utils.get_ammo_data( sobj )
          if data.ammo_left < box_size then
            data.ammo_left = box_size
            m_net_utils.set_ammo_data( data, sobj )
          end
        end
      end
    end
  end
end


function get_ammo_size( sobj )
  local data = m_net_utils.get_ammo_data( sobj )
  return data.ammo_left
end


function is_broken_wpn( w )
  return w.cond < rx_wmgr.wm_modes.min_cond
end


function process_weapon_repair( our_weapons )
  for _, w in ipairs( our_weapons ) do
    if w.cond < 1 and not is_broken_wpn( w ) then
      local data = m_net_utils.get_weapon_data( w.obj )
      if data.condition < 0.9 then
        data.condition = data.condition + 0.1
      else
        data.condition = 1
      end
      m_net_utils.set_weapon_data( data, w.obj )
      w.cond = data.condition
    end
  end
end
function process_weapon_repair_allowed() end


function sobj_is_far( obj, distance )
  local result = true
  -- на одном ли уровне?
  if object_level_name( obj ) == level.name() then
    -- Достаточно ли далеко?
    if obj.position:distance_to( db.actor:position() ) < distance then
      result = false
    end
  end
  return result
end


function box_is_protected( v )
  -- проверяем по ID объекта
  if protected.ids[ v.id ] then return true end
  -- проверяем по имени объекта
  for _, o in ipairs( protected.names ) do
    if o == v:name() then
      return true
    end
  end
  -- проверяем по story ID объекта
  for _, o in ipairs( protected.story_ids ) do
    if o == v.m_story_id then
      return true
    end
  end
  -- проверяем по секции объекта
  for _, o in ipairs( protected.sections ) do
    if o == v:section_name() then
      return true
    end
  end
  return false
end


function is_valuable( item )
  local result = false
  local cost   = get_item_cost( item )
  if IAmAWeapon[ item:clsid() ] and cost >= 1000 then
    result = true
  elseif cost >= 800 then
    result = true
  end
  return result
end


function can_be_spawned( sobj )
  if sobj.spawner then
    return xr_logic.pick_section_from_condlist(
      db.actor, sobj, sobj.spawner
    ) ~= nil
  end
  return true
end
