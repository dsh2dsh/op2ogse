-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

off_npcs={}
items={}
relation_matrix={}
tables_ready = false
sell_table = {}
local item_dependence = {}
always_keep_item = {}

local wpn_fp = {}
-- Как часто делать апдейты, реальные минуты
local iFreq       = 0 --12
local initialized = false

local monster_params = {}

local maps={
  "l01_escape",
  "l02_garbage",
  "l03_agroprom",
--      "l03u_agr_underground",
  "l04_darkvalley",
--      "l04u_labx18",
  "l05_bar",
  "l06_rostok",
  "l07_military",
  "l08_yantar"--,
  --"l08u_brainlab",
  --"l10_radar",
  --"l10u_bunker",
  --"l11_pripyat",
  --"l12_stancia",
  --"l12_stancia_2",
  --"l12u_control_monolith",
  --"l12u_sarcofag"
}

protected = {
  names = {},             -- имена объектов (стоит добавлять только уникальные имена!)
  ids = {},               -- ID объектов
  story_ids = {   -- story ID объектов
    5008,
    5013,
    5014,
    5041,
    5065,
    5084,
    5104,
    5205,
    5222,
    5226,
    5237,
    5238,
    5243,
    5244,
    5245,
    5246,
    5247,
    5248,
    5249,
    5250,
    5254,
    5255,
    5408,
    5413,
    5428,
    5433,
    5434,
    5444,
    5446,
    5470,
    5471,
    5472,
    5473,
    5474,
    573,
  },
  sections = {    -- секции объектов
    "volna_shron",
    "taynik_kuznec7",
    "dyak_mines_box",
    "radiodetail_box2",
    "radiodetail_box4",
    "keis_key_box",
    "computer_flash",
    "notebook_flash",
    "disk_flash",
    "pda_flash",
    "taynik_podarok"
  }
}

local smart_filters = {
  "esc_bridge", "esc_blokpost"
}


local rel_enemy, rel_friend

-- радиус "обзора"
local look_radius        = 50
-- интенсивность поиска (количество отрабатываемых неписей)
local search_intensivity = 60
-- Вещи дешевле продает торговцам
local sell_limit         = 3000
local rate_art_found     = 100
local to_actor           = 150
local look_radius_box    = 20

local stalkers_comm = {
  [ "bandit"  ] = true,
  [ "dolg"    ] = true,
  [ "ecolog"  ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
}


function init()
  if initialized == false then
    build_tables()
    initialized = true
  end
end


function schedule_update()
  if iFreq == 0 then return end
  dsh.timeout( iFreq * 60 * 1000, function()
    off_npcs = {}
    items    = {}
    offline_update_timer():start( true )
  end )
end


class "offline_update_timer" ( ogse_qt.quick_timer )
function offline_update_timer:__init() super()
  self.cur_id = 1
end

function offline_update_timer:condition()
  return self.cur_id == 65535
end

function offline_update_timer:action()
  schedule_update()
end

function offline_update_timer:update()
  local sobj = alife():object( self.cur_id )
  if sobj then
    add_fresh_meat( sobj )
  end
  self.cur_id = self.cur_id + 1
end


function add_fresh_meat( obj )
  if
    obj and obj.m_game_vertex_id
    and game_graph():valid_vertex_id( obj.m_game_vertex_id )
    and db.actor and (
      db.actor:id() ~= obj.id
      and obj.parent_id ~= db.actor:id()
    )
    and ( not always_keep_item[ obj:section_name() ] )
    and ( not protected_items.actor_items_keep( obj:section_name() ) )
    and ( not protected_items.is_no_offline_alife_npc( obj:section_name() ) )
    and ( not get_bool( obj:section_name(), "quest_item", false ) )
    and ( not get_bool( obj:section_name(), "watcher_act.bad_item", false ) )
  then
    local map = object_level_name( obj )
    if not off_npcs[ map ] then
      off_npcs[ map ] = {
        artefacts = {},
        inv_boxes = {},
        monsters  = {},
        stalkers  = {},
        weapons   = {},
      }
    end
    if
      IsStalker( obj ) and obj.alive and obj:alive()
      and obj.health and obj:health() > 0 and obj.m_story_id == 4294967296
      and obj:community() ~= "zombied"
      and not xr_companion.is_companion( obj.id )
    then
      table.insert(
        off_npcs[ map ].stalkers, { id = obj.id, name = obj:name() }
      )
    elseif dsh.is_artefact( obj:section_name() ) and obj.parent_id == 65535 then
      table.insert(
        off_npcs[ map ].artefacts, { id = obj.id, name = obj:name() }
      )
    elseif
      (
        obj:clsid() == clsid.inventory_box
        and not box_is_protected( obj )
      )
      or (
        obj:section_name() == "dsh_treasure_item"
        and not protected.ids[ obj.id ]
      )
    then
      table.insert(
        off_npcs[ map ].inv_boxes, { id = obj.id, name = obj:name() }
      )
    elseif
      obj.parent_id ~= 65535 and obj.m_story_id == 4294967296
      and sell_table[ obj:section_name() ]
      and not ( IsMonster( obj ) or IsStalker( obj ) )
    then
      local zz = alife():object( obj.parent_id )
      if zz then
        if not protected.ids[ obj.parent_id ] then
          if not items[ obj.parent_id ] then items[ obj.parent_id ] = {} end
          table.insert(
            items[ obj.parent_id ],
            {
              id    = obj.id,
              lname = map,
              name  = obj:name(),
            }
          )
        end
        -- Idler++-- корректируем хабар в помеченных тайниках
        gps_habar.insert_item( obj.parent_id, obj )
      end
    end
  end
end


--строим таблицу неписей, монстров и оружия
function build_tables()
  -- Почистим таблицу
  rel_enemy, rel_friend = utils.cfg_get_number(
    system_ini(), "game_relations", "goodwill_enemy",  nil, false, -1000
  ),
  utils.cfg_get_number(
    system_ini(), "game_relations", "goodwill_friend", nil, false,  1000
  )
  local s_comm_list = utils.cfg_get_string(
    system_ini(), "game_relations", "communities", nil, false, "", ""
  )
  local comm_list = {}
  local s_value = amk.str_explode( ",", string.trim(s_comm_list), true )
  for a = 1, table.getn( s_value ), 2 do
    local s_comm = s_value[ a ]
    table.insert( comm_list, s_comm )
  end

  local tmp = {}
  local result, id, value = nil, nil, nil
  for a = 0, system_ini():line_count( "communities_relations" ) - 1 do
    result, id, value = system_ini():r_line(
      "communities_relations", a, "", ""
    )
    if id ~= nil and string.trim( id ) ~= "" and string.trim( id ) ~= nil then
      relation_matrix[ string.trim( id ) ] = {}
      table.insert( tmp, string.trim( id ) )
    end
  end

  for a = 1, table.getn( tmp ) do
    local value = utils.cfg_get_string(
      system_ini(), "communities_relations", tmp[ a ], nil, false, "", ""
    )
    local idx = tmp[ a ]
    local m_value = amk.str_explode( ",", string.trim( value ), true )
    for i = 1, table.getn( m_value ) do
      local idx2 = comm_list[ i ]
      local v = m_value[ i ]
      if relation_matrix[ idx ] and idx2 ~= nil and v ~= nil then
        relation_matrix[ idx ][ idx2 ] = tonumber( string.trim( v ) )
      end
    end
  end

  sell_table = {}
  local sini = dsh.cached_ini_file( "misc\\trade_generic.ltx" )
  local cfg_sell = utils.cfg_get_string(
    sini, "trader", "sell_condition", npc, false, false, ""
  )
  if sini and sini:section_exist( cfg_sell ) then
    local result, id, value = nil, nil, nil
    for a = 0, sini:line_count( cfg_sell ) - 1 do
      result, id, value = sini:r_line( cfg_sell, a, "", "" )
      if
        id ~= nil and string.trim( id ) ~= "" and string.trim( id ) ~= nil
        and
        string.trim( value ) ~= "" and string.trim( value ) ~= nil
      then
        -- Добавим в таблицу, что можно продавать.
        sell_table[ id ] = true
      end
    end
  end

  --' Заполняем таблицу зависимостей
  item_dependence = {}
  local n = sys_ini:line_count( "death_generic.item_dependence" )
  local id, value = "", ""
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "death_generic.item_dependence", i, "", "" )
    item_dependence[ id ] = {}
    local vvv = parse_names( value )
    for k,v in pairs( vvv ) do
      item_dependence[ id ][ v ] = true
    end
  end
  --' Предметы, которые нельзя продавать (квестовые например)
  always_keep_item = {}
  local n = sys_ini:line_count( "death_generic.keep_items" )
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "death_generic.keep_items", i, "", "" )
    if value == "true" then
      always_keep_item[ id ] = true
    end
  end

  tables_ready = true
end


function update_npc_tables()
  items    = {}
  off_npcs = {}
  for a = 1, 65534 do
    local sobj = alife():object( a )
    if sobj then
      add_fresh_meat( sobj )
    end
  end
  schedule_update()
end


local weapon_repair_allowed = false
function update_trade()
  if
    ogse_st_mgr.timer_exists(
      script_name() .. ".weapon_repair.forbidden"
    )
  then
    weapon_repair_allowed = false
  else
    weapon_repair_allowed = true
  end
  for a = 1, 65534 do
    local sobj = alife():object( a )
    if sobj then
      process_trade( sobj )
    end
  end
  if weapon_repair_allowed then
    dsh.start_gtimerDHMS(
      script_name() .. ".weapon_repair.forbidden",
      0, math.random( 20, 24 ), 0, 0,
      script_name() .. ".process_weapon_repair_allowed"
    )
    weapon_repair_allowed = false
  end
end


function update_tables( level )
  cleanup_this_level_items( level )
  local ggraph = game_graph()
  local sim    = alife()
  for a = 1, 65534 do
    local obj = sim:object( a )
    if obj then
      if
        ggraph:valid_vertex_id( obj.m_game_vertex_id )
        and object_level_name( obj ) == level
      then
        add_fresh_meat( obj )
      elseif obj.parent_id then
        local p_obj = sim:object( obj.parent_id )
        if
          p_obj
          and ggraph:valid_vertex_id( p_obj.m_game_vertex_id )
          and object_level_name( p_obj ) == level
        then
          add_fresh_meat( obj )
        end
      end
    end
  end
end


function cleanup_this_level_items( lname )
  off_npcs[ lname ] = {
    monsters = {}, stalkers = {}, weapons = {}, artefacts = {}, inv_boxes = {}
  }
  local remove = {}
  for k, v in pairs( items ) do
    if table.getn( v ) > 0 then
      if v[ 1 ].lname == lname then
        remove[ k ] = true
      end
    else
      remove[ k ] = true
    end
  end
  for k, v in pairs( remove ) do
    items[ k ] = nil
  end
end


--генерируем оффлайн события
function offline_alife()
  local lname = maps[ math.random( table.getn( maps ) ) ]
  local st    = 0
  amk.oau_reason = "cn offline_alife chp1"
  if off_npcs[ lname ] then st = table.getn( off_npcs[ lname ].stalkers ) end
  if st > 0 then
    amk.oau_reason = "cn offline_alife chp2"
    for search = 1, search_intensivity do
      amk.oau_reason = "cn offline_alife chp3"
      local rnd = math.random( st )
      amk.oau_reason = "cn offline_alife chp4"
      if off_npcs[ lname ].stalkers[ rnd ] then
        amk.oau_reason = "cn offline_alife chp5"
        local victim = alife():object( off_npcs[ lname ].stalkers[ rnd ].id )
        amk.oau_reason = "cn offline_alife chp6"
        if
          victim
          and IsStalker( victim )
          and object_level_name( victim ) == lname
          and ( not victim.online ) and victim.health
          and victim.can_switch_online and victim:health() > 0
          and victim:can_switch_online()
          and victim:name() == off_npcs[ lname ].stalkers[ rnd ].name
        then
          amk.oau_reason = "cn offline_alife chp7 "
            .. tostring( victim and victim:name() )
          local vdata = collect_info( victim, lname )
          amk.oau_reason = "cn offline_alife chp8 "
            .. tostring( victim and victim:name() )
          if table.getn( vdata.artefacts ) > 0 then
            -- есть арты
            amk.oau_reason = "cn offline_alife chp14 "
              .. tostring( victim and victim:name() )
            on_artifacts_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif
            table.getn( vdata.inv_boxes ) > 0 and victim:community() ~= "zombied"
          then
            -- есть контейнеры. Надо обыскать.
            amk.oau_reason = "cn offline_alife chp18 "
              .. tostring( victim and victim:name() )
            on_inv_boxes_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif
            items[ victim.id ] and table.getn( items[ victim.id ] ) > 0
            and victim:community() ~= "zombied"
          then
            --попробуем продать всякого
            amk.oau_reason = "cn offline_alife chp17 "
              .. tostring( victim and victim:name() )
            process_trade( victim )
            break
          end
        end
      end
    end
  end
  amk.oau_reason = "cn offline_alife end"
end


--собираем инфу о неписе
function collect_info( victim, map )
  local vdata = {}
  vdata.rank      = victim:rank()
  vdata.health    = victim:health()
  vdata.community = victim:community()
  local sim = alife()

  --составляем список артов в зоне "видимости"
  vdata.artefacts = {}
  if
    off_npcs[ map ].artefacts and table.getn( off_npcs[ map ].artefacts ) > 0
  then
    for a = 1, table.getn( off_npcs[ map ].artefacts ) do
      local artefact = sim:object( off_npcs[ map ].artefacts[ a ].id )
      if
        artefact and object_level_name( artefact ) == map
        and artefact.can_switch_online and artefact:can_switch_online()
        and artefact:name() == off_npcs[ map ].artefacts[ a ].name
        and artefact.parent_id == 65535
        and victim.position:distance_to( artefact.position ) < look_radius
        and sobj_is_far( artefact, to_actor )
      then
        local zdist = victim.position:distance_to( artefact.position ) / look_radius
        if math.random() > zdist then
          table.insert(
            vdata.artefacts, { id = artefact.id, name = artefact:name() }
          )
        end
      end
    end
  end

  --составляем список контейнеров в зоне "видимости"
  vdata.inv_boxes = {}
  if
    off_npcs[ map ].inv_boxes and table.getn( off_npcs[ map ].inv_boxes ) > 0
  then
    for a = 1, table.getn( off_npcs[ map ].inv_boxes ) do
      local inv_box = sim:object( off_npcs[ map ].inv_boxes[ a ].id )
      if
        inv_box
        and inv_box.can_switch_online and inv_box:can_switch_online()
        and inv_box:name() == off_npcs[ map ].inv_boxes[ a ].name
        and victim.position:distance_to( inv_box.position ) < look_radius_box
        and sobj_is_far( inv_box, to_actor )
        and not treasure_manager.is_active( inv_box )
      then
        local zdist = victim.position:distance_to( inv_box.position ) / look_radius_box
        if math.random() > zdist then
          if inv_box.parent_id == nil or inv_box.parent_id == 65535 then
            table.insert(
              vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() }
            )
          end
        end
      end
    end
  end

  return vdata
end


-- Моя прелесссть
function on_artifacts_found( victim, vdata )
  local trade = false
  for i = 1, table.getn( vdata.artefacts ) do
    local v_obj  = vdata.artefacts[ i ]
    local object = alife():object( v_obj.id )
    if object then
      local obj = pick_item( victim, object )
      if obj and victim:community() ~= "zombied" then
        victim:set_rank( victim:rank() + rate_art_found )
        trade = true
      end
    end
  end
  if trade then process_trade( victim ) end
end


-- О, нычка - это гуд.  Idler ++ проверим, а сможет ли непись долезть
-- до тайника.  если есть аномалии в радиусе 20м, меньше шансов или
-- если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail( victim, box )
  -- отсекаем сюжетные тайники
  if
    transparent_treasure.IsTaken( box:section_name() )
    and box:section_name() ~= "m_inventory_box"
  then
    return false
  end
  local n_rnd = math.random( 2, 5 )
  if math.abs( box.position.y - victim.position.y ) > n_rnd then
    return false
  end
  if object_level_name( box ) == level.name() then
    local anom_list = amk_anoms.get_anomaly_list_for_pos( box.position, 20 )
    local n_anoms   = table.getn( anom_list )
    local n_rnd     = math.random( 100 )
    -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При
    -- 5 - точно до ящика не доберется
    if n_rnd < n_anoms * 20 then return false end
  end
  return true
end


function on_inv_boxes_found( victim, vdata )
  local trade = false
  for i = 1, table.getn( vdata.inv_boxes ) do
    local v_obj  = vdata.inv_boxes[ i ]
    local object = alife():object( v_obj.id )
    if object then
      -- Idler ++-- если нычка доступна - можно шмонать
      if inv_box_is_avail( victim, object ) then
        if object:section_name() == "dsh_treasure_item" then
          dsh_rukzak.on_inv_box_found( object.id, victim )
          trade = true
        elseif items[ v_obj.id ] and table.getn( items[ v_obj.id ] ) > 0 then
          for a = 1, table.getn( items[ v_obj.id ] ) do
            local v_itA = items[ v_obj.id ][ a ]
            local itA   = alife():object( v_itA.id )
            if
              itA
              and itA.parent_id == v_obj.id
              and itA:name() == v_itA.name
            then
              -- Решим, подбираем или нет?
              if is_valuable( itA ) then
                pick_item( victim, itA )
                trade = true
              end
            end
          end
        end
        if victim:community() ~= "zombied" then
          victim:set_rank( victim:rank() + rate_art_found )
        end
      end
    end
  end
  if trade then process_trade( victim ) end
end


function pick_item( npc, obj )
  local section = obj:section_name()
  local new     = alife():create(
    section,
    npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id,
    npc.id
  )
  if new then
    if new.parent_id then
      if not items[ new.parent_id ] then items[ new.parent_id ] = {} end
      table.insert(
        items[ obj.parent_id ],
        {
          id    = new.id,
          lname = object_level_name( new ),
          name  = new:name(),
        }
      )
      -- Idler++-- корректируем хабар в помеченных тайниках
      gps_habar.insert_item( new.parent_id, new )
    end
    if
      obj.parent_id
      and items[ obj.parent_id ] and table.getn( items[ obj.parent_id ] ) > 0
    then
      for z = 1, table.getn( items[ obj.parent_id ] ) do
        if items[ obj.parent_id ][ z ].id == obj.id then
          -- Idler++-- корректируем хабар в помеченных тайниках
          gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] )
          table.remove( items[ obj.parent_id ], z )
          break
        end
      end
    end
    alife():release( alife():object( obj.id ), true )
  end
  return new
end


function get_item_cost(item)
  local result = 0
  if item and item.section_name then
    result = get_float(item:section_name(), "cost", 0 )
    local params = m_net_utils.get_item_data( item )
    if params.condition > 0 then
      result = result * params.condition
    else
      result = 1
    end
  end
  return result
end


--[=[
Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.
Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class + item_dependence
Оставили одно, которое лучше (а), но патронов нет (б) (%)
Одно, которое лучше (а), но хуже (б) - в новости на продажу
Остальное на продажу
Патроны оставили только те, что подходят к (а), остальные на продажу
Для вояк - только родной калаш надо бы... Не продавать вобще?
Оставляем не более 2 аптечек и бинтов, антирада
Оставляем 1-2 гранаты (%)
Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
Еда, водка - не более 1-2 шт (%)
Броники наверное продаем...
Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
--]=]
function process_trade( npc )
  local item_list = {}
  local sell_list = {}
  local tb_ilist_size = table.getn( item_list )
  -- Имеет смысл проверять на наличие trade в секции [logic]...
  if
    npc and IsStalker( npc ) and npc:alive()
    and npc.m_story_id ~= nil and npc.m_story_id == 4294967296
    and ( not xr_companion.is_companion( npc.id ) )
    and items[ npc.id ] and table.getn( items[ npc.id ] ) > 0
    and ( not protected_items.is_no_offline_alife_npc( npc:section_name() ) )
  then
    local b_stalker = false
    local m_comm    = npc:community()
    if stalkers_comm[ m_comm ] then
      if npc.name and npc:name() ~= "agr_ratcatcher" then
        b_stalker = true
      end
    elseif m_comm == "zombied" then
      return
    end

    --Фильтруем квестовые items - always_keep_item, sell_table
    for _, ov in ipairs( items[ npc.id ] ) do
      local obj = alife():object( ov.id )
      if obj and obj.parent_id == npc.id and obj:name() == ov.name then
        if
          not (
            always_keep_item[ obj:section_name() ]
            or protected_items.actor_items_keep( obj:section_name() )
          )
        then
          table.insert( item_list, obj )
        end
      end
    end

    if item_list and table.getn( item_list ) > 0 then
      table.sort(
        item_list,
        function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
      )
      -- Выберем, что за оружие оставит себе NPC.
      local cnt_medkit    = 0
      local cnt_antirad   = 0
      local cnt_bandage   = 0
      local cnt_grenade   = 0
      local cnt_food      = 0
      local cnt_drink     = 0
      local cnt_torch     = 0
      local cnt_pda       = 0
      local cnt_radio     = 0
      local cnt_guitar    = 0
      local cnt_harmonica = 0
      local cnt_binocular = 0
      local cnt_knife     = 0
      local cnt_arts      = 0
      local cnt_detector  = 0
      local cnt_addons    = 0
      local cnt_mparts    = 0
      local weapons       = {}
      local ammo          = {}
      for _, v in ipairs( item_list ) do
        local sect = v:section_name()
        if
          sect == "grenade_f1"
          or sect =="grenade_gd-05"
          or sect == "grenade_rgd5"
          or sect == "grenade_flash"
          or sect == "grenade_f1_double"
          or sect == "grenade_m61"
        then
          cnt_grenade = cnt_grenade + 1
          if cnt_grenade > 2 then
            table.insert( sell_list, v )
          end
        elseif
          string.find( sect, "^wpn_addon_scope" )
          or string.find( sect, "^wpn_addon_silencer" )
          or string.find( sect, "^wpn_addon_grenade_launcher" )
        then
          cnt_addons = cnt_addons + 1
          if cnt_addons > 2 then
            table.insert( sell_list, v )
          end
        elseif sect == "wpn_knife" then
          cnt_knife = cnt_knife + 1
          if cnt_knife > 1 then
            table.insert( sell_list, v )
          end
        elseif isWeapon( v ) then
          local ac = get_string( sect, "ammo_class" )
          if ac and ac ~= "" then
            table.insert( weapons, { obj = v, ammo = parse_names( ac ) } )
          else
            table.insert( weapons, { obj = v } )
          end
        elseif string.find( sect, "^ammo_" ) then
          if ammo[ sect ] then
            table.insert( ammo[ sect ].objs, v )
          else
            ammo[ sect ] = { objs = { v } }
          end
        elseif
          string.find( sect, "af_", 1, true )
          or string.find( sect, "mutant_af_", 1, true )
        then
          -- 3 самых хороших арта оставили себе (+здоровье), остальные
          -- на продажу ( фильтруем булыжник )
          if sect ~= "af_buliz" then
            cnt_arts = cnt_arts + 1
            if cnt_arts > 3 then
              table.insert( sell_list, v )
            end
          end
        elseif sect == "device_torch" then
          cnt_torch = cnt_torch + 1
          if cnt_torch > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_pda" then
          cnt_pda = cnt_pda + 1
          if cnt_pda > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "hand_radio" then
          cnt_radio = cnt_radio + 1
          if cnt_radio > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "harmonica_a" then
          cnt_harmonica = cnt_harmonica + 1
          if cnt_harmonica > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "guitar_a" then
          cnt_guitar = cnt_guitar + 1
          if cnt_guitar > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "binocular_a" or sect == "wpn_binoc" then
          cnt_binocular = cnt_binocular + 1
          if cnt_binocular > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "medkit"
          or sect == "medkit_army"
          or sect == "medkit_scientic"
        then
          cnt_medkit = cnt_medkit + 1
          if cnt_medkit > 4 then
            table.insert( sell_list, v )
          end
        elseif sect == "antirad" then
          cnt_antirad = cnt_antirad + 1
          if cnt_antirad > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "bandage" then
          cnt_bandage = cnt_bandage + 1
          if cnt_bandage > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "bread_a"
          or sect =="bread"
          or sect == "kolbasa"
          or sect == "kolbasa_a"
          or sect == "conserva"
        then
          cnt_food = cnt_food + 1
          if cnt_food > 4 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "vodka_a"
          or sect =="vodka"
          or sect == "energy_drink"
        then
          cnt_drink = cnt_drink + 1
          if cnt_drink > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "detector_simple"
          or sect =="detector_advances"
          or sect == "detector_elite"
        then
          cnt_detector = cnt_detector + 1
          if cnt_detector > 1 then
            table.insert( sell_list, v )
          end
        elseif string.find( sect, "^mutant_" ) then
          cnt_mparts = cnt_mparts + 1
          if cnt_mparts > 2 then
            table.insert( sell_list, v )
          end
        elseif string.find( sect, "outfit" ) or string.find( sect, "exo" ) then
          table.insert( sell_list, v )
        end
      end

      local modes = rx_wmgr.read_wm_modes(
        npc:community(), ranks.get_obj_rank_name( npc ), npc:section_name()
      )
      local weapons_types = {}
      for _, i in ipairs( modes.types ) do
        weapons_types[ i.t ] = {}
      end
      for _, w in ipairs( weapons ) do
        local sect   = w.obj:section_name()
        local params = rx_wmgr.read_wpn_params( sect )
        local t      = { obj = w.obj, ammo = w.ammo, prm = 0 }
        if modes.mode1 == "1" then
          t.prm = params.cst + modes.addcost
        elseif modes.mode1 == "2" then
          local kf = rx_wmgr.wm_modes.koeffs[ modes.koeffs ]
          t.prm = ( params.dmg * kf.dmg )
            + ( params.rpm * kf.rpm )
            + ( params.dst * kf.dst )
            + ( ( 100 / params.dsp ) * kf.dsp )
        elseif modes.mode1 == "3" then
          t.prm = rx_wmgr.wm_modes.priors[ modes.priors ][ sect ] or 0
        end
        local pk = xs_netpk.weapon( t.obj )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s",
          script_name(), t.obj:name()
        )
        local data = pk:get()
        t.cond   = data.condition
        t.has_gl = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.gl
        ) ~= 0
        t.has_scope = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.scope
        ) ~= 0
        t.has_silencer = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.silencer
        ) ~= 0
        local pr = 0
        if t.has_gl then
          pr = pr + t.prm * modes.grenadelauncher / 100
        end
        if t.has_scope then
          pr = pr + t.prm * modes.scope / 100
        end
        if t.has_silencer then
          pr = pr + t.prm * modes.silencer / 100
        end
        for _, v in ipairs( modes.types ) do
          if v.t == params.typ then
            pr = pr + t.prm * v.p / 100
            break
          end
        end
        t.prm = t.prm + pr + w.obj.id / 100000 + t.cond * t.prm / 50
        if weapons_types[ params.typ ] then
          table.insert( weapons_types[ params.typ ], t )
        else
          weapons_types[ params.typ ] = { t }
        end
      end

      local our_weapons = {}
      for k, v in pairs( weapons_types ) do
        table.sort(
          v, function( a, b ) return a.prm > b.prm end
        )
        -- Так, теперь у нас отсортированны все пушки НПС. Найдем ту,
        -- для которой есть патроны...
        local b_self = false
        local b_best = false
        local s_self = ""
        for _, w in ipairs( v ) do
          local b_ammo = false
          local vac    = w.ammo
          if vac and table.getn( vac ) > 0 then
            for kk, vv in ipairs( vac ) do
              if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
                -- Так, патроны есть.
                b_ammo = true
                break
              end
            end
          end
          if is_broken_wpn( w ) then
            table.insert( sell_list, w.obj )
          elseif b_self == false and b_ammo == true then
            b_self = true
            s_self = w.obj:section_name()
            table.insert( our_weapons, w )
          elseif b_best == false then
            if s_self ~= "" then
              if w.obj:section_name() ~= s_self then
                b_best = true
                table.insert( our_weapons, w )
              else
                table.insert( sell_list, w.obj )
              end
            else
              b_best = true
              table.insert( our_weapons, w )
            end
          else
            table.insert( sell_list, w.obj )
          end
        end
      end
      process_ammo_trade( sell_list, ammo, npc, our_weapons )
      if weapon_repair_allowed then
        process_weapon_repair( our_weapons )
      end

      -- Так, с оружием закончили...
      -- Все, что осталось - надо продать.
      -- 1 самое дорогое можно попробовать через новости...
      -- ... ну и когда-нибудь, как фишка ляжет, наконец от него избавиться.
      local money = 0
      if sell_list and table.getn( sell_list ) > 0 and math.random() > 0.1 then
        table.sort(
          sell_list,
          function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
        )
        local zz = sell_list[ 1 ]
        if zz and b_stalker and get_item_cost( zz ) >= sell_limit then
          -- Продадим через новости.
          news_main.on_offline_trade( npc, zz )
          table.remove( sell_list, 1 )
        end
      end
      for _, vv in ipairs( sell_list ) do
        local cost = get_item_cost( vv )
        if cost > 0 then
          local coeff = math.random( 30, 50 ) / 100
          local price = math.floor( cost * coeff )
          money = money + price
          -- Почистим items
          if items[ npc.id ] and table.getn( items[ npc.id ] ) > 0 then
            for z, item in ipairs( items[ npc.id ] ) do
              if item.id == vv.id then
                table.remove( items[ npc.id ], z )
                -- Idler++-- корректируем хабар в помеченных тайниках
                gps_habar.remove_item( npc.id, item )
                break
              end
            end
          end
          alife():release( alife():object( vv.id ), true )
        end
      end
      if money > 0 then
        local pk = xs_netpk.stalker( sobj )
        if pk:isOk() then
          local data = pk:get()
          if data.money then money = money + data.money end
          data.money = money
          pk:set( data )
        end
      end
    end
  end
end


function process_ammo_trade( sell_list, ammo, npc, our_weapons )
  for _, w in ipairs( our_weapons ) do
    local vac = w.ammo
    if vac and table.getn( vac ) > 0 then
      for _, vv in ipairs( vac ) do
        if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
          ammo[ vv ].inuse = true
        end
      end
    end
  end
  for sect, v in pairs( ammo ) do
    if table.getn( v.objs ) > 2 then
      table.sort(
        v.objs,
        function( a, b )
          return get_ammo_size( a ) > get_ammo_size( b )
        end
      )
      while table.getn( v.objs ) > 2 do
        table.insert( sell_list, table.remove( v.objs ) )
      end
    end
    if table.getn( v.objs ) > 0 then
      if v.inuse then
        local box_size = get_u32( sect, "box_size" )
        for _, sobj in ipairs( v.objs ) do
          local data = m_net_utils.get_ammo_data( sobj )
          if data.ammo_left < box_size then
            data.ammo_left = box_size
            m_net_utils.set_ammo_data( data, sobj )
          end
        end
      end
    end
  end
end


function get_ammo_size( sobj )
  local data = m_net_utils.get_ammo_data( sobj )
  return data.ammo_left
end


function is_broken_wpn( w )
  return w.cond < rx_wmgr.wm_modes.min_cond
end


function process_weapon_repair( our_weapons )
  for _, w in ipairs( our_weapons ) do
    if w.cond < 1 and not is_broken_wpn( w ) then
      local data = m_net_utils.get_weapon_data( w.obj )
      if data.condition < 0.9 then
        data.condition = data.condition + 0.1
      else
        data.condition = 1
      end
      m_net_utils.set_weapon_data( data, w.obj )
      w.cond = data.condition
    end
  end
end
function process_weapon_repair_allowed() end


function sobj_is_far( obj, distance )
  local result = true
  -- на одном ли уровне?
  if object_level_name( obj ) == level.name() then
    -- Достаточно ли далеко?
    if obj.position:distance_to( db.actor:position() ) < distance then
      result = false
    end
  end
  return result
end


function box_is_protected( v )
  -- проверяем по ID объекта
  if protected.ids[ v.id ] then return true end
  -- проверяем по имени объекта
  for _, o in ipairs( protected.names ) do
    if o == v:name() then
      return true
    end
  end
  -- проверяем по story ID объекта
  for _, o in ipairs( protected.story_ids ) do
    if o == v.m_story_id then
      return true
    end
  end
  -- проверяем по секции объекта
  for _, o in ipairs( protected.sections ) do
    if o == v:section_name() then
      return true
    end
  end
  return false
end


function is_valuable( item )
  local result = false
  local cost   = get_item_cost( item )
  if IAmAWeapon[ item:clsid() ] and cost >= 1000 then
    result = true
  elseif cost >= 800 then
    result = true
  end
  return result
end
