--[[------------------------------------------------------------------------------------------------------------------
автор: Диденко Руслан (Stohe)

порядок вызова методов биндера:
reload
reinit
load
net_spawn
--------------------------------------------------------------------------------------------------------------------]]

memtsg = {} --' временная таблица
lasthealth = 0
lastime = nil

local debug_flag = false
local count = 0

local warn_check_timer = {}
local snd_check_timer = {}
local armor_check = {}

local check_npc_on_fire_line = true

local pri_checked = 0

local pri_f_count = 0
local pri_d_count = 0
local pri_m_count = 0

local particles={}

local watchdog = {}
local watchdog_max = 8

----------------------------------------------------------------------------------------------------------------------
function protected_loot(object, backup)
	death_manager.drop_manager(object, backup):create_release_item()
end

function look_to_shot(object, who)
	if object and who then
		if IsStalker(object) and 
		(object:alive() and who:alive()) and
		not xr_wounded.is_wounded(object) and
		((IsStalker(who) and object:relation(who) ~= game_object.friend) or IsMonster(who)) then
			if object:best_enemy() then
				local be = object:best_enemy()
				local enemy_dist = object:position():distance_to_sqr(be:position())
				local who_dist = object:position():distance_to_sqr(who:position())
				if who_dist < enemy_dist then
					object:set_sight(look.danger,who:bone_position("bip01_head"))
				end		
			else	
				object:set_sight(look.danger,who:bone_position("bip01_head"))
			end
		end
	end
end

function recognize_sound(sound_type)
	-- Выясняем тип звука
	local sn_t = "NIL"
	
	if bit_and(sound_type, snd_type.weapon) == snd_type.weapon then
		sn_t = "WPN"
		if bit_and(sound_type, snd_type.weapon_shoot) == snd_type.weapon_shoot then
			sn_t = "WPN_shoot"
		elseif bit_and(sound_type, snd_type.weapon_empty) == snd_type.weapon_empty then
			sn_t = "WPN_empty"
		elseif bit_and(sound_type, snd_type.weapon_bullet_hit) == snd_type.weapon_bullet_hit then
			sn_t = "WPN_hit"
		elseif bit_and(sound_type, snd_type.weapon_reload) == snd_type.weapon_reload then
			sn_t = "WPN_reload"
		end
	elseif bit_and(sound_type, snd_type.item) == snd_type.item then
		sn_t = "ITM"
		if bit_and(sound_type, snd_type.item_pick_up) == snd_type.item_pick_up then
			sn_t = "ITM_pckup"
		elseif bit_and(sound_type, snd_type.item_drop) == snd_type.item_drop then
			sn_t = "ITM_drop"
		elseif bit_and(sound_type, snd_type.item_hide) == snd_type.item_hide then
			sn_t = "ITM_hide"
		elseif bit_and(sound_type, snd_type.item_take) == snd_type.item_take then
			sn_t = "ITM_take"
		elseif bit_and(sound_type, snd_type.item_use) == snd_type.item_use then
			sn_t = "ITM_use"
		end
	elseif bit_and(sound_type, snd_type.monster) == snd_type.monster then
		sn_t = "MST"
		if bit_and(sound_type, snd_type.monster_die) == snd_type.monster_die then
			sn_t = "MST_die"
		elseif bit_and(sound_type, snd_type.monster_injure) == snd_type.monster_injure then
			sn_t = "MST_damage"
		elseif bit_and(sound_type, snd_type.monster_step) == snd_type.monster_step then
			sn_t = "MST_step"
		elseif bit_and(sound_type, snd_type.monster_talk) == snd_type.monster_talk then
			sn_t = "MST_talk"
		elseif bit_and(sound_type, snd_type.monster_attack) == snd_type.monster_attack then
			sn_t = "MST_attack"
		elseif bit_and(sound_type, snd_type.monster_eat) == snd_type.monster_eat then
			sn_t = "MST_eat"
		end
	elseif sound_type == snd_type.attack then
		sn_t = "ATTCK"
	elseif sound_type == snd_type.bullet_hit then
		sn_t = "BULLET"
	elseif sound_type == snd_type.die then
		sn_t = "DIE"
	elseif sound_type == snd_type.injure then
		sn_t = "INJURE"
	end
	
	return sn_t
end

local hear_something = {

[1] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_1]],
[2] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_2]],
[3] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_3]],
[4] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_4]],
[5] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_5]],
[6] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_6]],
[7] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_7]],
[8] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_8]],
[9] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_9]]

}

local nothing_there = {

[1] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_1]],
[2] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_2]],
[3] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_3]],
[4] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_4]],
[5] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_5]],
[6] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_6]],
[7] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_7]]

}


function silent_level()
	if 	level.name() == "l06_rostok" or
		level.name() == "l08u_brainlab" or
		level.name() == "l10u_bunker" or
		level.name() == "l12_stancia" or 
		level.name() == "l12u_sarcofag" or
		level.name() == "l12u_control_monolith" or
		level.name() == "l12_stancia_2" then
		return true 
	else 
		return false
	end
end

local warn_check_timer = {}

function check_sound(self, who, sound_type, sound_position, sound_power)
	-- secure and optimize
	
	if not self or
		not who or
		not sound_type or
		not sound_position or
		not sound_power 
	then
		return 
	end
	
	local actsch = nil
	
	if db.storage[self:id()] and db.storage[self:id()].active_scheme then
		actsch = db.storage[self:id()].active_scheme
	end
	
	if actsch and (actsch == "remark" or actsch == "wounded" or actsch == "actor_dialogs")
	then 
		return 
	end

	-- Реакция на звуки --
	-- Расстояния проверки
	local who_dist = 1000
	local check_dist = 25*sound_power
	local who_dist = self:position():distance_to(who:position())
	
	if who_dist > 100 then
		return
	end
	
	-- Отсеиваем свои звуки и звуки друзей
	if (who:is_monster() or who:is_stalker() or who:id() == db.actor:id()) 
	and (who:alive() and self:alive()) then
		if who:id() == self:id() 
		or (who:is_car() and self:relation(db.actor) ~= game_object.enemy)
		or xr_wounded.is_wounded(self) then
			return
		end
	else	
		return
	end
	
	local snd_t = recognize_sound(sound_type)
	
	local blow = hit()
	blow.power = 0.001
	blow.impulse = 1
	blow.draftsman = who
	blow.type = hit.wound
	blow.direction = utils.vector_copy_by_val(self:position()):sub(who:position())
	
	-- Если тип задан проверим реакцию на него
	if snd_t and snd_t ~= "NIL" and not self:best_enemy() then
		if IsStalker(who) and (self:relation(who) == game_object.enemy) then
			if snd_t == "WPN_empty" or
			snd_t == "WPN_reload" or 
			snd_t == "ITM_drop" or
			snd_t == "ITM_use" then		
				check_dist = 8*sound_power
				who_dist = self:position():distance_to(who:position())
				if who_dist > check_dist then
					if not silent_level() then
						if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
							local snd_name = nothing_there[math.random(1,7)]
							if snd_name and self:character_community() ~= "zombied" then
								local snd_obj = xr_sound.get_safe_sound_object(snd_name)
								if snd_obj and not snd_obj:playing() then
									self:set_sight(look.point,sound_position)
									snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
									warn_check_timer[self:id()] = time_global() + math.random(15000, 25000) 
								end
							end
						end
					end				
					return
				else
					if not silent_level() then
						if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
							local snd_name = hear_something[math.random(1,9)]
							if snd_name and self:character_community() ~= "zombied" then
								local snd_obj = xr_sound.get_safe_sound_object(snd_name)
								if snd_obj and not snd_obj:playing() then
									self:set_sight(look.point,sound_position)
									snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
									warn_check_timer[self:id()] = time_global() + math.random(5000, 10000) 
								end
							end
						end
					end
					self:set_sight(look.point,sound_position)
					self:set_mental_state(anim.danger)
					self:make_object_visible_somewhen(who)
				end
			elseif snd_t == "WPN_shoot" then
				-- self:hit(blow) -- попробуем без хита прямого, поглядим что будет
				stop_play_sound(self)
				self:set_mental_state(anim.danger)
				self:set_sight(look.point,sound_position)
				self:make_object_visible_somewhen(who)	
				if xr_companion.is_companion(self:id()) then
					xr_combat_companion.process_enemy(self, who)				
				end			
			end
		elseif IsStalker(who) and (self:relation(who) ~= game_object.enemy) then
			if snd_t == "ATTCK" or
			snd_t == "BULLET" or
			snd_t == "DIE" or
			snd_t == "INJURE" then
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)			
			end			
		elseif IsMonster(who) then
			if who_dist > check_dist then
				if not silent_level() then
					if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
						local snd_name = nothing_there[math.random(1,7)]
						if snd_name and self:character_community() ~= "zombied" then
							local snd_obj = xr_sound.get_safe_sound_object(snd_name)
							if snd_obj and not snd_obj:playing() then
								self:set_sight(look.point,sound_position)
								snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
								warn_check_timer[self:id()] = time_global() + math.random(15000, 25000) 
							end
						end
					end
				end				
				return
			end		
			if snd_t == "MST_step" or snd_t == "MST_talk" then
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)
				self:make_object_visible_somewhen(who)
			elseif snd_t == "MST_attack" then
				self:hit(blow)
				stop_play_sound(self)
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)
				self:make_object_visible_somewhen(who)
			end
		end
	end
end

function check_art_weapon(npc)
------------------------------
--' Изредка движок сглюкивает,
--' назначая неписю в слот артефакт
--' этого следует избежать,
--' так как такие неписи
--' застревают на попытке 
--' применения арта как оружия
------------------------------
	local item_in_slot = npc:item_in_slot(1)
	local act_item = npc:active_item()
	if act_item and item_in_slot and act_item:id() == item_in_slot:id() then
		local item_in_slot_sec = act_item:section()
		local item_in_slot_id = act_item:id()
		if item_in_slot_sec and item_in_slot_id and string.find(item_in_slot_sec, "af_") then
			--' Если непись получил арт в слот по ошибке при загрузке игры, мы просто
			--' обновим ему оружие в руках и всё. Иначе, если он взял арт в руки и отказывается
			--' его убирать, а лучшее оружие получить не удаётся, придётся арт выбросить, отрелизить и вернуть ему в рюкзак.
			-- log1("WARNING! Engine error - art in NPC weapon slot! "..tostring(item_in_slot_sec).." ID "..tostring(item_in_slot_id))
			-- local s_obj = alife():object(item_in_slot_id)
			local bw = npc:best_weapon()
			local be = npc:best_enemy()
			local rem_id = npc:active_item():id()
			npc:drop_item(npc:active_item())
			local s_obj = alife():object(rem_id)
			if s_obj then
				-- log1("ITEM RESET "..tostring(item_in_slot_sec))
				alife():release(s_obj, true)
				alife():create(item_in_slot_sec,npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id())
			end			
			if bw and string.find(bw:section(), "wpn_") then
				-- log1("TOSS WEAPON TO "..bw:section().." FROM "..tostring(rem_id))
				if be then
					npc:set_item(object.fire1, bw)
					return
				else
					npc:set_item(object.idle, bw)
					return
				end
			end
		end
	end
end

---------------------------------------------------------------------------------------------------------------------
class "motivator_binder" (object_binder)

function motivator_binder:__init (obj) super(obj)
	self.loaded = false
	self.last_update = 0
	----memusage.collect_info(self.object, "__init")

    self.first_update = false
	self.treasure_processed = false
	if (amkII_equip) then
		
		self.oDisguise = amkII_equip.CAmkDisguise()
	end	
	self.particles = {}
	self.am = ogse_signals.get_mgr()
end

function motivator_binder:extrapolate_callback(cur_pt)
    if self.object == nil then return false end
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "extrapolate_callback")
		self.st.move_mgr:extrapolate_callback(self.object)
	end

		if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
			return true
		end
	return false
end

function motivator_binder:reinit()

    if self.object == nil then return end
	
    object_binder.reinit(self)
    --memusage.collect_info(self.object, "reinit_start")
    --printf("motivator_binder:reinit(): self.object:name()='%s'", self.object:name())

    -- КОЛЛБЕКИ ЗДЕСЬ СТАВИТЬ НЕЛЬЗЯ! Здесь еще неизвестна активная схема.
    -- Ставьте коллбеки в методе update в отмеченном комментарием месте.

    local char_ini = self.object:spawn_ini() or ini_file("scripts\\dummy.ltx")

----------------------------------------------------------------------------------------------------------------------
-- Общие скрипты
----------------------------------------------------------------------------------------------------------------------
    db.storage[self.object:id()] = {  followers = {} }
    self.st = db.storage[self.object:id()]

    --' Создание менеджера контроля положений тела
    --memusage.collect_info(self.object, "before_statemgr")
	self.st.state_mgr = state_mgr.bind_manager(self.object)

	self.st.move_mgr = move_mgr.move_mgr(self.object)
	self.st.move_mgr:initialize()

	--memusage.collect_info(self.object, "after_statemgr")
	--memusage.collect_info(self.object, "reinit_end")
end
----------------------------------------------------------------------------------------------------------------------

local function del_zero_ammo(npc, item)
	if item == nil then return end
	local id = item:id()
	local sobj = alife():object(id) 
	if not sobj then return end	
	local section = sobj:section_name()	
	if string.find(section, "ammo") then
		local size = dunin_ammo.get_ammo_size(item)
		if size == 0 then
			local del = alife():object(item:id())
			if del then
				death_manager.shedule_release(item)
			end
		end
	end		
end	


function motivator_binder:net_spawn(sobject)
	printf("motivator_binder:net_spawn(): self.object:name()='%s'", self.object:name())
	--memusage.collect_info(self.object, "netspawn_start")
	
	ogse_debug.process_npc(self.object, "s_spw", 1)

	ogse.fix_restrictors(self.object)
	
	ogse_debug.process_npc(self.object, "s_spw", 100001)
	
	-- удалить в релизе нахер.
--[[	if (db.actor:has_info("esc_kvest_know_do_mils_near_anomaly_2_complete") or db.actor:has_info("esc_kvest_know_do_mils_near_anomaly_2_fail")) and string.find(self.object:name(), "esc_millitary_near_anomaly") then
		local s_npc = alife():object(self.object:id())
		alife():release(s_npc, true)
		ogse_debug.process_npc(self.object, "s_spw", 0)
		return
	end	
	
	-- удалить в релизе нахер.
	if string.find(self.object:name(), "hohol") and self.object:alive() then
		local s_npc = alife():object(self.object:id())
		local smrt_id = s_npc:smart_terrain_id()
		if smrt_id == 65535 then
			alife():release(s_npc, true)
			ogse_debug.process_npc(self.object, "s_spw", 0)
			log1("!!RESPAWNING HOHOL")
			local spawn_db = ogse_spawn_db.script_spawn_registry.jekan_quests
			ogse.spawn_object(spawn_db.hohol)
			return
		end
	end	
	
	-- удалить в релизе нахер.
	if db.actor:dont_has_info("DEBUG_gorbovsky_respawned") and string.find(self.object:name(), "gorbovsky") then
		local s_npc = alife():object(self.object:id())
		s_npc.force_offline = true
	end	
	
	-- удалить в релизе нахер.
	if db.actor:dont_has_info("DEBUG_bar_sinyak_respawned") and string.find(self.object:name(), "bar_sinyak") then
		local s_npc = alife():object(self.object:id())
		s_npc.force_offline = true
		--log1("sinyak forced offline")
	end]]
	
	ogse_debug.process_npc(self.object, "s_spw", 2)

	if not object_binder.net_spawn(self, sobject) then
		ogse_debug.process_npc(self.object, "s_spw", 0)
		return false
	end
	
	ogse_debug.process_npc(self.object, "s_spw", 3)

--	if self.object:spawn_ini():section_exist("dont_spawn_online") then
--		printf("!!!OFFLINE")
--		alife():object(self.object:id()).dont_spawn_online = true
--	end


	db.add_obj(self.object)
	
	if not self.loaded then
		self.loaded = xr_logic.load_logic_online(self.object)
		local st = self.st
		st.loaded_ini_filename = st.ini_filename
		st.loaded_section_logic = st.section_logic
		st.loaded_active_section = st.active_section
		st.loaded_gulag_name = st.gulag_name
	end
	
	if has_alife_info("bar_heli_scene_stay_online") then
		if string.find(self.object:name(), "bar_ecolog_professor") then
			local gulag = xr_gulag.get_npc_gulag(self.object)
			if gulag and gulag.name ~= "bar_ecolog_crush" then
				log1("Найден Круглов, его гулаг "..gulag.name)
				gulag:free_obj(self.object:id())
			end		
		end		
	end
	
	ogse_debug.process_npc(self.object, "s_spw", 4)

	-- Все CALLBACK-и ставить здесь:
	self.object:set_patrol_extrapolate_callback(motivator_binder.extrapolate_callback, self)
	self.object:set_callback(callback.hit, motivator_binder.hit_callback, self)
	self.object:set_callback(callback.death, motivator_binder.death_callback, self)
	self.object:set_callback(callback.use_object, motivator_binder.use_callback, self)
	--
	self.object:set_callback(callback_ex.entity_alive_before_hit, self.before_hit_callback, self)
	self.object:set_callback(callback.on_item_drop, self.on_item_drop, self)	
	self.object:set_callback(callback.on_item_take, self.on_item_take, self)
	--memusage.collect_info(self.object, "after__callback")
	
	ogse_debug.process_npc(self.object, "s_spw", 5)

	if not ogse.is_quest_npc(self.object) then
		self.object:set_callback(callback.sound, motivator_binder.hear_callback, self)
	end
	
	ogse_debug.process_npc(self.object, "s_spw", 6)

    --' Загрузка историй для лагеря.
	if self.loaded == false then
		local char_ini = self.object:spawn_ini() or ini_file("scripts\\dummy.ltx")
		xr_info.loadInfo(self.object, char_ini)
	end
	
	ogse_debug.process_npc(self.object, "s_spw", 7)
	
	if not self.object:alive() then
		if xr_companion.is_companion(self.object:id()) then
			xr_companion.save_var_companion(self.object:id(), "is_companion", 0)
		end
		--' Наносим небольшой импульс вперед.
		local h = hit()
		h.draftsman = self.object
		h.type = hit.fire_wound
		h.direction = db.actor:position():sub(self.object:position())
		h:bone("bip01_spine")
		h.power = 0.01
		h.impulse = 1
		self.object:hit(h)
		
		local s_obj = alife():object(self.object:id())
		
		if s_obj.offline_dead == 1 then
		
			ogse_debug.process_npc(self.object, "s_spw", 71)
			
			if debug_flag then
				log1("--ВНИМАНИЕ! Обнаружен погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведена обработка лута и постановка объекта на удаление!")					
				db.actor:give_game_news("ВНИМАНИЕ! Обнаружен погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведена обработка лута и постановка объекта на удаление!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end
			
			if self.st.death then
				xr_logic.issue_event(self.object, self.st.death, "death_callback", self.object, self.object)
			end
			
			ogse_debug.process_npc(self.object, "s_spw", 72)	

			if self.st.active_section then
				xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", self.object, self.object)
			end
			
			ogse_debug.process_npc(self.object, "s_spw", 73)	

			sr_territory.issue_event(self.object, "death_callback", self.object, self.object)
			
			ogse_debug.process_npc(self.object, "s_spw", 74)

			local drop, err_msg = pcall(protected_loot,self.object,self.object)
			if not drop then
				log1("ERROR: XR_M protected_loot pcall FAIL "..self.object:id().." reason: "..tostring(err_msg))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при генерации лута после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end	

			ogse_debug.process_npc(self.object, "s_spw", 75)

			self:clear_callbacks()
			
			ogse_debug.process_npc(self.object, "s_spw", 76)

			-- добавим в постмортем-обработчик
			db.add_deadman(self.object, self.object)
			
			ogse_debug.process_npc(self.object, "s_spw", 77)
			
			s_obj.offline_dead = game.time()+(1*24*60*60*1000)
			
		elseif s_obj.offline_dead > 1 and s_obj.offline_dead <= game.time() then
			
			ogse_debug.process_npc(self.object, "s_spw", 77)
			
			if death_manager.offline_dead_quest_check(self.object) then
				-- имеет квестовую вещь, не трогаем
			else
				if debug_flag then
					log1("--ВНИМАНИЕ! Обнаружен уже обработанный погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведено удаление объекта!")
					db.actor:give_game_news("ВНИМАНИЕ! Обнаружен уже обработанный погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведено удаление объекта!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
				end
				if checker_minefield.to_delete[self.object:id()] == nil and db.actor:position():distance_to(self.object:position()) >= 100 then
					checker_minefield.to_delete[self.object:id()] = self.object:id()
				end				
			end
			
			ogse_debug.process_npc(self.object, "s_spw", 0)
			return true
		end
		
		ogse_debug.process_npc(self.object, "s_spw", 0)
		return true
	end
	
	ogse_debug.process_npc(self.object, "s_spw", 8)

  --' Для зомбированных чуваков говорим что аномалий не существует
  if self.object:character_community() == "zombied" then
    local manager = self.object:motivation_action_manager()
    manager:remove_evaluator  (stalker_ids.property_anomaly)
    manager:add_evaluator   (stalker_ids.property_anomaly, property_evaluator_const(false))
  else
    local manager = self.object:motivation_action_manager()
    manager:remove_evaluator  (stalker_ids.property_anomaly)
    manager:add_evaluator   (stalker_ids.property_anomaly, property_evaluator_const(false))
  end
  
  ogse_debug.process_npc(self.object, "s_spw", 9)
	
	if xr_combat_companion then
		local manager = self.object:motivation_action_manager()
		manager:add_evaluator(xr_combat_companion.prop_combat, property_evaluator_const(false))
	end	
	
	if xrs_battle_ai then
		local manager = self.object:motivation_action_manager()
		manager:add_evaluator(xrs_battle_ai.evid_altcombat, property_evaluator_const(false))	
	end
	
	if xr_companion then
		local manager = self.object:motivation_action_manager()
		manager:add_evaluator(xr_companion.property_need_companion, property_evaluator_const(false))
	end	
	
	if xrs_grenade then
		local manager = self.object:motivation_action_manager()
		manager:add_evaluator(xrs_grenade.prop_fire, property_evaluator_const(false))
		manager:add_evaluator(xrs_grenade.prop_grenade, property_evaluator_const(false))
	end		
	
	ogse_debug.process_npc(self.object, "s_spw", 10)
	  

  if ogsm_hideout then
	local manager = self.object:motivation_action_manager()
      manager:add_evaluator(ogsm_hideout.property_blowout, property_evaluator_const(false))
      manager:add_evaluator(ogsm_hideout.property_hideout_lost, property_evaluator_const(false))
      manager:add_evaluator(ogsm_hideout.property_inhide, property_evaluator_const(false))
      manager:add_evaluator(ogsm_hideout.property_psyzoned, property_evaluator_const(false))

  end
  
	ogse_debug.process_npc(self.object, "s_spw", 11)

    --' загрузка озвучки
    --memusage.collect_info(self.object, "before_soundmgr")
    xr_sound.load_sound(self.object)
    --memusage.collect_info(self.object, "after_soundmgr_netspawn_end")
	
	ogse_debug.process_npc(self.object, "s_spw", 12)
	
	--// xr_companion
	if xr_companion.is_companion(self.object:id()) then
		local gulag = xr_gulag.get_npc_gulag(self.object)
		if gulag then
			gulag:free_obj(self.object:id())
		end		
		if db.actor then
			db.actor:give_game_news("Обнаружен сигнал КПК вашего напарника. "..self.object:character_name() .. " находится поблизости!", "ui\\ui_iconsTotal", Frect():set(0,235,83,47), 0, 15000)
		end
		sobject:smart_terrain_task_deactivate()
		xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_stalker, false )	-- сделано, чтобы сбросить активную секцию у напарника
	else
		xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_stalker, self.loaded )
	end

	ogse_debug.process_npc(self.object, "s_spw", 13)

	ogse_car_control.register_target(self.object)
	ogse_scripted_btr.register_target(self.object)

	ogse_debug.process_npc(self.object, "s_spw", 0)
	--// xr_companion	
	return true
end

function motivator_binder:net_destroy()
	xr_logic.save_logic_online(self.object)
	
	if xrs_ai then xrs_ai.npc_net_destroy(self.object) end

	--printf("motivator_binder:net_destroy(): self.object:name()='%s'", self.object:name())

	local st = db.storage[self.object:id()]
	if st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy", self.object)
	end

	db.del_obj(self.object)

	db.storage[self.object:id()] = nil

	self:clear_callbacks()
	self.object:set_callback(callback.use_object, nil)
	self.object:set_callback(callback.sound, nil)

	ogse_car_control.unregister_target(self.object)
	ogse_scripted_btr.unregister_target(self.object)
	
	if table.getn(self.particles)>0 then
		for kk,vv in pairs(self.particles) do
			if not vv:is_finished() then
				vv:stop()
				self.particles[kk]=nil
			end
		end
	end
	
	event("npc_net_destroy"):trigger({victim = self.object})

	object_binder.net_destroy(self)
end

function motivator_binder:clear_callbacks()
	self.object:set_patrol_extrapolate_callback(nil)
	self.object:set_callback(callback.hit, nil)
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.on_item_drop, nil)
	self.object:set_callback(callback.on_item_take, nil)
end

function motivator_binder:before_hit_callback(p_s_hit, p_ignore_flags)
	local hit_data = read_hit_data(p_s_hit)
	if hit_data ~= 0 then
		local obj = level.object_by_id(hit_data.who_id)
		if obj then -- если есть виновник хита
			local obj_id = obj:id()
			if obj_id ~= db.actor:id() and IsStalker(obj) then -- если не актор и сталкер
				-- проверяем условия игнорирования урона от дружественного огня
				if  obj_id ~= self.object:id() and -- если не сам себя
					obj:general_goodwill(self.object) >= -100 and -- если друг
					(self.object:relation(obj) ~= game_object.enemy or self.object:character_community() == obj:character_community()) and 
					not xr_companion.is_companion(obj_id)
				then
					-- подстрелил друг, игнорируем
					write_memory_int(1, p_ignore_flags)
				end
			elseif obj_id == bind_statpkm.pkm_captured and obj:section() == "stationary_pkm" then -- если это турель
				-- то надо заменить на реального виновника, т.е. ГГ
				write_memory_int(db.actor:cast_game_object(), p_s_hit, hit_offset.who)
				write_memory_int16(db.actor:id(), p_s_hit, hit_offset.whoID)
			end
		end
	end
end

function motivator_binder:hit_callback(obj, amount, local_direction, who, bone_index)

	if not self.object then
		self.object = obj
	end

	ogse_debug.process_npc(self.object, "hit", 1)

	if xr_companion.is_companion(self.object:id()) and amount < 0.3 then
		xr_sound.set_sound(self.object, nil)
		stop_play_sound(self.object)
	end
	
	ogse_debug.process_npc(self.object, "hit", 2)
	
	if who and victim and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end	
	
	if amount > 0.01 then
		local chk_dist = self.object:position():distance_to(who:position())
		local range = self.object:range()
		if chk_dist > range then
			self.object:set_range(chk_dist*1.1)
		end
		self.object:make_object_visible_somewhen(who)
	end
	
	ogse_debug.process_npc(self.object, "hit", 3) 
	
	-- FIXME: коллбеки неплохо было бы регистрировать в общем storage, а не посхемно...
	-- просто всегда ставить их при включении схемы и снимать при отключении.
	
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	
	ogse_debug.process_npc(self.object, "hit", 4)

	if self.st.combat_ignore then
		xr_logic.issue_event(self.object, self.st.combat_ignore, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	
	ogse_debug.process_npc(self.object, "hit", 5)

	if self.st.combat then
		xr_logic.issue_event(self.object, self.st.combat, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	
	ogse_debug.process_npc(self.object, "hit", 6)
	
	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	
	ogse_debug.process_npc(self.object, "hit", 7)

	if amount > 0 then
		sr_territory.issue_event(self.object, "hit_callback", obj, amount, local_direction, who, bone_index)
		if self.object then
			local drop, err_msg = pcall(xr_wounded.hit_callback,self.object:id())
			if not drop then
				log1("ERROR: XR_M xr_wounded.hit_call_back pcall 1 FAIL "..self.object:id().." reason: "..tostring(err_msg))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коолбэка хита по раненому! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end				
		else
			local drop, err_msg = pcall(xr_wounded.hit_callback,obj:id())
			if not drop then
				log1("ERROR: XR_M xr_wounded.hit_call_back pcall 2 FAIL "..obj:id().." reason: "..tostring(err_msg))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коолбэка хита по раненому! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end				
		end
	end
	
	ogse_debug.process_npc(self.object, "hit", 8)
	

	
	ogse_debug.process_npc(self.object, "hit", 10)

	if checker_minefield then checker_minefield.mine_hit(obj,who) end
	
	ogse_debug.process_npc(self.object, "hit", 11)
	
	ogse_debug.process_npc(self.object, "hit", 12)
	
	local warn_timer = time_global()
	
	if not ogse.is_quest_npc(obj) and not xr_companion.is_companion(obj:id()) then
		if not warn_check_timer[obj:id()] then
			warn_check_timer[obj:id()] = warn_timer + math.random(1000, 2000) 
		else
			if warn_check_timer[obj:id()] < warn_timer then
				drop, err_msg = pcall(look_to_shot,obj,who)
				if not drop then
					log1("ERROR: XR_M look_to_shot pcall FAIL "..obj:id().." reason: "..tostring(err_msg))
					db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке звука стрельбы! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
				end	
				warn_check_timer[obj:id()] = warn_timer + math.random(1000, 2000)
			end
		end
	end
	
	ogse_debug.process_npc(self.object, "hit", 13)
	
	if amount > 0.05 then
		xr_effects.bar_territory_hit(self.object, who)
	end
	
	-- ogse_debug.process_npc(self.object, "hit", 14)
	
	-- if rx_ai and amount > 0.15 and not (xr_companion.is_companion(self.object:id()) and who:id() == db.actor:id()) then 
		-- rx_ai.npc_hit(obj,amount,local_direction,who,bone_index,self.object) 
	-- end
	
	ogse_debug.process_npc(self.object, "hit", 14)
	
	if xr_companion.is_companion(self.object:id()) then
		if xr_combat_companion then
			xr_combat_companion.hit_callback(self.object, who, amount)
		else	
			log1("--xr_combat_companion cannot be loaded!")
		end
	end
	
	ogse_debug.process_npc(self.object, "hit", 15)
	
	if amount > 0.05 then
		local hit_info = {
			timer = time_global() + 7000,
			id = who:id(),
			dist = self.object:position():distance_to(who:position())
		}	
		ogse_night.being_hit[self.object:id()] = hit_info
	end
	
	ogse_debug.process_npc(self.object, "hit", 16)
	
	event("npc_hit"):trigger({victim = self.object, amount = amount, dir = local_direction, who = who, bone = bone_index})
	
	ogse_debug.process_npc(self.object, "hit", 0)
	
end

function motivator_binder:death_callback(victim, who)

	ogse_debug.process_npc(victim, "dth", 1)
	
	if who and victim and string.find(who:name(), "vehicle_btr") and ogse_car_control.current_car and who:id() == ogse_car_control.current_car:id() then
		who = db.actor
		local drop, err_msg = pcall(ogse_car_control.btr_kill,victim)
		if not drop then
			log1("ERROR: XR_M ogse_car_control.btr_kill pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
			db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке смерти от орудия БТР! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
		end
	end
	
	ogse_debug.process_npc(victim, "dth", 2)

	ogse.deadmans_table[victim:id()] = tostring(game.time()).."_"..tostring(who:id())
	
	ogse_debug.process_npc(victim, "dth", 21)	

	local name = tostring(victim:name())
	ogse_hitfx.npc_on_death(victim, who)
	
	ogse_debug.process_npc(victim, "dth", 3)

	if self.st.death then
		xr_logic.issue_event(self.object, self.st.death, "death_callback", victim, who)
	end
	
	ogse_debug.process_npc(victim, "dth", 4)	

	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end
	
	ogse_debug.process_npc(victim, "dth", 5)	

	sr_territory.issue_event(self.object, "death_callback", victim, who)
	
	ogse_debug.process_npc(victim, "dth", 6)	

	if self.object then
		smart_terrain.on_death(self.object:id())
	elseif victim then
		smart_terrain.on_death(victim:id())
		self.object = victim
	end
	
	local drop, err_msg = pcall(sr_light.check_light,obj)
	if not drop then
		log1("ERROR: XR_M sr_light.check_light pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
		db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке света фонаря после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
	end	
	
	ogse_debug.process_npc(victim, "dth", 7)

	local drop, err_msg = pcall(protected_loot,self.object,victim)
	if not drop then
		log1("ERROR: XR_M protected_loot pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
		db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при генерации лута после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
	end	
	
	ogse_debug.process_npc(victim, "dth", 8)

	rx_ai.npc_death(self.object,who)
	
	ogse_debug.process_npc(victim, "dth", 9)

	self:clear_callbacks()
	
	ogse_debug.process_npc(victim, "dth", 10)

	-- добавим в постмортем-обработчик
	db.add_deadman(self.object, victim)
	
	ogse_debug.process_npc(victim, "dth", 11)
	
	-- добавление опыта за убийство
--	if who:id() == db.actor:id() then
		xr_statistic.addKillCount(who, self.object)
--	end

	ogse_debug.process_npc(victim, "dth", 12)

    --новости 
	news_amk_core.on_death(victim, who) -- скажем о смерти
    death_news.on_death(victim, who) -- и прокомментируем её
	
	ogse_debug.process_npc(victim, "dth", 13)

	--проверка на аномалии  
	ogse_death_artefact.on_death(victim, who)
	
	ogse_debug.process_npc(victim, "dth", 14)
	
	--проверка на мины
	if checker_minefield then checker_minefield.mine_hit(victim,who) end
	
	ogse_debug.process_npc(victim, "dth", 15)
	
	-- --' Наносим небольшой импульс вперед.
	-- local h = hit()
	-- h.draftsman = self.object
	-- h.type = hit.fire_wound
	-- h.direction = db.actor:position():sub(self.object:position())
	-- h:bone("pelvis")
	-- h.power = 1
	-- h.impulse = 10
	-- self.object:hit(h)
	
	ogse_debug.process_npc(victim, "dth", 16)
	

	local community = self.object:character_community()
	if	community == "zombied" or
		community == "monolith" or
		community == "arena_enemy" or
		string.find(self.object:name(), "aem_")
	then
		-- did nothing
	else
		local drop, err_msg = pcall(actor_stats.remove_from_ranking,self.object:id())
		if not drop then
			log1("ERROR: XR_DEATH remove_from_ranking pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
			db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой удаления из рангов после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
		end		
	end
	
	ogse_debug.process_npc(victim, "dth", 17)
	
	--// xr_companion
	xr_companion.companion_death(self.object)
	
	ogse_debug.process_npc(victim, "dth", 18)
	
	xr_effects.bar_territory_death(self.object, who)
	
	ogse_debug.process_npc(victim, "dth", 19)
	
	ogse_car_control.unregister_target(self.object)
	ogse_scripted_btr.unregister_target(self.object)
	
	ogse_debug.process_npc(victim, "dth", 20)
	
	if table.getn(self.particles)>0 then
		for kk,vv in pairs(self.particles) do
				vv:on_death()
		end
	end	
	
	ogse_debug.process_npc(victim, "dth", 21)
	
	event("npc_death"):trigger({victim = self.object, who = who})

	ogse_debug.process_npc(victim, "dth", 0)
	
end

function motivator_binder:use_callback(obj, who)

	ogse_debug.process_npc(self.object, "use", 1)

    if not self.object then 
		if obj then
			self.object = obj
		else	
			ogse_debug.process_npc(self.object, "use", 0)
			return
		end
	end
	
	ogse_debug.process_npc(self.object, "use", 2)

	if self.object:alive() then
		ogse_debug.process_npc(self.object, "use", 3)
		
		xr_use.notify_on_use(obj, who)
		if self.st.active_section then
			xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
		end
	else
		ogse_debug.process_npc(self.object, "use", 4)
		if self.treasure_processed == false then
			treasure_manager:get_treasure_manager():use(self.object)
			self.treasure_processed = true
		end
	end

	ogse_debug.process_npc(self.object, "use", 0)
	event("npc_used"):trigger({obj = self.object, who = who})
	self.am:call("npc_use", self.object, who)
end

function motivator_binder:update(delta)
	object_binder.update(self, delta)
	
	ogse_debug.check_monsters()
	ogse_debug.check_actor()
	
	ogse_debug.process_npc(self.object, "upd", 1)
	
	if not watchdog[self.object:id()] then
		watchdog[self.object:id()] = 0
	end

--	self.prev_action_id = debug_helper.print_action(self.object, self.prev_action_id)

    if self.first_update == false then
		--спавн друпа если не был произведен
        if self.object:alive() == false then
			local obj = level.object_by_id(self.object:id())
			if obj and IsStalker(obj) and (obj:object("device_torch") or obj:object("device_pda")) then
				death_manager.drop_manager(self.object, nil):create_release_item()
				ogse_debug.process_npc(self.object, "upd", 0)
				return
			end				
        end        
        self.first_update = true
    end
	
	ogse_debug.process_npc(self.object, "upd", 2)

	--' Апдейт менеджера состояний тела
	if self.st.state_mgr then
		if self.object:alive() then
			self.st.state_mgr:update()
		else
			self.st.state_mgr = nil
		end
	end
	
	ogse_debug.process_npc(self.object, "upd", 3)
	
	--' Апдейт саундменеджера
	if self.object:alive() then
		xr_sound.update(self.object)
	end
	
	ogse_debug.process_npc(self.object, "upd", 4)
	
	ogse_debug.process_npc(self.object, "upd", 5)

	if self.object:alive() then
		if self.object:is_talk_enabled() then
			self.object:set_tip_text("character_use")
		else
			self.object:set_tip_text("")
		end
	else
		self.object:set_tip_text_default()
	end

	ogse_debug.process_npc(self.object, "upd", 6)
	
	self.object:info_clear()
	local best_enemy = self.object:best_enemy()
	if best_enemy then
		self.object:info_add('enemy -- ' .. best_enemy:name())
	end
	
	ogse_debug.process_npc(self.object, "upd", 7)
	
	local active_section = db.storage[self.object:id()].active_section
	if active_section then
		self.object:info_add('section -- ' .. active_section)
	end
	self.object:info_add('name -- ' .. self.object:name())
	
	ogse_debug.process_npc(self.object, "upd", 8)
	
	if xr_combat_companion then
		xr_combat_companion.process_enemy(db.actor, self.object)
	else	
		log1("--xr_combat_companion cannot be loaded!")
	end
	
	ogse_debug.process_npc(self.object, "upd", 81)
		if xr_companion.is_companion(self.object:id()) then
		if xr_combat_companion then
			xr_combat_companion.reprioritize_targets(self.object)
		else	
			log1("--xr_combat_companion cannot be loaded!")
		end	
	end
	
	ogse_debug.process_npc(self.object, "upd", 82)
	
	if particles[self.object:id()] and table.getn(particles[self.object:id()])>0 then
		for kk,vv in pairs(particles[self.object:id()]) do
			if amk_particle then
				table.insert(self.particles,amk_particle.amk_particle(vv))
				table.remove(particles[self.object:id()],kk)
			end
		end
	end

	ogse_debug.process_npc(self.object, "upd", 83)
	
	if table.getn(self.particles)>0 then
		for kk,vv in pairs(self.particles) do
			if vv:is_finished() then
				self.particles[kk]=nil
			else
				vv:update(delta)
			end
		end
	end	
	
	ogse_debug.process_npc(self.object, "upd", 84)
	
	event("npc_update"):trigger({obj = self.object})

	--' Проверка потери жизни
--[[
	if lasttime == nil or
	   game.get_game_time():diffSec(lasttime) > 1
	then
		printf("%f * %f", self.object.health, self.object.health - lasthealth)
		lasthealth = self.object.health
		lasttime = game.get_game_time()
	end
]]
--[[	if not self.debug_smrt then
		for k, v in pairs( db.smart_terrain_by_id ) do
			self.debug_smrt = true

			local o = alife():object( self.object:id() )

			if v:enabled(o) then
				v:register(o)
			end

			break
		end
	end]]
	
	ogse_debug.process_npc(self.object, "upd", 85)
	
	if watchdog[self.object:id()] == 1 then
		-- Апдейт включения/выключения фонарика
		if self.object:alive() then
			if time_global() - self.last_update > 1000 then
				ogse_debug.process_npc(self.object, "upd", 9)
			   sr_light.check_light(self.object)
			   self.last_update = time_global()
			end	
		end
		-- Апдейт включения/выключения фонарика
	end
	if watchdog[self.object:id()] == 2 then
		-- Апдейт торговли
		ogse_debug.process_npc(self.object, "upd", 10)
		if self.object:alive() then
			if self.st.state_mgr.combat == false and
			   self.st.state_mgr.alife == false
			then
				trade_manager.update(self.object)
			end					
		end
		-- Апдейт торговли
	end
	if watchdog[self.object:id()] == 3 then

	
	end
	if watchdog[self.object:id()] == 4 then
		-- Обновление схем гранатометания, медика и переодевания
		ogse_debug.process_npc(self.object, "upd", 12)
		if self.object:alive() then
			if xrs_ai then xrs_ai.npc_update(self) end
		end
		-- Обновление схем гранатометания, медика и переодевания
	end
	if watchdog[self.object:id()] == 5 then
		-- Обновление оружейного менеджера
		ogse_debug.process_npc(self.object, "upd", 13)
		if self.object:alive() then
			if rx_ai then rx_ai.npc_update(self.object,self.st) end
		end
		-- Обновление оружейного менеджера
	end
	if watchdog[self.object:id()] == 6 then
		-- Проверка артефакта в руках
		ogse_debug.process_npc(self.object, "upd", 14)
		if self.object:alive() then
			check_art_weapon(self.object)
		end
		-- Проверка артефакта в руках
	end
	if watchdog[self.object:id()] == 7 then
		-- Проверка брони
		ogse_debug.process_npc(self.object, "upd", 15)
		if self.object:alive() then
			local chk_time = time_global()
			if not armor_check[self.object:id()] then
				armor_check[self.object:id()] = time_global() + math.random(10000, 30000)
				if (amkII_equip) then
					amkII_equip.CAmkDisguise():PeriodicalUpdate(self.object)
				end	
			elseif chk_time > armor_check[self.object:id()] then
				armor_check[self.object:id()] = time_global() + math.random(10000, 30000)
				if (amkII_equip) then
					amkII_equip.CAmkDisguise():PeriodicalUpdate(self.object)
				end		
			end
		end
		-- Проверка брони
	end	

	ogse_debug.process_npc(self.object, "upd", 86)
	
	ogse_quest_guard.check_guard_necessity_for_object(self.object)
	
	ogse_debug.process_npc(self.object, "upd", 16)
	
	watchdog[self.object:id()] = watchdog[self.object:id()] + 1
	if watchdog[self.object:id()] >= watchdog_max then
		watchdog[self.object:id()] = 0
	end
	
	ogse_debug.process_npc(self.object, "upd", 0)
	
end

function motivator_binder:reload(section)
	--memusage.collect_info(self.object, "reload_start")
	object_binder.reload(self, section)
	--printf("motivator_binder:reload(): self.object:name()='%s'", self.object:name())
	--self.object:set_pda_callback(pda_callback)
	--memusage.collect_info(self.object, "reload_end")
end

function motivator_binder:net_save_relevant()
	--printf("motivator_binder:net_save_relevant(): self.object:name()='%s'", self.object:name())
	return true
end

function motivator_binder:save(packet)

	ogse_debug.process_npc(self.object, "npc_sv", 1)

	xr_logic.pstor_store(self.object, "anom_invis", get_anomaly_invisibility(self.object))
	
	ogse_debug.process_npc(self.object, "npc_sv", 2)
	
	xr_logic.pstor_store(self.object, "is_invulnerable", self.object:invulnerable())
	
	ogse_debug.process_npc(self.object, "npc_sv", 3)

	if rx_wmgr then
		rx_wmgr.return_all()
	end
	
	ogse_debug.process_npc(self.object, "npc_sv", 4)
	
	ogse_debug.process_npc(self.object, "npc_sv", 5)
	
	object_binder.save(self, packet)
	
	ogse_debug.process_npc(self.object, "npc_sv", 6)

	packet:w_bool(self.treasure_processed)
	
	ogse_debug.process_npc(self.object, "npc_sv", 7)

	xr_logic.save_obj(self.object, packet)
	
	ogse_debug.process_npc(self.object, "npc_sv", 9)
	
	dialog_manager.save(self.object, packet)
	
	ogse_debug.process_npc(self.object, "npc_sv", 10)
	
	trade_manager.save(self.object, packet)
	
	ogse_debug.process_npc(self.object, "npc_sv", 0)
end

function motivator_binder:load(reader)
	self.loaded = true

	printf("motivator_binder:load(): self.object:name()='%s'", self.object:name())
	object_binder.load(self, reader)
	printf("motivator_binder:object_binder.load(): self.object:name()='%s'", self.object:name())

	if reader:r_eof() then
		if self.object:alive() then
			abort("SAVE FILE IS CORRUPT - XR_MOTIV, OBJ: "..tostring(self.object:name()).." ID "..self.object:id().." PRO: "..self.object:profile_name())
		else
			log1("ERROR: CORRUPTED QUEST BODY FOUND! "..tostring(self.object:name()).." ID "..self.object:id().." PRO: "..self.object:profile_name())
			db.actor:give_game_news("ВНИМАНИЕ! Обнаружен повреждённый квестовый труп! Объект: "..self.object:character_name().." ИД: "..self.object:id().." Профиль: "..self.object:profile_name().." Убедитесь что с телом всё в порядке, и с него выдаются все необходимые инфопоршены и вещи!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			return true
		end
	end


	self.treasure_processed = reader:r_bool()

	xr_logic.load_obj(self.object, reader)

	self.npc_script_version = alife():object(self.object:id()).script_version
	dialog_manager.load(self.object, reader, self.npc_script_version)
	trade_manager.load(self.object, reader)
	local anom_invis = xr_logic.pstor_retrieve(self.object, "anom_invis", false)
	set_anomaly_invisibility(self.object, anom_invis)
	
	local is_invulnerable = xr_logic.pstor_retrieve(self.object, "is_invulnerable", false)
	self.object:invulnerable(is_invulnerable)
end

function motivator_binder:hear_callback(self, who, sound_type, sound_position, sound_power)

	ogse_debug.process_npc(self, "hr", 1)
	
	--// xr_companion
	if xr_companion.is_companion(self:id()) then
		ogse_debug.process_npc(self, "hr", 0)
		return
	end	
	
	if who and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end		

	ogse_debug.process_npc(self, "hr", 2)	
	
	local snd_timer = time_global()
	
	ogse_debug.process_npc(self, "hr", 3)
	
	if not snd_check_timer[self:id()] then
		snd_check_timer[self:id()] = snd_timer + math.random(1000, 2000) 
	else
		if snd_check_timer[self:id()] < snd_timer then
			local result, err = pcall(check_sound, self, who, sound_type, sound_position, sound_power)
			if not result then
				log1("ERROR: XR_M hear_callback pcall FAIL "..self:id().." reason: "..tostring(err))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коллбэка звука! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end
			snd_check_timer[self:id()] = snd_timer + math.random(1000, 2000)
		end
	end
	
	
	
	
	ogse_debug.process_npc(self, "hr", 0)

end

class "timer_drop_weapon" (ogse_qt.quick_timer)
function timer_drop_weapon:__init(item, parent) super()
	self.item_id = item:id()
	self.parent_id = parent:id()
end
function timer_drop_weapon:condition()
	local item = level.object_by_id(self.item_id)
	if item == nil then
		self:stop()
	elseif item:parent() == nil then
		return true
	elseif item:parent():id() ~= self.parent_id then
		self:stop()
	end
	return false
end
function timer_drop_weapon:action()
	local parent = level.object_by_id(self.parent_id)
	local item = level.object_by_id(self.item_id)
	if item ~= nil then
		death_manager.set_weapon_drop_condition(item, parent)
	end
end

function motivator_binder:on_item_drop(obj)
	if not obj then 
		return 
	else	
		local id = obj:id()
		local sobj = alife():object(id)
		if not sobj then
			return
		end
	end
	if obj:is_weapon() then
		timer_drop_weapon(obj, obj:parent()):start()
	end
end

function motivator_binder:on_item_take(obj)
	local sobj = nil
	if not obj then 
		return 
	else	
		local id = obj:id()
		sobj = alife():object(id)
		if not sobj then
			return
		end
	end
	
	local section = sobj:section_name()
	
	if section == "device_torch" then
		if not obj:attachable_item_enabled() then
			obj:switch_torch(false)
		end
	end
end

function AddToMotivator(npc)
	if alife() then
		npc:bind_object(this.motivator_binder(npc))
	end
end

-- Эвалюаторы, которые имеют высший приоритет, и, соответственно, перебивают остальные скрипты собой
function addCommonPrecondition(action)
	--action:add_precondition (world_property(xr_evaluators_id.reaction,false))
	action:add_precondition (world_property(xr_evaluators_id.stohe_meet_base + 1,false))
	action:add_precondition (world_property(xr_evaluators_id.sidor_wounded_base + 0,  false))
	action:add_precondition (world_property(xr_evaluators_id.chugai_heli_hunter_base, false))
	action:add_precondition (world_property(xr_evaluators_id.abuse_base, false))
	
	if xr_combat_companion and xr_companion then
		action:add_precondition (world_property(xr_combat_companion.prop_combat, false))
		action:add_precondition (world_property(xr_companion.property_need_companion, false))
	end
	
	if xrs_battle_ai then
		action:add_precondition (world_property(xrs_battle_ai.evid_altcombat, false))
	end	
	
	if ogsm_hideout then
		action:add_precondition(world_property(ogsm_hideout.property_blowout, false))
		action:add_precondition(world_property(ogsm_hideout.property_hideout_lost, false))
		action:add_precondition(world_property(ogsm_hideout.property_inhide, false))
		action:add_precondition(world_property(ogsm_hideout.property_psyzoned, false))
	end

	if xrs_ai then xrs_ai.addCommonPrecondition(action) end

	if rx_ai then rx_ai.addCommonPrecondition(action) end
	
	if watcher_act then
		action:add_precondition (world_property(watcher_act.evid_see_stuff, false))
		action:add_precondition (world_property(watcher_act.evid_near_stuff, false))
	end

	action:add_precondition(world_property(ogse_anomaly_evader.prop_evade,false))
	
end

function play_particle(obj,params)
	if not particles[obj:id()] then
		particles[obj:id()]={}
	end
	table.insert(particles[obj:id()],params)
end