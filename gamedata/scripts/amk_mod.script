-- -*- mode: lua; coding: windows-1251-dos -*-
--[[

File:  amk_mod .script
copyright © AMK TEAM 2007-2008

добавлена  fenechka by TAG

--]]

function attach( sm )
  sm:subscribe({ signal = "on_before_spawn", fun = this.on_before_spawn })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_actor_spawn  })
end


function on_before_spawn()
  load_hand_made_af_info()
end


function on_actor_spawn()
  if db.actor:has_info( "blowout" ) then
    on_blowout_hit_actor()
    blowout_phantoms()
  end
  if level.name() == "l10_radar" then
    if not has_alife_info( "bar_deactivate_radar_done" ) then
      ogse_signals.get_mgr():subscribe({
        signal = "on_update", fun = this.check_radar_off,
        script_name = script_name(),
      })
    end
  end
end


local afs = {}
-- аномалия "узнаётся" по части названия!
-- komp - компонентv
-- удача v_udachi + вvрождение в булvжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописvвать в таблицу
-- cel - цель (может бvть одновременно несколько целей)
-- info - инфопорция, которая будет вvдана после L-L+=+Ј варки
-- virogd - во что вvрождается (может бvть одновременно несколько вvрождений)
-- vremya = {дни, часы, минуты} - время варки/мутации
-- remove_anomaly - удалить ли аномалию (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадёт в трансмутатор
anom_recept_komp = {}

function load_hand_made_af_info()
  anom_recept_komp.anomalii = {}
  local base = "dsh.hand_made_arts."
  for _, k in pairs( get_section_keys( base .. "anomalies" ) ) do
    anom_recept_komp.anomalii[ k ] = {
      [ "default" ] = {},
      [ "name"    ] = get_string( base .. k .. ".self", "name" ),
      [ "recepti" ] = {},
    }
    anom_recept_komp.anomalii[ k ].recepti = {}
    for _, rec in ipairs( get_section_keys( base .. k ) ) do
      local sect = base .. k .. "." .. rec
      local t    = {}
      local need_info = get_string( sect, "need_info" )
      ASSERT( need_info, "%s.%s: required field not found", sect, "need_info" )
      anom_recept_komp.anomalii[ k ].recepti[ need_info ] = t
      t.cel = {}
      local cel = get_string( sect, "cel" )
      if cel then
        for _, af in ipairs( parse_names( cel ) ) do
          ASSERT( sys_ini:section_exist( af ), "section not found: %s", af )
          t.cel[ af ] = true
        end
      end
      t.komp = {}
      local komp = get_string( sect, "komp" )
      if komp then
        for _, af in ipairs( parse_names( komp ) ) do
          ASSERT( sys_ini:section_exist( af ), "section not found: %s", af )
          t.komp[ af ] = true
          afs[ af ] = true
        end
      end
      t.virogd = {}
      local virogd = get_string( sect, "virogd" )
      if virogd then
        for _, af in ipairs( parse_names( virogd ) ) do
          ASSERT( sys_ini:section_exist( af ), "section not found: %s", af )
          t.virogd[ af ] = true
        end
      end
      t.info            = get_string( sect, "info" )
      t.not_for_mutator = get_bool( sect, "not_for_mutator", false )
      t.remove_anomaly  = get_bool( sect, "remove_anomaly",  false )
      t.v_udachi        = get_float( sect, "v_udachi", 0 )
      t.v_virogd        = get_float( sect, "v_virogd", 0 )
      t.vremya          = get_numbers( sect, "vremya" )
    end
  end
end


local math_random = math.random
local math_floor = math.floor
local math_pi = math.pi
local math_sin = math.sin
local math_cos = math.cos
local math_ceil = math.ceil
local string_find = string.find
local string_sub = string.sub

local nrg,med,cnt,w
in_hide=false
local sound_obj_right,sound_obj_left,snd_volume,snd_obj_eq
local sync_done=false
local dynlasthour
zombied={}

local weather_types={
        l01_escape=1,
        l02_garbage=1,
        l03_agroprom=1,
        l03u_agr_underground=1,
        l04_darkvalley=1,
        l04u_labx18=1,
        l05_bar=1,
        l06_rostok=1,
        l07_military=1,
        l08_yantar=1,
        l08u_brainlab=1,
        l10_radar=1,
        l10u_bunker=1,
        l11_pripyat=1,
        l12_stancia=1,
        l12_stancia_2=1,
        l12u_control_monolith=1,
        l12u_sarcofag=1
}

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      QUEST_AF_STAR        **   **   **   **    **   **   **   ** 
--'*******************************************************************************
local points={
    {
        position={x=-24.2727108001709,y=-12.1660995483398,z=-100.200202941895},
        gv=0,
        lv=73868
        },
    {
        position={x=159.56,y=4.72,z=88.60},
        gv=155,
        lv=463808
        },
    {
        position={x=-4.11,y=2.90,z=108.09},
        gv=85,
        lv=272619
        }
}

function spawn_star(actor,npc,p1,p2)
    local a = points[math_random(#points)]
    local obj = alife():create("amk_af_night_star", vector():set(a.position.x,a.position.y,a.position.z), a.lv, a.gv)
        if (obj) then
                if is_debug==true then add_spot_on_map(obj.id, "red_location", "art") end
        end
        local m_where 
        if news_main then
                m_where = news_main.get_point_description("l01_escape", vector():set(a.position.x,a.position.y,a.position.z))
        else
                m_where = "здесь, на кордоне"
        end
        db.actor:give_talk_message(m_where.." скорее всего поискать стоит. Где-то там он, точно говорю.", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        FIRST_RUN          **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
-- іта функция вvзvвается первой. +нлайновvе объектv недоступнv! db.actor недоступен!
function on_game_start()
        math.randomseed (device ():time_global ())
end
--local tmp_intro=false
function first_run() 
---- На момент вызова этой функции актор уже доступен - переделано на поршень. То, что отключено, обозначено ----
        if not has_alife_info("x_first_run") then
----if amk.load_variable("x_first_run",true) then
----    amk.save_variable("x_first_run",false)
----end
        
----if amk.load_variable("amk_12",0)==0 then  
                amk.spawn_item("amk_zapiska",vector():set(-126.96,-28.41,-379.12),27,125181)
                amk.spawn_item("amk_zapiska",vector():set(21.6,-3.94,-18.28),1140,5991)
                alife():create("amk_zapiska",vector():set(124.86881256104,31.754182815552,-13.352614402771),7186,1543)
                sak.add_new_lcitem()
----    amk.save_variable("amk_12",1)
----end
  
----if amk.load_variable("amk_version",0)<1400 then
        --      tmp_intro=true
----    amk.save_variable("amk_version",1400)
                amk_anoms.pre_blow_off()
        --      amk_anoms.after_blow_on()
                
                spawn_military_btr()    
                spawn_fuel()
                db.actor:give_info_portion("x_first_run")
        end
end
--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        CHECK_SPAWN          **   **   **   **   **    **   **   **  
--'*******************************************************************************
function check_spawn()
        amk_anoms.init()
        spawn_unspawned_respawners() 
        if (news_main) then
                news_main.init()
        end
        if (amk_corpses) then
                amk_corpses.init()
        end
        if (amk_objects) then
                amk_objects.init()
        end

        --спавним аномалии
        --initial_spawn()
  
        if not db.actor:has_info("val_chase_start") then
--if db.actor:has_info("info_amk_recipt_pancir") then
                local objt = alife():story_object(6002)
                if objt then
                        alife():release(objt)
                end
        end
        sak.out_new_lc(9100,"info_way100a")
     sak.out_new_lc(9101,"info_way101a")
     sak.out_new_lc(9102,"info_way102a")
        sak.out_new_lc(9103,"info_way103a")
     sak.out_new_lc(9104,"info_way104a")
     sak.out_new_lc(9105,"info_way105a")
        sak.out_new_lc(9106,"info_way106a")
     sak.out_new_lc(9107,"info_way107a")
     sak.out_new_lc(9108,"info_way108a")
        sak.out_new_lc(9109,"info_way109a")
     sak.out_new_lc(9110,"info_way110a")
     sak.out_new_lc(9111,"info_way111a")
        sak.out_new_lc(1008,"info_way112a")
     sak.out_new_lc(592,"info_way113a")
     sak.out_new_lc(97101,"info_way114a")
     sak.out_new_lc(11504,"info_way_arhara_peshera_cvalka")
     sak.out_new_lc(11505,"info_way_arhara_peshera_agro")
     sak.out_new_lc(11502,"info_way_arhara_cvalka_peshera")
     sak.out_new_lc(11503,"info_way_arhara_agro_peshera")
     sak.out_new_lc(97071,"info_way_arhara_td_les")
     sak.out_new_lc(97081,"info_way_arhara_labirint_peshera")
     sak.out_new_lc(97021,"info_way_arhara_peshera_labirint")
     sak.out_new_lc(11512,"info_way_arhara_labirint_yantar")
     sak.out_new_lc(11515,"info_way_arhara_yantar_labirint")
     sak.out_new_lc(11511,"info_way_arhara_labirint_earth")
     sak.out_new_lc(97041,"info_way_arhara_atp_pripyat")
     sak.out_new_lc(97091,"info_way_arhara_atp_military")
     sak.out_new_lc(97092,"info_way_arhara_atp_kordon")
     sak.out_new_lc(97093,"info_way_arhara_atp_svalka")
     sak.out_new_lc(97100,"info_way_arhara_pripyt_village") 
     sak.out_new_lc(11514,"info_way_arhara_military_earth")
     sak.out_new_lc(11513,"info_way_arhara_td_earth")
     sak.out_new_lc(12506,"info_way_arhara_svalka_earth")
     sak.out_new_lc(11510,"info_way_arhara_earth_labirint")
     sak.out_new_lc(97094,"info_way_arhara_radar_warlab")
     sak.out_new_lc(97095,"info_way_arhara_warlab_brainlab")
     sak.out_new_lc(97097,"info_way_arhara_warlab_skladu")
     sak.out_new_lc(97098,"info_way_arhara_x18_warlab")
     sak.out_new_lc(14002,"info_way_arhara_kordon_boloto")
     sak.out_new_lc(14091,"info_way_arhara_radar_forest")
     sak.out_new_lc(97099,"info_way_arhara_chaes2_atp")
     sak.out_new_lc(11529,"info_way_arhara_village_limansk")
     sak.out_new_lc(11531,"info_way_arhara_village_hospital")
     sak.out_new_lc(97103,"info_way_arhara_chaes_generator")
     sak.out_new_lc(97104,"info_way_arhara_hospital_agroprom")
     sak.out_new_lc(97105,"info_way_arhara_agroprom_marsh1")
     sak.out_new_lc(97001,"info_way_arhara_bar_atp")
     sak.out_new_lc(97106,"info_way_arhara_gener_pripyat")
     sak.out_new_lc(97102,"info_way_arhara_chaes2_chaes")
     sak.out_new_lc(11521,"info_way_arhara_gener_hospital")
     sak.out_new_lc(97096,"info_way_arhara_warlab_generators")
     sak.out_new_lc(97107,"info_way_arhara_limansk_generators")
     sak.out_new_lc(97108,"info_way_arhara_forest_warlab")
     sak.out_new_lc(97109,"info_way_arhara_dcity_limansk")
     sak.out_new_lc(97110,"info_way_arhara_dead_city_atp")
     sak.out_new_lc(97111,"info_way_arhara_dcity_rostok")
     sak.out_new_lc(97112,"info_way_arhara_atp_dead_city")
     sak.out_new_lc(97113,"info_way_arhara_dcity_zaton")
     sak.out_new_lc(97114,"info_way_arhara_lima_dcity")
        
        --level_changers section
        local lname = level.name()
        local sname = amk.load_variable("level_on_save","")

    if (amk_offline_alife) then
                amk_offline_alife.update_npc_tables()
        end
        if (amk_corpses) then
                amk_corpses.update_all_corpses()
        end
        if lname ~= sname and amk_objects then 
                amk_objects.update() 
        end
        
        -- іададим сооб ения при переходе на уровень.
        if news_main then
                if (lname ~= sname and sname ~= "") then
                        if (news_main.isIsolatedLevel(lname)== true and news_main.isIsolatedLevel(sname) == false) then -- Tпустились под землі.
                                news_main.on_disconnect()
                        elseif (news_main.isIsolatedLevel(lname) == false and news_main.isIsolatedLevel(sname) == true) then -- Tvбрались из-под земли.
                                news_main.on_connect()
                        end
        end
  end

        if (amk_offline_alife) then
                amk_offline_alife.update_trade()
        end

        if lname=="l01_escape" and sname=="l04_darkvalley" then
                local obj = alife():story_object(6002)
                if not obj then
                        alife():create(alife():spawn_id(6002))
                end
        end
  
        if sname=="l01_escape" and lname=="l04_darkvalley" then
                db.actor:set_actor_position(vector():set(-44.38, 0.43, -541.47))
        end
  
        --[[spots section
        obj = alife():story_object(6001)
        if obj then
                level.map_add_object_spot(obj.id, "level_changer3", "to_pripyat")
        end
        obj = alife():story_object(6002)
        if obj then
                level.map_add_object_spot(obj.id, "level_changer2", "to_darkvalley")
        end]]
        if weather_types[lname]==0 then
                w=amk.load_variable("dynweather",nil) or level.get_weather() 
        else
                w=level.get_weather() 
        end
        if amk.load_variable("blowout",0)>0 then amk.save_variable("weather",level.get_weather()) end
        level.set_weather("amk_for_blow",true)
        game.start_tutorial("restore_sun")
end

function restore_sun()
  --update_anoms()
        --amk_anoms.init()
        local lname = level.name()
        local sname = amk.load_variable("level_on_save","")
  amk.save_variable("level_on_save",lname)
--      if amk.load_variable("blowout",0) == 0 then
                level.set_weather(w,true)
--      end
--[=[
        if amk.load_variable("blow_started", 0) == 0 then
                start_blow_timer() amk.save_variable("blow_started", 1)
        end
--      if tmp_intro then
--              tmp_intro = false
--      end
        -- Tид ++ после смерти в его собственной броне
        local npc_SP = db.actor
        local outfit = npc_SP:item_in_slot(6)
        if outfit ~= nil then
                local outfit_name = outfit:section()
                local outfit_cond = outfit:condition()
                alife():release(alife():object(outfit:id()), true)
                outfit = alife():create(outfit_name, npc_SP:position(), npc_SP:level_vertex_id(), npc_SP:game_vertex_id(), npc_SP:id())
                if outfit ~= nil then
                        amk.start_timer("outfit_cond", 1, {outfit.id, math.min(math_ceil(outfit_cond * 100), 100)})
                end
        end
--]=]
end
  
--[[    local lname = level.name()
        local sname = amk.load_variable("level_on_save","")
  amk.save_variable("level_on_save",lname)
  if sname=="l12_stancia_2" and lname=="l11_pripyat" then
    ogse_sleep_mgr.begin_sleep(1)
  end
        
        if amk.load_variable("blow_started",0)==0 then
                start_blow_timer()
                amk.save_variable("blow_started",1)
        end
        if tmp_intro then
                --amk.send_tip(game.translate_string("amk_welcome_msg"),game.translate_string("amk_welcome_title"),nil,35,"monolith")
                tmp_intro=false
        end
        sync_done=true  
end]]


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      SLEEP_AMK          **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function test_for_need_sleep( add )
end

function test_for_need_sleep_tr_item(oid)
        if alife():object(oid)==nil then
            if news_main then
              news_main.create_treasurebox()
            end
        end
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **      RADAR_FIX         **   **   *
--'****************************************************************************


function check_radar_off()
  ogse_signals.get_mgr():reschedule( 1000 )
  if not has_alife_info( "bar_deactivate_radar_done" ) then
    local pos = db.actor:position()
    if pos.z > 65 and pos.x > 350 and pos.x < 410 then
      if amk.load_variable( "radar_fix", 0 ) == 0 then
        level.add_pp_effector( "fire_hit.ppe", 1523, true )
        level.set_pp_effector_factor( 1523, 0.5 )
        amk.save_variable( "radar_fix", 1 )
        amk.start_timer( "radar_fix", 5 )
      end
    end
  end
end


function radar_fix()
  level.remove_pp_effector( 1523 )
  local pos = db.actor:position()
  if pos.z > 65 and pos.x > 350 and pos.x < 410 then
    db.actor:kill( db.actor )
  end
  amk.del_variable( "radar_fix" )
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      ITEM_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************

local tramsform_items = {
        ["item1"] = {info = "info_portion_1", result = {"item_out_1", "item_out_2", "item_out_3", "item_out_4"}},
        ["item2"] = {info = "info_portion_2", result = {"item_out_2"}},
        ["kaktus_izomorf"] = {info = "kaktus_izo_resept", result = {"bloodsucker_effector", "af_spirit_4", "af_arhara_globus", "mutant_krovosos_cocoon"}},
        ["izom_globus"] = {info = "kaktus_izo_resept", result = {"bomba_mina_n", "af_babka_3", "af_spirit_4", "device_teleport"}},
        ["psevdokristall"] = {info = "kaktus_izo_resept", result = {"af_spirit_3", "af_babka_2", "wpn_m4", "device_teleport"}},
        ["izomorf_plastilin"] = {info = "molniya_plastilin_ok_start", result = {"korobka_sigars", "ammo_5.45x39_izomorf", "ammo_7.62x54_izomorf", "ammo_zhekan_izomorf"}},
     ["korobka_sigars"] = {info = "kluch_poluchen", result = {"9x39_izomorf", "ammo_9x39_izomorf", "ammo_9x39_izomorf", "ammo_9x39_izomorf"}}
}


-- проверка на упавший предмет/артефакт
function check_for_item_drop( obj )
  if not level.get_inventory_wnd():IsShown() then return end
  local obj_sect = obj:section()
  local actor    = db.actor
  if
    tramsform_items[ obj_sect ]
    and actor:has_info( tramsform_items[ obj_sect ].info )
  then
    local lv = obj:level_vertex_id()
    local gv = obj:game_vertex_id()
    if gv == 65535 then gv = actor:game_vertex_id() end
    if gv == 65535 then return end -- похоже, что рядом нету вертекса
    -- предмет подходит - отправляем его на экспертизу
    -- узнаем не съели ли его или вvложили в нvчку
    local tbl = {}
    tbl.obj_id = obj:id()
    tbl.lv     = lv
    tbl.gv     = gv
    dsh.timeout( 200, function()
      timer_drop_obj_transform( tbl )
    end )
  end
end


function timer_drop_obj_transform( tbl )
  local sobj = alife():object( tbl.obj_id )
  if not sobj then return end
  if sobj.parent_id == 65535 then
    -- выбросили
    -- запускаем трансформацию предмета
    local obj = level.object_by_id( tbl.obj_id )
    if obj then
      amk_mod.item_transform( tbl.obj_id, tbl.lv, tbl.gv )
    end
  end
end


function item_transform( obj_id, lv, gv )
  local obj = level.object_by_id( obj_id )
  if obj then
    level.add_pp_effector( "teleport.ppe", 1524, false )
    local result = tramsform_items[ obj:section() ].result
    local position = obj:position()
    for i = 1, #result do
      amk.spawn_item( result[ i ], position, gv, lv )
    end
    amk.remove_item( obj )
  end
end


--'*****************************************************************************
--'   **   **   **   **   **    **   **   **      AF_TRANSFORM
--'*****************************************************************************
local cur_level, havegoodart


-- проверка на упавший предмет/артефакт
function check_for_af_drop( obj )
  if not level.get_inventory_wnd():IsShown() then return end
  local obj_sect = obj:section()
  -- проверка не один ли это из компонентов
  if is_komponent( obj_sect ) then
    local anom_id, anom_pos, anom_radius, dist =
      amk_anoms.get_nearest_anomaly( obj )
    if anom_id and anom_radius - dist > -2 then
      local a_obj = level.object_by_id( anom_id )
      local lv    = a_obj:level_vertex_id()
      local gv    = a_obj:game_vertex_id()
      if gv == 65535 then gv = obj:game_vertex_id() end
      if gv == 65535 then gv = db.actor:game_vertex_id() end
      if gv == 65535 then return end -- похоже, что рядом нету вертекса
      -- предмет подходит - отправляем его на экспертизу
      -- узнаем не съели ли его или вvложили в нvчку
      local tbl = {}
      tbl.obj_id      = obj:id()
      tbl.anom_id     = anom_id
      tbl.anom_radius = anom_radius
      tbl.lv          = lv
      tbl.gv          = gv
      dsh.timeout( 200, function()
        timer_drop_obj_varka( tbl )
      end )
    end
  end
end


function timer_drop_obj_varka( tbl )
  local sobj = alife():object( tbl.obj_id )
  if not sobj then return end
  if sobj.parent_id == 65535 then
    -- выбросили
    -- запускаем проверку на рецепт и, если успешно, варку
    local obj  = level.object_by_id( tbl.obj_id )
    local anom = level.object_by_id( tbl.anom_id )
    if obj and anom then
      -- если чего само выпадет или будет вброшено в игру скриптом при переходе
      -- ГГ между уровнями, то obj == nil и аномалии тоже не будет
      local obj_sect  = obj:section()
      local obj_pos   = obj:position()
      local anom_sect = anom:section()
      local anom_pos  = anom:position()
      check_af_transform(
        obj, obj_sect, obj_pos, tbl.anom_id, anom_sect, anom_pos,
        tbl.anom_radius, tbl.lv, tbl.gv
      )
    end
  end
end


-- проверка: является ли компонентом для варки
-- параметр - название секции
function is_komponent( sect, recept )
  if not recept then recept = afs end
  local prop = amk_utils.get_item_props( sect )
  for _, aka in ipairs( prop.aliases ) do
    if recept[ aka ] == true then return true end
  end
  return false
end


-- возвра ает значение, возможно из умолчаний
function get_af_transform_param(name, recept, recepti)
        local result
        --get_console():execute("load ~#I#:"..string.format(name.." имя"))
        if recept[name] ~= nil then
                result = recept[name]
        elseif recepti["default"] ~= nil and recepti["default"][name] ~= nil then
                result = recepti["default"][name]
        elseif anom_recept_komp["default"] ~= nil and anom_recept_komp["default"][name] ~= nil then
                result = anom_recept_komp["default"][name]
        else
                -- нет информации!!!
                amk.send_tip("нет информации для "..name.."!","варка артефактов",0,15,"gen_info")
                result = nil
        end
        return result
end

-- іолучаем полнvй набор рецептов для аномалии anom_sect
function fill_recepti_est(anom_sect)
        local recepti_est = {} -- рецептv для заданной аномалии
        local anom_name = nil
        for anom, recepti in pairs(anom_recept_komp["anomalii"]) do
                if string_find(anom_sect, anom) ~= nil then --нашли в списке аномалиі.
                        anom_name = anom_recept_komp["anomalii"][anom]["name"]
                        if anom_recept_komp["anomalii"][anom]["recepti"] then
                                for info, recept in pairs(recepti["recepti"]) do
                                        if not recept["not_for_mutator"] and not recept["remove_anomaly"] and db.actor:has_info(info) then
                                                -- есть рецепт: заносим в таблицу
                                                recepti_est[info] = {}
                                                for k, v in pairs(recept) do
                                                        if type(v) == "table" then
                                                                recepti_est[info][k] = {}
                                                                for i, j in pairs(v) do
                                                                        recepti_est[info][k][i] = j
                                                                end
                                                        else
                                                                recepti_est[info][k] = v
                                                        end
                                                end
                                        end
                                end
                        end
                end
        end
        return recepti_est,anom_name
end


-- проверяет рецептv и компонетv
-- если всї в порядке - запускает варку/мутациі
function check_af_transform( af, af_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv )
  --поиск по аномалиям
  local finish = false -- флаг для вvхода из циклов
  for anom, recepti in pairs( anom_recept_komp[ "anomalii" ] ) do
    --нашли в списке аномалиі, возле которой стоим
    if string.find( anom_sect, anom ) then
      -- рецептv в наличии у ++, в которvх участвует даннvй компонент
      local recepti_est     = {}
      local recept_podhodit = false
      -- собираем рецептv, в которvх участвует даннvй компонент
      for info, recept in pairs( recepti[ "recepti" ] ) do
        --есть рецепт и этот компонент в нїм участвует
        if
          db.actor:has_info( info )
          and is_komponent( af_sect, recept[ "komp" ] )
        then
          recept_podhodit = true
          -- копируем рецепт
          recepti_est[ info ] = {}
          for k, v in pairs( recept ) do
            if type( v ) == "table" then
              recepti_est[ info ][ k ] = {}
              for i, j in pairs( v ) do
                recepti_est[ info ][ k ][ i ] = j
              end
            else
              recepti_est[ info ][ k ] = v
            end
          end
          -- так как table.getn() как и оператор # не работаіт с
          -- таблицами, у которvх не целочисельнvе индексv, то считаем
          -- количество в ручнуі
          local count = 0
          for k, v in pairs( recepti_est[ info ][ "komp" ] ) do
            count = count + 1
          end
          recepti_est[ info ][ "count" ] = count
        end
      end
      -- если нашли хоть один имеіийся подходяий рецепт
      if recept_podhodit then
        --и рядом другие компонентv если находим их в вvбраннvх
        --рецептах, то удаляем их из рецептов как только какой-то
        --рецепт остаїтся без компонентов - рецепт сработал
        for i = 1, 65534 do
          local obj = level.object_by_id( i )
          if obj and alife():object( i ) and not obj:parent() then
            local dist = obj:position():distance_to( anom_pos )
            if
              ( anom_radius - obj:position():distance_to( anom_pos ) ) > -2
            then
              local obj_sect = obj:section()
              --проверяем отобраннvе рецептv
              for info, recept in pairs( recepti_est ) do
                -- если компонент есть в рецепте
                if is_komponent( obj_sect, recepti_est[ info ][ "komp" ] ) then
                  -- добавляем L- компонента для буду его удаления из игрv
                  recepti_est[ info ][ "komp" ][ obj_sect ] = obj:id()
                  -- уменьшаем количество компонентов в рецепте
                  recepti_est[ info ][ "count" ] =
                    recepti_est[ info ][ "count" ] - 1
                  -- если рецепт пуст, то он сработал
                  if recepti_est[ info ][ "count" ] == 0 then
                    -- устанавливаем все параметрv для рецепта, возможно из умолчаний
                    local cel      = get_af_transform_param(
                      "cel", recepti_est[ info ], recepti
                    )
                    local v_udachi = get_af_transform_param(
                      "v_udachi", recepti_est[ info ], recepti
                    )
                    local v_virogd = get_af_transform_param(
                      "v_virogd", recepti_est[ info ], recepti
                    )
                    local virogd   = get_af_transform_param(
                      "virogd", recepti_est[ info ], recepti
                    )
                    local vremya   = get_af_transform_param(
                      "vremya", recepti_est[ info ], recepti
                    )
                    local komp     = recepti_est[ info ][ "komp" ]
                    local remove_anomaly    = get_af_transform_param(
                      "remove_anomaly", recepti_est[ info ], recepti
                    )
                    local remove_anomaly_id = anom_id
                    local result, udacha    = af_select_result(
                      v_udachi, v_virogd, virogd, cel, komp
                    )
                    local info_portion      = recepti_est[ info ][ "info" ]
                    if
                      cel == nil or v_udachi == nil or v_virogd == nil
                      or virogd == nil or vremya == nil or remove_anomaly == nil 
                      or cel == nil and remove_anomaly == false
                      or v_udachi + v_virogd > 100
                    then
                      -- кривой рецепт  - вvходим
                      finish = true
                      break
                    end
                    -- неудача
                    if udacha == false then
                      remove_anomaly = false
                      info_portion   = nil
                    end
                    level.add_pp_effector( "teleport.ppe", 1524, false )
                    -- запускаем варку/мутациі
                    as_start_universal_transform_timer(
                      komp, result, udacha, obj_pos, vremya, gv, lv,
                      info_portion, remove_anomaly, remove_anomaly_id
                    )
                    -- удаляем из игрv компонентv рецепта
                    db.actor:give_info_portion( "biznes_remove_special_item" )
                    for k, v in pairs( komp ) do
                      alife():release( alife():object( v ) )
                    end
                    db.actor:disable_info_portion( "biznes_remove_special_item" )
                    -- вvходим
                    finish = true
                    break
                  end
                end
              end
            end
          end
          if finish then break end
        end
      end
      -- аномалия с рецептами найдена, все дела сделанv - вvходим
      break
    end
  end
end


function af_flash(af)
        level.add_pp_effector("teleport.ppe", 1524, false)
        amk.remove_item(af)
end


-- случайно вvбирает результат, возвра ает таблицу с секциями результатов
function af_select_result( v_udachi, v_virogd, virogd, cel, komp )
  local rnd = dsh.get_next_random(
    script_name() .. ".af_select_result.rnd", 0, 100
  )
  if rnd > v_udachi then --неудача
    if rnd > v_virogd + v_udachi then -- отторжение
      return komp, false
    else -- вvрождение
      return virogd, false
    end
  else -- удача
    return cel, true
  end
end


-- запускаем трансофрмациі результатv могут бvть многочисленнv
-- (несколько целей, полное отторжение компонентов, несколько
-- вvрождений)
function as_start_universal_transform_timer( komp, result, udacha, pos, vremya, gv, lv, info_portion, remove_anomaly, remove_anomaly_id )
  local t = { } -- сохраняемvе даннvе
  t.result = result -- можно сохранять сразу таблицv
  t.udacha = udacha
  t.pos    = {}
  t.pos.x  = pos.x
  t.pos.y  = pos.y
  t.pos.z  = pos.z
  t.gv     = gv
  t.lv     = lv
  t.info_portion = info_portion
  t.komp   = komp -- можно сохранять сразу таблицv
  t.remove_anomaly    = remove_anomaly
  t.remove_anomaly_id = remove_anomaly_id
  dsh.begin_af_transform( vremya[ 1 ], vremya[ 2 ], vremya[ 3 ], t )
end


-- старая фунция
function af_start_transform(v1,v2,af_from,af_target)
        local rnd=math_random(0,100)
        if rnd>v1 then
                if rnd>v2+v1 then
                        return af_from
                else
                        return "af_buliz"
                end
        else
                return af_target
        end
end

-- старая фунция
function af_start_transform_timer(af,pos,delay_d,delay_h,delay_m,af_sect)
        local t={}
        t.section=af
        t.pos={}
                t.pos.x=pos.x
                t.pos.y=pos.y
                t.pos.z=pos.z
        t.gv=gv
        t.lv=lv
        t.from_sect=af_sect
        amk.g_start_timer("af_transform",delay_d,delay_h,delay_m,t)
end


-- завершаем варку/мутациі
-- может бvть много результатов
function af_transform_universal_end( params )
  -- если есть результатv
  local af_sobj
  if table.getn( params.result ) > 0 then
    local anom_pos = vector():set( params.pos.x, params.pos.y, params.pos.z )
    if
      level.name() == params.lname
      and db.actor:position():distance_to( anom_pos ) < 15
    then
      level.add_pp_effector( "teleport.ppe", 1524, false )
    end
    -- формируем строку с названиями компонентов
    local from_komp = {}
    for _, k in ipairs( params.komp ) do
      table.insert( from_komp, game.translate_string( amk.get_inv_name( k ) ) )
    end
    -- спавним результат(v)
    for _, k in ipairs( params.result ) do
      -- спавн поднят на 10 метров, чтоб победить проваливание под текстуры
      af_sobj = amk.spawn_item(
        k,
        vector():set( params.pos.x, params.pos.y + 10, params.pos.z ),
        params.gv, params.lv
      )
      amk.add_spot_on_map(
        af_sobj.id, "red_location",
        game.translate_string( "trans_finished_title" )
          .. " из %c[255,255,0,0]" .. table.concat( from_komp, ", " )
      )
      if dsh.is_artefact( k ) then
        dsh.handmade_arts_cnt( 1 )
        if params.udacha then
          archievements.acv_count_event( "acv_art", 100, "Сварщик" )
        end
      end
    end
    amk.send_tip(
      game.translate_string( "trans_finished_title" )
        .. " из %c[255,255,0,0]" .. table.concat( from_komp, ", " )
    )
  end

  -- даїм инфопорциі, если есть
  if params.info_portion and db.actor:dont_has_info( params.info_portion ) then
    db.actor:give_info_portion( params.info_portion )
  end

  -- удаляем аномалии, если нужно и она не в исклічениях
  -- код взят из amk_anoms.turn_off_all()
  if params.remove_anomaly then
    local sobj = alife():object( params.remove_anomaly_id )
    if sobj and game_graph():valid_vertex_id( sobj.m_game_vertex_id ) then
      local map = object_level_name( sobj )
      if not amk_anoms.check_exclusion( sobj, map ) then
        local status = amk_anoms.get_anomaly_status( sobj )
        if status == "" or status == "on" then
          amk_anoms.set_anomaly_status( sobj, "del" )
          alife():release( sobj, true )
        end
      end
    end
  end
  return af_sobj
end


-- старая функция
function af_transform_end(params)
        local from_sect="\""..params.from_sect.."\""
        local obj
        obj=amk.spawn_item(params.section,vector():set(params.pos.x,params.pos.y+10,params.pos.z),params.gv,params.lv)
        amk.add_spot_on_map(obj.id,"red_location",game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
        amk.send_tip(game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **    AMK_METKA     **   **   **   **   **    **   **   **   **
--'*******************************************************************************
local beakons={}
function check_beacon_drop(obj)
        local sim=not (alife()==nil)
        local actor=db~=nil and db.actor~=nil
        local lp=level.present()
        local dp=device()==nil or device():is_paused()
        if obj:section()=="amk_metka" and not has_alife_info("biznes_remove_special_item") then
                beakons[obj:id()]=true
        end
end

function check_metka()
        for id,v in pairs(beakons) do
                local obj=level.object_by_id(id)
                if obj then
                        beakons[id]=nil
                        if obj:parent()==nil then
                                local spwn=ui_dots.dots(get_hud(),id)
                                level.start_stop_menu(spwn,true)
                        end
                end
        end  
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **   **      BLOWOUT        **   **
--'****************************************************************************


local blowout_phantoms_subscribed

function blowout_phantoms()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() < 2 and blow > 1 and blow < 4 then
    local lname    = level.name()
    local phantoms = amk_hideouts.blowouts_phantoms[ lname ]
    if phantoms and phantoms.count > 0 then
      if blowout_phantoms_subscribed then
        ogse_signals.get_mgr():reschedule( 1000 )
        if not in_hide then
          if math.random() < phantoms.probability then
            if phantom_manager:phantom_count() < phantoms.count then
              local yaw = math_pi * 2.0 * math.random()
              local radius = phantoms.radius * ( math.random() / 2.0 + 0.5 )
              local height = phantoms.height * math.random()
              local a_pos  = db.actor:position()
              local pos    = vector():set(
                math.sin( yaw ) * radius + a_pos.x,
                a_pos.y + height,
                math.cos( yaw ) * radius + a_pos.z
              )
              phantom_manager.spawn_phantom( pos )
            end
          end
        end
      else
        blowout_phantoms_subscribed = {
          signal = "on_update", fun = this.blowout_phantoms,
          script_name = script_name(),
        }
        ogse_signals.get_mgr():subscribe( blowout_phantoms_subscribed )
      end
    end
  elseif blowout_phantoms_subscribed then
    ogse_signals.get_mgr():unsubscribe( blowout_phantoms_subscribed )
    blowout_phantoms_subscribed = nil
  end
end


function blowout_scary_sounds()
        local blow=amk.load_variable("blowout",-1)
        if blow>0 and blow<4 then
                local snd_obj = xr_sound.get_safe_sound_object(amk_hideouts.blowout_sounds[math_random(#amk_hideouts.blowout_sounds)])
                local a=vector()
                a.x=math_random(0,10)
                a.y=math_random(0,10)
                a.z=math_random(0,10)
                snd_obj:play_at_pos(db.actor, db.actor:position():add(a))
                amk.start_timer("blowout_ss",math_random(10,30),0)
        end
end

function blowout_psy_sound(action)
        if action=="start" then
                snd_obj_eq = sound_object([[ambient\earthquake]],sound_object.looped+sound_object.s2d)
    snd_obj_eq:play(db.actor, 4, sound_object.looped+sound_object.s2d)
        end
        if action == "stop" then
                if snd_obj_eq then snd_obj_eq:stop() end
        end
        
        local lname=level.name()
        if not amk_hideouts.blowouts_phantoms[lname] then return end
        local psy_sound=amk_hideouts.blowouts_phantoms[lname].psy_sounds or false       
        if not psy_sound then return end

        if action=="start" then
                local level_vol=amk_hideouts.blowouts_phantoms[lname].level_vol or 1                            
                sound_obj_right, sound_obj_left = xr_sound.get_sound_object("psy_voices", "random")
                sound_obj_left:play_at_pos (db.actor, vector():set(-1, 0, 1), 0, sound_object.s2d + sound_object.looped)
                sound_obj_right:play_at_pos(db.actor, vector():set( 1, 0, 1), 0, sound_object.s2d + sound_object.looped)
                snd_volume      = level.get_snd_volume()
                level.set_snd_volume( level_vol )
        end
        if action == "stop" then
                if sound_obj_left then sound_obj_left:stop() end
                if sound_obj_right then sound_obj_right:stop() end
                if snd_volume then level.set_snd_volume(snd_volume) end
        end     
end

function Run_Blowout_pp()
end

function Run_Blowout_pp_old()
if game_options.run_blowout_pp == 1 then
                local bt=blowout_type()
                if bt==2 then start_blow_timer() return end
                sleep_manager.stopper()
                amk.save_variable("blowout",1)
                if bt<1 then
                        level.add_pp_effector("monolith_off.ppe", 2003, false)
                        level.add_cam_effector("camera_effects\\shell_shock.anm", 2004, false, "")
                        local snd_obj = xr_sound.get_safe_sound_object([[ambient\organic_moan1]])
                        snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
                end
                amk.start_timer("blowout_ss",math_random(5,15),0)
                amk.start_timer("blowout",11,0)
                dsh.blowout_modif_arts()
        end
        start_blow_timer()
end

function start_blow_timer()
end

function Blowout_pp(phase)
---------------------------------------------------
--' TimeFactor = 5
--' GameMin = 12 RealSec
--' TimeBlowout = 184 RealSec

--' начало (Timer = 36 sec)
--' первая фаза (Timer = 36 sec)
--' вторая фаза (Timer = 36 sec)
--' Tретья фаза (Timer = 36 sec)
--' четвертая фаза (Timer = 60 sec)
--' конечная фаза (Timer = 0 sec)
---------------------------------------------------

        amk.mylog("blowout "..phase)
local basis = game_options.blow_phase_basis
local shift = game_options.blow_phase_shift
local max = game_options.blow_phase_max
local resuls = basis + (math_random()*shift) - (shift/2)
if resuls < 1 then resuls = 1 elseif resuls > max then resuls = max end
local blow = amk.load_variable("blowout", 0)
local bt=blowout_type()
if blow > 0 and blow < 4 and bt == 2 then amk.g_start_timer("blowout", 0, 0, 3, 4) end
        if phase==0 then
                db.actor.blowout_outside = true
                amk_anoms.pre_blow_off()
                if bt<1 then
                        level.set_weather("pre_blow",true)
                        level.set_weather_fx("amk_surge_day")
                end 
amk.g_start_timer("blowout", 0, 0, resuls, 1)
                elseif phase==1 then
                local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
                snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
                level.add_cam_effector("camera_effects\\earthquake.anm", 2002, true, "")
                snd_obj = xr_sound.get_safe_sound_object([[anomaly\blowout]])
                snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
                blowout_psy_sound("start")
                if bt < 1 then
                        level.add_pp_effector("vibros.ppe", 2001, true)
                end
                in_hide=false
amk.g_start_timer("blowout", 0, 0, resuls, 2)
                amk.save_variable("blowout",2)  
        elseif phase==2 then
                amk.g_start_timer("blowout",0,0,3,3)
        elseif phase==3 then
                amk_anoms.after_blow_on()
                sak.off_testobj()
                amk.save_variable("blowout",3)
                local h = hit()
                local cr
                h.type = hit.strike
                h.power = 1000
                h.impulse = 1000
                for a=1,65534,1 do
                        cr=level.object_by_id(a)
                        if cr~=nil and cr:section()=="m_crow" and math_random(0,100)<70 then
                                h.draftsman = cr
                                h.direction = cr:direction()
                                cr:hit(h)
                        end
                end
amk.g_start_timer("blowout", 0, 0, resuls, 4)
        elseif phase==4 then
                amk.save_variable("blowout",4)
                level.remove_cam_effector(2002)
                if bt<1 then
                        level.remove_pp_effector(2001)
                        level.add_pp_effector("monolith_off.ppe", 2003, false)
                end
                blowout_psy_sound("stop")
                amk.start_timer("blowout",5,5)
        elseif phase==5 then
                level.set_weather(amk.load_variable("weather","default1"))
                if bt<1 then
                        local snd_obj = xr_sound.get_safe_sound_object([[anomaly\teleport_work2]])
                        snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
                end
                amk.del_variable("blowout")
        if game_options.zombie_team == 1 then
            tag_spb.zombie_team()
        end 
                if db.actor.blowout_outside then
                        archievements.acv_count_event("acv_blow", 5, "Выброшенный")
                        db.actor.blowout_outside = nil
                end
                amk.start_timer("autosave_blowout", 10, "") -- autosave
        end
end


local blowout_hit_subscribed

function on_blowout_hit_actor()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() == 0 and blow > 1 and blow < 4 then
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():reschedule( 1000 )
      on_blowout_hit( db.actor )
    else
      blowout_hit_subscribed = {
        signal = "on_update", fun = this.on_blowout_hit_actor,
        script_name = script_name(),
      }
      ogse_signals.get_mgr():subscribe( blowout_hit_subscribed )
    end
  else
    in_hide = true
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():unsubscribe( blowout_hit_subscribed )
      blowout_hit_subscribed = nil
    end
  end
end


function on_blowout_hit( npc, hide )
        local bt=blowout_type()
        if bt>0 or amk.load_variable("blowout",-1)~=3 then 
                if npc:id()==db.actor:id() then in_hide = true end
                return false
        end
        
        local lname=level.name()
        local need_hit
        need_hit=true
        local khit=1
        if hide and hide.zone then
                need_hit = not check_npc_in_hideout(npc,hide)
                if not need_hit then
                        if hide.defence then 
                                khit=hide.defence
                        else
                                khit=0
                        end
                end
        else
                local hides=amk_hideouts.hide[lname]
                local tmp
                if hides then
                        for i,o in ipairs(hides) do
                                if o.zone then
                                        for j,v in ipairs(o.zone) do
                                                if v.p3 then
                                                        tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
                                                else
                                                        tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
                                                end
                                                need_hit = need_hit and not tmp
                                                if tmp then
                                                        if o.defence then 
                                                                khit=o.defence
                                                        else
                                                                khit=0
                                                        end
                                                end
                                        end
                                end
                        end
                end
        end

    if npc:id()==db.actor:id() then
                if not need_hit then
                        db.actor.blowout_outside = nil
                end
                if outfit_hideout() then -- защита от выброса броником
                        need_hit = false
                        khit = 0
                else
                        khit = khit+khit*level.get_game_difficulty()/6  -- усиление хита для актора, чтобы вне укрытия не пережил
                end
                in_hide = not need_hit
        end
    if (need_hit or khit>0) and amk.load_variable("blowout",-1)==3 and not (hide and hide.hidden) then
                local h = hit()
        h.power = (amk_hideouts.blowout_damages[lname] or 0.01)*khit
        h.impulse = 0
                h.draftsman = npc
                h.direction = vector():set(0,0,0)
                h:bone("bip01_spine") -- чтобv учитvвалась броня
        h.type = hit.strike
                npc:hit(h)
        h.type = hit.telepatic
                npc:hit(h)
        h.type = hit.radiation
                npc:hit(h)
    end
    return need_hit or khit>0
end


function outfit_hideout()
        local outfits = {
                ["gagarin_outfit"] = true,
                ["gagarin_outfit_m1"] = true,
                ["voshod_outfit"] = true,
                ["exo_knight_outfit"] = true
        }
        return db.actor:item_in_slot(6) and outfits[db.actor:item_in_slot(6):section()]
end

function check_npc_in_hideout(npc,hide)
        local not_in_zone=true
        if hide and hide.zone then
                for k,v in pairs(hide.zone) do
                        if v.p3 then 
                                not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
                        else
                                not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
                        end
                end
        end
        return not not_in_zone
end

function initial_spawn(action)
        local fr=0
        for i=0,amk_hideouts.anom_count-1,1 do
                local sobj = alife():story_object(amk_hideouts.anom_sid0+i)
                if not sobj then 
                        alife():create(i+amk_hideouts.anom_num0) 
                        fr=1
                end
        end
        if fr==1 then create_anoms() end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       ANOMS SPAWN        **   **   **   **   **    **   **   **   
--'*******************************************************************************
anomalies_state={}

function remove_anoms()
        amk.save_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
        update_anoms()
end

function create_anoms()
        anomalies_state={}
        for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
                anomalies_state[i]=math_random(0,1)==1
        end
        local str=pack_anoms(anomalies_state)
        amk.save_variable("blowout_anoms",str)
        update_anoms()
end

function update_anoms()
        local anoms=amk.load_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
        anomalies_state=unpack_anoms(anoms)
        for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
                local sobj=alife():story_object(i)
                if sobj then
                        local obj=level.object_by_id(sobj.id)
                        if obj then
                                if anomalies_state[i] then
                                        obj:enable_anomaly()
                                else
                                        obj:disable_anomaly()
                                end
                        end
                end
    end
end

-- anom_state[sid]==true для активнvх аномалий
function pack_anoms(anom_state)
        local str=""
        for i=0,amk_hideouts.anom_count-1,7 do
                local cval=128
                local mul=1
                for j=0,6,1 do
                        if anom_state[i+j+amk_hideouts.anom_sid0] then
                                cval=cval+mul
                        end
                mul=mul*2
                end
    str=str..string.char(cval)
        end
        return str
end

function unpack_anoms(str)
        local anom={}
        for i=1,string.len(str),1 do
                local cval=string.byte(string_sub(str,i,i))
                local mul=1
                for j=0,6,1 do
                        anom[(i-1)*7+j+amk_hideouts.anom_sid0]=bit_and(mul,cval)~=0
                        mul=mul*2
                end
        end
        return anom
end

function blowout_type()
        local lname=level.name()
local blow_type = amk_hideouts.blowout_types[lname]
return blow_type or 0
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **    **      RECEPTS       **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function check_usable_item(obj)
        local info=nil
        if obj:section()=="vehicle_btr" then
                db.actor:kill(db.actor)
        end
        if obj:name()=="mil_stalker0012" then
                info="info_amk_recipt_stone_dikoobraz"
        elseif level.name()=="l01_escape" and obj:section()=="amk_zapiska" then
                info="info_amk_recipt_shkura"
                amk.drop_item(db.actor,obj)
                amk.remove_item(obj)
        elseif level.name()=="l04u_labx18" and obj:section()=="amk_zapiska" then
                info="info_amk_recipt_simbion"
                amk.drop_item(db.actor,obj)
                amk.remove_item(obj)
        elseif level.name()=="l08u_brainlab" and obj:section()=="amk_zapiska" then
                local infos = {
                                "info_amk_recipt_dummy",
                                "info_amk_recipt_dummy_fire",
                                "info_amk_recipt_dummy_bright",
                                "info_amk_recipt_dummy_moon",
                                "info_amk_recipt_dummy_puding"
                                }
                amk.drop_item(db.actor,obj)
                amk.remove_item(obj)
                if db.actor==nil then
                        return
                end
                local info_given = false
                for i=1,#infos do
                        local inf = infos[i]
                        if db.actor:dont_has_info(inf) then
                                db.actor:give_info_portion(inf)
                                info_given = true
                        end
                end
                if info_given then
                        amk_dialogs.info_received()
                end
                return
        else
                local recipes=amk.load_table("amk_body_recipe")
                info=recipes[obj:id()]
        end  
        if db.actor==nil or info==nil or db.actor:has_info(info) then
                return
        end
        db.actor:give_info_portion(info)
        amk_dialogs.info_received()
end

function generate_recipe(obj)
        if obj and IAmAMonster[obj:clsid()] then
                return
        end
        local info=nil
        local prop=100
  if level.name()=="l07_military" and obj.character_community and
          obj:character_community()=="killer" then
                info="info_amk_recipt_titan_kolobok"
                prob=30
  elseif (level.name()=="l10_radar" or level.name()=="l11_pripyat") and obj.character_community and
          obj:character_community()=="monolith" then
                info="info_amk_recipt_controller_skalp"
                prob=30  
        end
        if not info then return end
        local recipes=amk.load_table("amk_body_recipe")
        -- іроверим не генерился ли уже этот рецепт
        for k,v in pairs(recipes) do
                if v==info then
                        return
                end
        end
        -- Tгенерим рецепт
        if math_random(100)<=prob then
                recipes[obj:id()]=info
                amk.save_table("amk_body_recipe",recipes)
        end
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **     SPAWN_OBJ        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************
function spawn_fuel()
        local ballons = {
        {108.16, -6.30, -18.17, 412158, 115},
        {370.12, 15.06, -39.48, 594401, 0},
        {58.30, 19.36, 156.50, 345136, 97},
        {-92.21, -1.18, -212.66, 115177, 268},
        {-74.17, 1.80, 8.45, 127766, 329},
        {3.18, 1.24, 42.48, 243919, 490},
        {15.35, -1.90, 2.40, 255433, 479},
        {77.54, 0.30, -108.47, 312366, 427},
        {-145.54, -0.00, -199.61, 92520, 650},
        {-130.08, 10.00, -196.67, 109214, 629},
        {-140.13, 10.00, -197.94, 98647, 629},
        {37.28, 1.02, -49.90, 220638, 1084},
        {476.68, -46.94, -0.23, 155714, 1919},
        {76.80, -2.54, -23.93, 36304, 1970},
        {94.78, 0.03, -6.88, 88986, 1514},
        {-3.24, -11.75, -263.07, 33794, 1448}
        }
        local kanisters = {
        {-293.80, -14.18, -15.36, 15703, 67},
        {-16.57, 2.48, 58.82, 260308, 88},
        {-74.81, -1.30, 160.52, 196218, 163},
        {-69.94, 0.97, 6.51, 131411, 329},
        {64.01, 0.60, 148.46, 235341, 364},
        {63.29, -0.20, 5.10, 299326, 461},
        {-28.52, -1.04, -181.84, 211644, 676},
        {2.93, -1.88, -13.30, 176553, 1047},
        {41.71, 4.54, -86.36, 227110, 1100},
        {7.90, 1.41, -71.93, 183138, 1041},
        {158.71, -0.76, -259.73, 358950, 962},
        {-342.92, -13.60, 390.01, 11235, 1847},
        {305.22, -36.99, -24.40, 68330, 1930},
        {55.02, 1.17, 40.35, 68094, 1511},
        {-114.14, -0.00, 121.75, 43453, 1315},
        {31.33, 5.60, -13.51, 4683, 1538}
        }
        for k,v in pairs(ballons) do
                if #v == 5 then
                        local obj = alife():create("amk_ballon",vector():set(v[1], v[2], v[3]), v[4], v[5])
                        if obj and is_debug==true then
                                amk.add_spot_on_map(obj.id, "red_location", "ballon")
                        end
                end
        end
        for k,v in pairs(kanisters) do
                if #v == 5 then
                        local obj = alife():create("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
                        if obj and is_debug==true then
                                amk.add_spot_on_map(obj.id, "red_location", "kanistra")
                        end
                end
        end
end

-- +Tі на блокпосту
function spawn_military_btr()
        spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-168.11, -29.71, -303.21),81808,38 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
        spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),17147,14 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
        spawn_military_tech_pack( alife():create("helicopter",vector():set(-150.0,-40.0,-620.0),128298,11 ) ,"helicopter", "scripts\\esc\\esc_blockpost_heli.ltx")
--      spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-189.55,-0.24,-140.49),46901,559),"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--      spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-93.81,0,-185.82),146369,607),"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--  spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-135.49, -30.13, -375.27),115062,20 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--  spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-167.58, -29.48, -364.26),82401,31 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
end

function spawn_military_tech_pack(obj, spawn_item, spawn_item_logic)    
        local packet = net_packet()
        obj:STATE_Write(packet)

        -- свойства cse_alife_object
        local game_vertex_id = packet:r_u16()
        local cse_alife_object__unk1_f32 = packet:r_float()
        local cse_alife_object__unk2_s32 = packet:r_s32()
        local level_vertex_id = packet:r_s32()
        local object_flags = packet:r_s32()
        local custom_data = packet:r_stringZ()
        local story_id = packet:r_s32()
        local cse_alife_object__unk3_s32 = packet:r_s32()

        -- свойства cse_visual
        local model_visual = packet:r_stringZ()
        local cse_visual__unk1_u8 = packet:r_u8()
        local motion_name
        if spawn_item == "helicopter" then
                -- свойства cse_motion
                motion_name = packet:r_stringZ()
        end

        -- свойства cse_ph_skeleton
        local skeleton_name = packet:r_stringZ()
        local cse_ph_skeleton__unk1_u8 = packet:r_u8()
        local cse_ph_skeleton__unk2_u16 = packet:r_u16()
        local health 
        local cse_alife_helicopter__unk1_sz 
        local engine_sound 
                
        if spawn_item == "helicopter" then
                -- свойства cse_alife_helicopter
                cse_alife_helicopter__unk1_sz = packet:r_stringZ()
                engine_sound = packet:r_stringZ()
        elseif  spawn_item == "vehicle_btr" then
                health = packet:r_float()
        end
        
        -- теперь заполняем нужнvе параметрv
        -- свойства cse_alife_object
        packet:w_begin(game_vertex_id)
        packet:w_float(cse_alife_object__unk1_f32)
        packet:w_s32(cse_alife_object__unk2_s32)
        packet:w_s32(level_vertex_id)
        object_flags = bit_not(5)       -- ~5 = 0xfffffffa
        packet:w_s32(object_flags)
        
        packet:w_stringZ("[logic]\ncfg = "..spawn_item_logic)
--[=[   if spawn_item == "helicopter" then
                packet:w_stringZ("[logic]\ncfg = "..spawn_item_logic)
        elseif  spawn_item == "vehicle_btr" then
                packet:w_stringZ("[logic]\ncfg = "..spawn_item_logic)
        end
]=]
        packet:w_s32(-1)
        packet:w_s32(cse_alife_object__unk3_s32)

        -- свойства cse_visual
        packet:w_stringZ(model_visual)
        packet:w_u8(cse_visual__unk1_u8)
        
        if spawn_item == "helicopter" then
                packet:w_stringZ(motion_name)           
        end 
        
        -- свойства cse_ph_skeleton
        skeleton_name = "idle"
        packet:w_stringZ(skeleton_name)
        packet:w_u8(cse_ph_skeleton__unk1_u8)
        packet:w_u16(cse_ph_skeleton__unk2_u16)

        if spawn_item == "helicopter" then
                -- свойства cse_alife_helicopter
                cse_alife_helicopter__unk1_sz = "idle"
                engine_sound = "alexmx\\helicopter"
                packet:w_stringZ(cse_alife_helicopter__unk1_sz)
                packet:w_stringZ(engine_sound)
        elseif  spawn_item == "vehicle_btr" then
                health = 1
                packet:w_float(health)
        end     
        -- считvваем скорректированнvе параметрv
        packet:r_seek(0)
        obj:STATE_Read(packet, packet:w_tell())
        
        return obj
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **       DYNWEATHERS       **   **   **   **    **   **   **   
--'*******************************************************************************
dynweathers={
        clear={
                clear=15,
                pasmurno=85,
                rain=0,
                groza=0
        },
        pasmurno={              
                clear=20,
                rain=20,
                groza=10,
                pasmurno=50     
        },
        rain={
                clear=0,
                groza=35,
                pasmurno=45,
                rain=20
        },
        groza={
                clear=0,
                rain=20,
                pasmurno=65,
                groza=15        
        }
}

function weather_manager()
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       AMK_RESPAWNS     **   **   **   **   **    **   **   **   
--'*******************************************************************************
function switch_monster_online(obj)
        se_monster.need_be_online[obj.id]=true
end

function switch_monster_offline(obj)
        se_monster.need_be_online[obj.id]=false
end


function respawned( obj, respawner )
  if obj and IAmAMonster[ obj:clsid() ] then
    local sini = respawner:spawn_ini()
    if sini:line_exist( "respawn", "creature_binded_logic" ) then
      local t = amk.read_monster_params( obj )
      if ( not t.custom ) or string.len( t.custom ) == 0 then
        local cfg_name = utils.cfg_get_string(
          sini, "respawn", "creature_binded_logic", false, false, false, ""
        )
        t.custom = "[logic]\ncfg = scripts\\amk\\" .. cfg_name .. ".ltx"
        amk.write_monster_params( t, obj )
      end
    end
  elseif obj and IAmAStalker[ obj:clsid() ] then
    local sini = respawner:spawn_ini()
    if sini:line_exist( "respawn", "creature_binded_logic" ) then
      local t = amk.read_stalker_params( obj )
      if ( not t.custom ) or string.len( t.custom ) == 0 then
        local cfg_name = utils.cfg_get_string(
          sini, "respawn", "creature_binded_logic", false, false, false, ""
        )
        t.custom = "[logic]\ncfg = scripts\\amk\\" .. cfg_name .. ".ltx"
        amk.write_stalker_params( t, obj )
      end
    end
  end
end


function spawn_unspawned_respawners( respawn )
  local respawners = {}
  for a = 1, 65534 do
    local obj = alife():object( a )
    if obj then
      local sini = obj:spawn_ini()
      if sini:section_exist( "respawn" ) then
        local amk_name = get_string( "respawn", "amk_name", nil, sini )
        if amk_name then respawners[ amk_name ] = obj end
      end
    end
  end

  local root = "amk_respawns"
  local dv   = {}
  if sys_ini:section_exist( root .. ".default_values" ) then
    for id, value in pairs(
      get_section_keys_and_values( root .. ".default_values" )
    ) do
        dv[ id ] = value
    end
  end

  if sys_ini:section_exist( root ) then
    local tmp = get_section_keys( root )
    for _, v in ipairs( tmp ) do
      local flag = get_bool( "amk_respawns", v, false )
      if respawn then flag = false end
      local sect = root .. "." .. v
      if not respawners[ v ] and flag then
        local t     = get_section_keys_and_values( sect )
        local xyzlg = amk.str_explode( ",", t.xyzlg, true )
        local pos   = vector():set(
          tonumber( xyzlg[ 1 ] ), tonumber( xyzlg[ 2 ] ), tonumber( xyzlg[ 3 ] )
        )
        local respawner = amk.spawn_item(
          "respawn", pos, tonumber( xyzlg[ 5 ] ), tonumber( xyzlg[ 4 ] )
        )
        local tbl = amk.get_spawner_data( respawner )
        t.xyzlg    = nil
        t.amk_name = v
        for kkk, vvv in pairs( dv ) do
          if not t[ kkk ] then
            t[ kkk ] = vvv
          end
        end
        tbl.custom = amk.gen_custom_data({ respawn = t })
        amk.set_spawner_data( tbl, respawner )
        se_respawn.reinit_spawner_params( respawner:name() )
      end
      if respawners[ v ] and flag then
        local new_ver = get_float( sect, "dsh_version", 0 )
        local obj     = respawners[ v ]
        local cur_ver = get_u32(
          "respawn", "dsh_version", 0, obj:spawn_ini()
        )
        if new_ver > cur_ver then flag = false end
      end
      if not flag then
        local o = se_respawn.get_respawner_by_name( v )
        if o then
          o:dsh_cleanup_spawned_obj()
          se_respawn.release_respawner( o )
        end
      end
    end
  end
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **          OTHER        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************

local last_armor_id=0
local last_condition=0

function repair_armor(val)
        local armor = db.actor:item_in_slot(6)
        if armor then
                last_armor_id=armor:id()
                last_condition=val
                armor:set_condition(val)
        end
end

btrs_friends={}

function build_btrs_table(obj)
        if obj and (IAmAStalker[obj:clsid()] and obj:character_community()=="military" and obj:alive()) or obj:section()=="vehicle_btr" then
                        btrs_friends[obj:id()] = obj:section()
        end
end

function zomby_blow(obj)
        if obj:object("wpn_flame") then
                amk_particle.amk_particle({
                                particle="explosions\\explosion_fuelcan",
                                pos=obj:position(),
                                sound=[[weapons\t_rgd5_explosion]]
                        })
                local dist = db.actor:position():distance_to(obj:position())
                if dist < 10 and db.actor:see(obj) then
                        local h = hit()
                        h.impulse = 0
                        h.draftsman = db.actor
                        h.direction = vector():set(0,0,0)
                        h:bone("bip01_spine") -- чтобv учитvвалась броня
                        h.power = 1/dist
                        h.type = hit.strike --chemical_burn
                        db.actor:hit(h)
                        h.power = 15/dist
                        h.type = hit.chemical_burn
                        db.actor:hit(h)
                end
                alife():release(alife():object(obj:id()))
                return
        end
        
        if obj:section()=="zombie_blow" or obj:section()=="zombie_beee" or obj:section()=="zombie_hell" or obj:section()=="zombie_hospital1" or obj:section()=="zombie_hospital2" or obj:section()=="zombie_hospital3" then
                amk_particle.amk_particle({
                        particle="monsters\\polter_death_00",
                        pos=obj:bone_position("bip01_head"),
                        sound="anomaly\\anomaly_gravy_hit1"
                })
                local dist = db.actor:position():distance_to(obj:position())
                if dist < 20 and db.actor:see(obj) then
                        local h = hit()
                        h.impulse = 0
                        h.draftsman = db.actor
                        h.direction = vector():set(0,0,0)
                        h:bone("bip01_spine")
                        h.power = 1/dist
                        h.type = hit.burn
                        db.actor:hit(h)
                        h.power = 15/dist
                        h.type = hit.burn
                        db.actor:hit(h)
--            level.add_pp_effector("amk_shoot.ppe", 2016, false)
            local snd_obj = xr_sound.get_safe_sound_object([[monsters\zombie\zombie_take_damage_]]..tostring(math.random(1,6)))
                        snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
                        alife():release(alife():object(obj:id()))
                end
        end
end

function repair_weapon (st)
        local arr = amk.unpack_array_from_string(st)
        local oid = arr[1]
        local repbox_health = arr[2]
        local slot = arr[3]
        if alife():object(oid)==nil then
                local repair_coef = 0                                   
                local item_in_slot = db.actor:item_in_slot(slot)  
                if repbox_health==1 then                                 
                        repair_coef=0.25                                           
                elseif repbox_health<1 then                       
                        repair_coef=0.2                                         
                elseif repbox_health<0.8 then                       
                        repair_coef=0.15                                            
                elseif repbox_health<0.6 then                        
                        repair_coef=0.1                                         
                elseif repbox_health<0.4 then                        
                        repair_coef=0.05         
                end      
                --------------------------------------------------------------------------- 
                local rem
                
                if item_in_slot == nil then
                        amk.send_tip(game.translate_string("rep_no_weapon_in_slot"),nil,nil,5)
                        rem = amk.spawn_item_in_inv("repbox_s"..slot)
                        amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                else
                        if item_in_slot:condition()>0.95 then
                                amk.send_tip(game.translate_string("rep_not_need"),nil,nil,5)
                                rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                        else 
                                if item_in_slot:condition()>=0.7 then
                                        item_in_slot:set_condition(item_in_slot:condition() + repair_coef)
                                        if repbox_health>0.3 then
                                                rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                                amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health-0.2} )
                                        end
                                else
                                        amk.send_tip(game.translate_string("rep_need_big"),nil,nil,5)
                                        rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                        amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                                end
                        end
                end
        end

end

function after_repair_weapon (st)
        local arr = amk.unpack_array_from_string(st)
        local oid = arr[1]
        local repbox_health = arr[2]
        local lobj = level.object_by_id(oid)
        if lobj then
                lobj:set_condition(repbox_health)
        end
end

function fake_weapon (st)
monnoroch.fake_weapon (st)
end
