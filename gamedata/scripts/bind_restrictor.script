-- -*- mode: lua; coding: windows-1251-dos -*-
-- Space restrictor binder
-- Чугай Александр
--
-- Примечания:
--
--   - обновлений у рестрикторов нету, поэтому для тех, кому надо,
--   - актёр вызывает искусственно на своём обновлении


function bind( obj )
  if
    obj:name() == "gar_vagon_in_restrictor"
    or obj:name() == "bar_restrictor"
    or obj:name() == "rostok_sniper_killer_restrictor"
    or obj:name() == "agr_u_bloodsucker_rest"
  then
    local sobj = alife():object( obj:id() )
    if sobj then
      alife():release( sobj, true )
      return
    end
  end
  obj:bind_object( restrictor_binder( obj ) )
end


class "restrictor_binder" ( object_binder )
function restrictor_binder:__init( obj, char_ini ) super( obj )
  self.initialized = false
  self.loaded      = false
  self.sm          = ogse_signals.get_mgr()
end


function restrictor_binder:reload( section )
  object_binder.reload(self, section)
end


function restrictor_binder:reinit()
  object_binder.reinit( self )
  db.storage[ self.object:id() ] = {}
  self.st = db.storage[ self.object:id() ]
end


function restrictor_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  db.add_zone( self.object )
  -- Не регистрироваться на апдейты, если у объекта в customdata
  -- нет секции logic вообще.
  --
  -- ОП-2: Функция
  --
  -- xr_logic.get_customdata_or_ini_file(self.object, "<customdata>")
  --
  -- при отсутствии у рестриктора кастомдаты -- возвращает "пустую" логику:
  -- return ini_file([[scripts\dummy.ltx]]), в которой секция logic есть.
  -- Поэтому в updatable_binders в варианте от ПЫСов, несмотря на их
  -- коммент выше, регистрируются на апдейты АБСОЛЮТНО ВСЕ
  -- рестрикторы. Даже те, у которых нет кастомдаты вообще.  Поэтому
  -- условие проверки доработано на проверку строки active ~= nil и
  -- отсутствие строки cfg.
  local char_ini = xr_logic.get_customdata_or_ini_file(
    self.object, "<customdata>"
  )
  if xr_logic.logic_not_empty( self.object, char_ini ) then
    self.subscribed = {
      [ "signal" ] = "on_update",
      [ "fun"    ] = self.actor_update,
      [ "self"   ] = self,
    }
    self.sm:subscribe( self.subscribed )
  end
  return true
end


function restrictor_binder:net_destroy()
  local st = db.storage[ self.object:id() ]
  if st.active_scheme then
    xr_logic.issue_event( self.object, st[st.active_scheme], "net_destroy" )
  end
  db.del_zone( self.object )
  if self.subscribed then
    self.sm:unsubscribe( self.subscribed )
    self.subscribed = nil
  end
  db.storage[ self.object:id() ] = nil
  object_binder.net_destroy( self )
end


-- вызывается из обновления актёра!
function restrictor_binder:actor_update( delta )
  if not self.initialized and db.actor then
    self.initialized = true
    xr_logic.initialize_obj(
      self.object, self.st, self.loaded, db.actor, modules.stype_restrictor
    )
  end
  if not self:is_nil_active_section() then
    xr_logic.issue_event(
      self.object, self.st[self.st.active_scheme], "update", delta
    )
  end
  -- пустая логика могла быть пустой изначально, или могла переключиться
  -- активная секция после вызова xr_logic.issue_event(). Поэтому проверим
  -- лишний раз здесь.
  if self:is_nil_active_section() then
    if 
      self.object:section() == "space_restrictor"
      and self.object:name() == self.object:section() .. self.object:id()
    then
      -- ОП-2: Рестрикторы, у которых логика вышла в nil, не удаляются
      -- еще от ПЫСов и болтаются в памяти всю игру. И этот апдейт для
      -- них постоянно вызывается.  Но теперь, согласно правке
      -- заполнения updatable_binders выше, в этой таблице есть только
      -- рестрикторы с логикой.  И их логика вышла в nil, поэтому их
      -- смело можно было бы удалить. Но некоторые из них используются
      -- дополнительно как рестрикторы зон для неписей.  Поэтому удаляем
      -- только обычные рестрикторы, заспавненные скриптом. У
      -- скриптового рестриктора name = секция+ид.  А алспауновские и с
      -- уникальными секциями не удаляем ...
      local sobj = alife():object( self.object:id() )
      if sobj then
        alife():release( sobj )
      end
    else
      -- ... а просто снимаем с апдейта
      ASSERT( self.subscribed, "not subscribed: %s", self.object:name() )
      self.sm:unsubscribe( self.subscribed )
      self.subscribed = nil
    end
  else
    local dist = self.object:position():distance_to( db.actor:position() )
    self.sm:reschedule(
      ( dist < 25 and 200 ) or ( dist < 100 and 1000 )
      or math.random( 5000, 6000 )
    )
  end
end


function restrictor_binder:is_nil_active_section()
  return
    self.st.active_section == nil
    or self.st.active_section == "sr_idle@nil"
end


function restrictor_binder:net_save_relevant()
  return true
end


function restrictor_binder:save( packet )
  ASSERT(
    db.saving_obj == nil ,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  object_binder.save( self, packet )
  xr_logic.save_obj( self.object, packet )
  db.saving_obj = nil
end


function restrictor_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  xr_logic.load_obj( self.object, reader )
end
