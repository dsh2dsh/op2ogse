-- -*- mode: lua; coding: windows-1251-dos -*-

-- При получении хита удара такой величины, водка в инвентаре будет разбиваться
-- c вероятностью 100%. Чем меньше полученный хит, тем меньше вероятность
-- разбить водку.
local BREAK_VODKA_HIT = 0.6

-- Предметы и их кол-во, которые остаются в инвентаре, при сбросе рюкзака.
local mandatory_items = {
  {
    [ "num"      ] = 20,
    [ "sections" ] = { "bandage" },
  },
  {
    [ "num"      ] = 5,
    [ "sections" ] = { "medkit", "medkit_army", "medkit_scientic" },
  },
  {
    [ "num"      ] = 5,
    [ "sections" ] = { "medkit_army", "medkit_scientic", "medkit" },
  },
  {
    [ "num"      ] = 5,
    [ "sections" ] = { "antirad" },
  },
  {
    [ "num"      ] = 10,
    [ "sections" ] = { "sandwich", "bread", "kolbasa", "conserva" },
  },
  {
    [ "num"      ] = 10,
    [ "sections" ] = { "matches" },
  },
  {
    [ "num"      ] = 3,
    [ "sections" ] = { "energy_drink" },
  },
  {
    [ "num"      ] = 9,
    [ "sections" ] = { "flaska" },
  },
  {
    [ "num"      ] = 5,
    [ "sections" ] = { "sigaret", "cigara" },
  },
  {
    [ "num"      ] = 1,
    [ "sections" ] = { "matras" },
  },
}


function attach( sm )
  sm:subscribe({ signal = "on_hit",        fun = this.on_hit      })
  sm:subscribe({ signal = "on_key_down",   fun = this.on_key_down })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_take",       fun = this.on_take     })
  sm:subscribe({ signal = "on_rukzak_use", fun = this.on_rukzak_use })
  sm:subscribe({ signal = "on_spawn",      fun = this.on_spawn    })
end


function on_spawn()
  rebind_keys()
end


local dik_inv_drop
function rebind_keys()
  dik_inv_drop = {}
  local data = dsh_cfg.get_data()
  if not data.chat then return end
  for _, kn in ipairs( parse_names( data.chat ) ) do
    local dik = keyname_to_dik( kn )
    ASSERT( dik, "keyname to dik not found: %s", kn )
    dik_inv_drop[ dik ] = true
  end
  cmd( "unbind chat" )
  cmd( "unbind_sec chat" )
end


function on_mm_return_game()
  rebind_keys()
end


local drop_t
function on_key_down( key, bind )
  if
    ( not dik_inv_drop[ key ] )
    or drop_t
    or dsh_hud_fx.is_active_hud_fx_queue()
    or db.eat
  then
    return
  end
  local item = db.actor:object( "treasure_item" )
  if item then
    db.actor:hide_weapon()
    db.eat = true
    local snd = xr_sound.get_safe_sound_object( "rykzack\\drop_rykzak_" .. math.random( 4 ) )
    snd:play( db.actor, 0, sound_object.s2d )
    drop_t = dsh.timeout(
      snd:length(), function()
        drop_shadow_inventory(
          item,
          function()
            db.eat = false
            db.actor:restore_weapon()
            drop_t = nil
          end
        )
      end
    )
  end
  return true
end


local dropping = false

function drop_shadow_inventory( item, done_f )
  local sobj = ogse.spawn_item_in_inv( "shadow_inventory" )
  sobj = alife():object( sobj.id )
  sobj:used_ai_locations( false )
  alife():set_switch_online(  sobj.id, true  )
  alife():set_switch_offline( sobj.id, false )
  level.client_spawn_manager():add(
    sobj.id, -1, function( id, obj )
      fill_shadow_inventory( item, obj )
      ogse.remove_item_from_inventory( item )
      dropping = true
      local dir = vector_rotate_y( db.actor:direction(), 180 )
      if ( dir.y < 0 ) then dir.y = -dir.y end
      dir:normalize():mul( 2 )
      db.actor:drop_item_and_throw( obj, dir )
      ogse.save_var( "dsh_fast_inv_drop.dropped", true )
      done_f()
    end
  )
end


function fill_shadow_inventory( item, box )
  local break_vodka  = (
    get_actor_obj():is_actor_running()
    or get_actor_obj():is_actor_sprinting()
    or get_actor_obj():is_actor_climbing()
  ) and true or false
  local broken_vodka = {}
  local ignore_items = { [ item:id() ] = true }
  local need_ammo    = get_need_ammo()
  local actor_items  = mandatory_filter(
    dsh_rukzak.get_actor_items(
      function( obj )
        if need_ammo[ obj:section() ] or ignore_items[ obj:id() ] then
          return false
        elseif obj:section() == "vodka" and break_vodka then
          if math.random() < 0.5 then
            table.insert( broken_vodka, obj )
            return false
          end
        end
        return dsh_rukzak.can_include_into_actor_items( obj )
      end
    )
  )
  if table.getn( broken_vodka ) > 0 then
    for _, obj in ipairs( broken_vodka ) do
      ogse.remove_item_from_inventory( obj )
    end
  end
  local has_metka = false
  local has_zamok = false
  for _, ai in ipairs( actor_items ) do
    for _, obj in ipairs( ai.game_objs ) do
      if obj:section() == "zamok" then
        has_zamok = true
      elseif obj:section() == "amk_metka" then
        has_metka = true
      end
      db.actor:transfer_item( obj, box )
    end
  end
  if table.getn( broken_vodka ) > 0 then
    local snd = xr_sound.get_safe_sound_object( "material\\bottle\\collide\\bottle_break_1" )
    snd:play( db.actor, 0, sound_object.s2d )
    dsh.timeout( snd:length() * 1.1, dsh.say_blin )
  end
  if has_metka then
    level.map_add_object_spot_ser( box:id(), "habar_location", "аўъчръ" )
  end
  if has_zamok then
    amk_offline_alife.protected.ids[ box:id() ] = 1
  end
end


function on_take( obj )
  if obj:section() ~= "shadow_inventory" then return end
  if dropping then
    dropping = false
    return true
  end
  db.actor:hide_weapon()
  db.eat = true
  local snd = xr_sound.get_safe_sound_object( "rykzack\\give_rykzak_2" )
  snd:play( db.actor, 0, sound_object.s2d )
  drop_t = dsh.timeout(
    snd:length() * 1.15, function()
      db.eat = false
      db.actor:restore_weapon()
      drop_t = nil
    end
  )
  take_shadow_inventory( obj )
  return true
end


function take_shadow_inventory( box, done_f )
  local cnt = box:object_count()
  if cnt > 0 then
    local items = {}
    for i = 0, box:object_count() - 1 do
      table.insert( items, box:object( i ) )
    end
    for _, obj in ipairs( items ) do
      box:transfer_item( obj, box:parent() )
    end
  end
  amk_offline_alife.protected.ids[ box:id() ] = nil
  ogse.remove_item( box )
  ogse.delete_var( "dsh_fast_inv_drop.dropped" )
  local sobj = dsh_rukzak.spawn_item_in_inv( "treasure_item" )
  if done_f then
    level.client_spawn_manager():add(
      sobj.id, -1, function( id, obj ) done_f() end
    )
  end
end


function get_need_ammo()
  local weapons = {}
  for _, slot in ipairs({ 1, 2, 8 }) do
    local obj = db.actor:item_in_slot( slot )
    if obj and obj:is_weapon() then
      table.insert( weapons, obj )
    end
  end
  local need_ammo = {}
  for _, obj in ipairs( weapons ) do
    local sect = obj:section()
    local ammo_class = get_string( sect, "ammo_class", "" )
    for _, ammo in ipairs( parse_names( ammo_class ) ) do
      need_ammo[ ammo ] = true
    end
    local grenade_class = get_string( sect, "grenade_class", "" )
    for _, ammo in ipairs( parse_names( grenade_class ) ) do
      need_ammo[ ammo ] = true
    end
  end
  local grenade_obj = db.actor:item_in_slot( 3 )
  if grenade_obj then
    need_ammo[ grenade_obj:section() ] = true
  end
  return need_ammo
end


function mandatory_filter( items )
  local index = {}
  for _, item in ipairs( items ) do
    if item.condition > 0 then
      if index[ item.section ] then
        table.insert( index[ item.section ], item )
      else
        index[ item.section ] = { item }
      end
    end
  end
  for k, v in pairs( index ) do
    table.sort( v, function( a, b ) return a.condition < b.condition end )
  end
  for _, item in ipairs( mandatory_items ) do
    local cnt = item.num
    for _, sect in ipairs( item.sections ) do
      if index[ sect ] then
        for _, our in ipairs( index[ sect ] ) do
          while table.getn( our.game_objs ) > 0 and cnt > 0 do
            table.remove( our.game_objs )
            cnt = cnt - 1
          end
          our.count = table.getn( our.game_objs )
          if cnt == 0 then break end
        end
        if cnt == 0 then break end
      end
    end
  end
  local filtered = {}
  for _, item in ipairs( items ) do
    if table.getn( item.game_objs ) > 0 then
      if not item.count then
        item.count = table.getn( item.game_objs )
      end
      table.insert( filtered, item )
    end
  end
  return filtered
end


function on_rukzak_use( obj )
  if drop_t then return end
  local id       = obj:id()
  local prefix   = "dsh_rukzak." .. id
  local inv_drop = ogse.load_var( prefix .. ".inv_drop", false, "bool" )
  if inv_drop then
    db.actor:hide_weapon()
    db.eat = true
    local snd = xr_sound.get_safe_sound_object( "rykzack\\give_rykzak_2" )
    snd:play( db.actor, 0, sound_object.s2d )
    ogse.remove_item( obj )
    drop_t = dsh.timeout(
      snd:length() * 1.15, function()
        move_to_inventory( id )
        db.eat = false
        db.actor:restore_weapon()
        drop_t = nil
      end
    )
    return true
  end
end


function move_to_inventory( rukzak )
  local items = dsh_rukzak.load_rukzak( rukzak )
  for _, item in ipairs( items ) do
    while item.count > 0 do
      local sobj
      if item.game_type == "ammo" then
        local box_size = dsh_rukzak.get_ammo_box_size( item.section )
        if item.count > box_size then
          sobj = dsh_rukzak.spawn_ammo_in_inv( item.section, box_size )
          item.count = item.count - box_size
        else
          sobj = dsh_rukzak.spawn_ammo_in_inv( item.section, item.count )
          item.count = 0
        end
      else
        if item.game_type == "weapon" then
          sobj = dsh_rukzak.spawn_weapon_in_inv( item.section, item.info )
        else
          sobj = dsh_rukzak.spawn_item_in_inv( item.section )
        end
        if
          string.find( item.section, "arc_art_box_", 1, true )
          or dsh.is_artefact( item.section )
          or item.game_type == "outfit"
        then
          sobj.custom_data = item.info or ""
        end
        item.count = item.count - 1
      end
      if item.condition < 100 then
        level.client_spawn_manager():add(
          sobj.id, -1, function( id, obj )
            dsh.set_condition( obj, item.condition / 100 )
          end
        )
      end
      if item.count == 0 then
        if item.section == "zamok" then
          amk_offline_alife.protected.ids[ rukzak ] = nil
        end
      end
    end
  end
  dsh_rukzak.save_rukzak( rukzak, {} )
  dsh_rukzak.spawn_item_in_inv( "treasure_item" )
end


function on_hit( obj, amount, local_direction, who, bone_index )
  if not ( db.actor:alive() and amount > 0 ) then return end
  local binder = obj:binded_object()
  local data   = binder.last_hit_data
  if not ( data and data.hit_type == hit.strike ) then return end
  local t = {}
  local r = amount / BREAK_VODKA_HIT
  amk_utils.inventory_iterate_section(
    "vodka",
    function( obj )
      if math.random() < r then
        table.insert( t, obj )
      end
    end
  )
  if table.getn( t ) > 0 then
    for _, obj in ipairs( t ) do
      ogse.remove_item_from_inventory( obj )
    end
    local snd = xr_sound.get_safe_sound_object( "material\\bottle\\collide\\bottle_break_1" )
    snd:play( db.actor, 0, sound_object.s2d )
    dsh.timeout( snd:length() * 1.1, dsh.say_blin )
  end
end
