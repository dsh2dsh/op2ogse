-- -*- mode: lua; coding: windows-1251-dos -*-

-- величина разряда
local step = 0.014
-- как часто выполняется разряд фонарика ( в милисекундах реального времени )
local freq = 31 * 1000

-- если заряд меньше этой величины, яркость начинает снижаться
max_brightness = 0.1


function attach( sm )
  sm:subscribe({ signal = "on_first_update", fun = this.on_first_update })
  sm:subscribe({ signal = "on_key_down",     fun = this.on_key_down    })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_sleep_finished", fun = this.on_sleep_finished })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_spawn       })
  sm:subscribe({ signal = "on_update",       fun = this.on_update      })
end


function on_spawn()
  rebind_use_torch()
end


local dik_use_torch
function rebind_use_torch()
  dik_use_torch = {}
  local data = dsh_cfg.get_data()
  if not data.torch then return end
  for _, kn in ipairs( parse_names( data.torch ) ) do
    local dik = keyname_to_dik( kn )
    ASSERT( dik, "keyname to dik not found: %s", kn )
    dik_use_torch[ dik ] = true
  end
  cmd( "unbind torch" )
  cmd( "unbind_sec torch" )
end


function on_mm_return_game()
  rebind_use_torch()
end


function on_first_update()
  set_torch_mode()
end


local torch_mode = "off"
function set_torch_mode( k )
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      if torch.on then
        torch_mode = ogse.load_var( "dsh_torch.torch_mode", "near" )
        if torch_mode == "far" then
          set_far_mode( torch, k )
        elseif torch_mode == "near" then
          set_near_mode( torch, k )
        end
      else
        set_near_mode( torch, k )
        torch_mode = "off"
      end
    end
  end
end


function on_key_down( key, bind )
  if
    ( not dik_use_torch[ key ] ) or level.main_input_receiver() or db.eat
  then
    return
  end
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      local snd = sound_object( "device\\nlc6\\pda\\dairy_click_1" )
      snd:play( db.actor, 0, sound_object.s2d )
      torch = get_torch_obj( torch )
      if torch.on then
        if torch_mode == "near" then
          set_far_mode( torch )
        else
          torch:switch( false )
          torch_mode = "off"
        end
      else
        set_near_mode( torch )
        torch:switch( true )
      end
      ogse.save_var( "dsh_torch.torch_mode", torch_mode )
    end
  end
end


function set_brightness( torch, r )
  torch:set_brightness( math.min( 1, r / max_brightness ) )
end


function set_near_mode( torch, r )
  torch_mode = "near"
  if not r then r = get_torch_power() end
  torch:set_range( 20 * math.min( 1, r / max_brightness ) )
  torch:set_angle( math.rad( 90 ) )
  set_brightness( torch, r )
end


function set_far_mode( torch, r )
  torch_mode = "far"
  if not r then r = get_torch_power() end
  torch:set_range( 70 * math.min( 1, r / max_brightness ) )
  torch:set_angle( math.rad( 60 ) )
  set_brightness( torch, r )
end


function is_torch_enabled()
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      return torch.on
    end
  end
end


function play_click()
  snd_obj = xr_sound.get_safe_sound_object( [[device\click10b]] )
  if snd_obj then
    snd_obj:play_no_feedback(
      db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0
    )
  end
end


function get_torch_power( new )
  local vname = "dsh_torch.power"
  local power = ogse.load_var( vname, 1 )
  if new then
    ogse.save_var( vname, new, "float" )
  end
  return power
end


function recharge_torch( cond )
  if not cond then cond = 1 end
  get_torch_power( cond )
  set_torch_mode()
end


local flash_t
function discharge_torch()
  if torch_mode == "off" then return end
  local torch = db.actor:item_in_slot( 9 )
  if not ( torch and torch:is_torch() ) then return end
  local power = get_torch_power()
  if power < max_brightness and math.random() < 0.2 then
    set_torch_mode( power * ( math.random( 5, 9 ) ) / 10 )
    if flash_t then flash_t:stop() end
    flash_t = dsh.timeout(
      500 + 500 * math.random( 5 ),
      function()
        flash_t = nil
        discharge_torch()
      end
    )
  else
    local k   = 1 -- ( torch_mode == "near" and 1 or 2 )
    local dec = step * k
    if power > dec then
      get_torch_power( power - dec )
      set_torch_mode()
    else
      torch = get_torch_obj( torch )
      torch:switch( false )
      torch_mode = "off"
    end
  end
end


local started = false
function on_update()
  ogse_signals.get_mgr():reschedule( freq )
  if started then
    discharge_torch()
  else
    started = true
  end
end


function on_sleep_finished( sleep_time )
  if torch_mode == "off" then return end
  get_torch_power( 0.13 )
  set_torch_mode()
end
