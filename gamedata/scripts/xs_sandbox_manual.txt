Описание:
	"Песочница" основана на так называемой event-driven модели. В ней используется ООП-парадигма, которая позволяет упростить код и сделать его более эффективным.
	Вся работа с песочницей состоит из двух частей:
		объекты-события (см. ниже)
		программные модули (тоже см. ниже)
		
	Объекты-события помогают связать игровые события и код в модулях, при этом код в модулях становится независимым, не мешает и не связан ни с чем другим. Модули благодаря этому можно безболезненно включать и выключать.
	
	Модули - это по сути отдельные скрипты, в которых реализуется необходимая логика, но их подключение - проще пареной репы, не надо лезть в дебри других скриптов и плодить связи и зависимости. В каждом модуле обязательно существует функция init(), которая вызывается, когда модуль подключается и инициализируется. Зачем она нужна - описано ниже.
	
	Использование и работу я рассмотрю на примере одного модуля, который используется в ОГСЕ для определения ревизии СВН и сохранения ее в сейв-файлах.
		
--------------------------

Интеграция:
1) В _g.script ищем функцию
	function start_game_callback()
	...
	end
	И в самый конец лепим инструкции:
	
	-- xStream -- sandbox init --
	xs_sandbox.init()
	event("game_start"):trigger()

2) добавление модулей:
	(NOTE: результат описанных ниже действий можно увидеть в архиве)
	а) создается скрипт с произвольным именем, например xs_svn.script
	б) в файле xs_sandbox_bindings.script в таблицу добавляем имя этого скрипта без расширения .script
	в) Порядок, в котором добавляются модули очень важен. В зависимости от порядка происходит инициализация модулей, если где-то реализована, например, работа с нет-пакетами, то изменение порядка модулей приведет к порче и несовместимости таких нет-пакетов.
	г) если есть несколько модулей и они взаимосвязаны, то есть один не может работать без других, то такие модули надо объединять в таблицу в xs_sandbox_bindings.script, например:
		binds = {
			{
				"module1",
				"module2"
			},
			"xs_svn" -- should be last!
		}
	Модули 1 и 2 - взаимозависимы, при ошибке загрузки одного не будет грузиться и другой.
	
3) Объекты-события.
	Вся event-driven модель реализована посредством специальных объектов - event().
	Каждое событие имеет имя, например event("actor_spawn")
	Имя может быть произвольным, но я рекомендую использовать систему префиксов, в данном случае actor_ - это означает, что событие сгенерировано для актора. А конкретно - появление актора в онлайне.
	
	а) Как же использовать события? Да очень просто. События где-то создаются, а где-то используются. Создаются непосредственно в различнейших местах игры. event("actor_spawn") у меня создается, например, в файле bind_stalker (ага, файл для актора) ищем функцию function actor_binder:net_spawn(data) и в самый конец (перед return xxx) добавляем следующую строчку:
	event("actor_spawn"):trigger({data = data})
	
	Мать моя женщина, а что за trigger какой-то и таблица? А вот это очень важно. Каждое событие может нести некую информацию, которую можно использовать в будущем в модулях. Это раз. Два - событие мало просто создать, его надо "выстрелить" (fire на английском), "триггнуть" (на сленге). Это делается методом trigger объекта-события.
	
	Существует альтернативный способ указания данных, которые буду храниться в событии:
	local evt = event("actor_spawn")
	evt.data = data
	evt:trigger()
	
	Эта запись длиннее, но иногда гораздо удобнее и понятнее, что же тут происходит.
	
	Еще раз повторю: прежде, чем мы сможем использовать события и саму песочницу в целом, НЕОБХОДИМО в нужных местах расставить "выстрелы" разных событий.
	Например: event("npc_hit"):trigger({victim = self.object, amount = amount, dir = local_direction, who = who, bone = bone_index}) в файле xr_motivator в функции motivator_binder:hit_callback.
	Здесь мы помешаем в событие ВСЕ НЕОБХОДИМЫЕ данные. Иначе пользы от "пустого" события будет мало.
	
	б) Все замечательно - в нужный момент времени в игре создастся событие и "выстрелит". Что с этим делать и как обработать этот "выстрел"?
	Возвращаемся к функции init() в программных модулях, о которой я говорила выше.
	
	События умеют не только "выстреливать", они могут иметь "подписчиков" - функции, которые будут вызваны, когда событие "выстрелит". ПРОФИТ! То, что нам как раз и надо. Надо этим воспользоваться. А сделать это можно так:
	В модуле (в примере xs_svn) в функции init() мы добавляем строку:
		event("actor_spawn"):register(on_spawn)
	Бинго! Это называется регистрация подписчика на событие. А если по-русски - как только "выстрелит" событие actor_spawn, вызовется функция on_spawn в этом же файле. Более того, в нее будет передан единственный аргумент - ... сам объект событие. Зачем?
	Да затем, что событие, если помните, содержит в себе разную информацию, в данном случае - data. Получив эти данные как e.data (см. файл, функцию on_spawn) мы можем с ними что-то сделать. У каждого типа событий - свой набор данных. Можно посмотреть его там, где событие "выстреливает".
	NOTE! Можно использовать так же и безымянные функции! Или переменные-функции.
	
	Итог: мы получаем мощный инструмент, благодаря которому, практически не внося изменений в оригинальные скрипты игры мы можем делать собственную игровую логику, очень быстро и просто. Можем удобно этим хозяством управлять - отключать и включать.
	
	NOTE! Есть симметричная register функция unregister, которая позволяет убрать подписчика у события. Главное помнить - передавать надо абсолютно ту же функцию, которая передавалась в register
	
	в) NOTE: материал для продвинутых!
		i)Иногда случаются ситуации, что данные, которые обработали в одном подписчике, были им удалены (например - убит непись или переменная выставлена в nil). Тогда ОЧЕНЬ ОПАСНО продолжать вызывать другие обработчики этого же события - непись удален, а мы пытаемся что-то с ним сделать - скорее всего вылет или поломка логики игры. Чтобы предотвратить такое, у объекта-события есть метод :stop(). Это означает, что если в коде какого-то обработчика мы вызовем e:stop() (е - параметр, объект, переданный в обработчик), то дальнейшая обработка "выстрелившего события в этот раз остановится.
		ii) Иногда происходят ситуации, называемые "зависаниями биндеров". Происходит это, если внутри кода обработчика сделать какие-то действия, которые не приведут к краху программы, но биндер больше работать не будет и события "выстреливаться" тоже не будут - короче, поломашка всей игровой логики. В песочнице предусмотрена возможность отладки подобных случаев: у каждого объекта-события можно выставить так называемый fingerprint - метку, произвольную, описывающую, что происходит сейчас. В случае повисания, можно узнать метку и вычислить, где произошло зависание. Пример можно увидеть в коде, но приведу его и тут:
		
		-- пример применения setFingerprint
		-- function on_save(e)
			-- e:setFingerprint("save svn rev")
			-- if rev and rev~="" then
				-- e.packet:w_u16(tonumber(rev))
			-- end
		-- end

		Ключевой является строка e:setFingerprint("save svn rev")
		Она выставляет отметку. И если произойдет какая-то беда, то мы в логе увидим, что зависание произошло во время записи ревизии СВН в сейв-файл.
		
		iii) Чтобы удалить тот колбек, что сейчас выполняется из очереди на выполнение, надо вызвать e:removeThisCallback(). После отработки этот колбек не будет больше вызываться вообще. Пока заново не зарегистрируют.
