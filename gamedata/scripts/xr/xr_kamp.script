-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Схема лагерь. Чудак(и) у костра.
-- автор: Диденко Руслан (Stohe)
-- TODO:

local women_vis = {
  [ "actors\\woman\\devchonka"    ] = true,
  [ "actors\\woman\\girl_pantera" ] = true,
  [ "actors\\woman\\wife_pvt_voronin" ] = true,
}


function attach( sm )
  sm:subscribe({ signal = "on_monster_death", fun = this.on_death })
  sm:subscribe({ signal = "on_monster_spawn", fun = this.on_npc_spawn })
  sm:subscribe({ signal = "on_npc_death",     fun = this.on_death })
  sm:subscribe({ signal = "on_npc_spawn",     fun = this.on_npc_spawn })
  sm:subscribe({ signal = "on_spawn",         fun = this.on_spawn })
end


local last_death_t
function on_death( obj, who )
  last_death_t = time_global()
end


function on_npc_spawn( obj )
  if not obj:alive() then
    last_death_t = time_global()
  end
end


function on_spawn()
  load_stories()
end


local known_stories = {}
function load_stories()
  local sect = "stories.known_info"
  local n    = sys_ini:line_count( sect )
    for i = 0, n - 1 do
      local res, id, value = sys_ini:r_line( sect, i, "", "" )
      table.insert( known_stories, id )
    end
end


function is_woman_visual( npc )
  return women_vis[ npc:get_visual_name() ]
end


kamps           = {}
kamp_stalkers   = {}    -- могут ли сталкеры в лагере юзаться игроком.
-- Объявления итераторов
deadmansids     = {}          -- кто какой труп оттаскивает


function get_kamp_level_vertex_id( path )
  local sect = "dsh.xr_kamp." .. path
  local vertex
  if sys_ini:section_exist( sect ) then
    local center_point = get_string( sect, "center_point" )
    if center_point then
      path = center_point
    else
      vertex = get_u32( sect, "level_vertex_id" )
    end
  end
  if not vertex then
    local patrol = patrol( path )
    vertex = patrol:level_vertex_id( 0 )
  end
  ASSERT(
    level.valid_vertex_id( vertex ),
    "[%s]: kamp %s has wrong level_vertex_id = %s, vertex_count() = %s",
    script_name(), path, vertex, level.vertex_count()
  )
  return vertex
end


function get_my_kamp( npc, path, scheme, radius )
  local vertex = get_kamp_level_vertex_id( path )
  local kamp   = kamps[ vertex ]
  if not kamp then
    local pos     = level.vertex_position( vertex )
    local nearest = {}
    for lvid, k in pairs( kamps ) do
      local pos2 = level.vertex_position( lvid )
      if
        pos:distance_to( pos2 ) < 10
        and math.abs( pos.y - pos2.y ) < 1
      then
        table.insert(
          nearest,
          {
            [ "kamp" ] = k,
            [ "pos"  ] = pos2,
          }
        );
      end
    end
    table.sort(
      nearest,
      function( a, b )
        return pos:distance_to( a.pos ) < pos:distance_to( b.pos )
      end
    )
    if table.getn( nearest ) > 0 then
      kamp = nearest[ 1 ].kamp
    end
  end
  if kamp then
    local sobj = alife():object( npc:id() )
    ASSERT(
      sobj,
      "[%s]: [%s]: %s not found in alife()",
      script_name(), path, npc:name()
    )
    if kamp.smart_terrain_id <= sobj:smart_terrain_id() then
      kamps[ vertex ] = kamp
    else
      kamps[ vertex ] = CKampManager( path, vertex, scheme, radius, kamp )
    end
  else
    kamps[ vertex ] = CKampManager( path, vertex, scheme, radius )
  end
  return kamps[ vertex ]
end


function bad_position( anomalies, pos, center_pos, ignore_height )
  if not ignore_height then
    if math.abs( center_pos.y - pos.y ) > 2 then return true end
  end
  for _, anom in ipairs( anomalies ) do
    local dist = pos:distance_to( anom.pos ) - anom.radius
    if dist < 5 then
      return true
    end
  end
  return false
end


class "CKampManager"
function CKampManager:__init( name, level_vertex_id, scheme, min_radius, src_kamp )
  self.debug       = false
  self.scheme      = scheme
  self.kamp_name   = name
  self.center      = level_vertex_id
  self.center_point = level.vertex_position( level_vertex_id )
  self.min_radius  = math.max( ( min_radius or 2 ), 2 )
  self.npc         = {}
  self.population  = 0
  self.population_comed = 0
  self.kamp_state  = "idle"
  self.avail_state = xr_kamp_data.avail_state
  self.avail_sound = xr_kamp_data.avail_sound
  self.timeout     = table.clone( xr_kamp_data.timeout )
  self.kamp_states = table.clone( xr_kamp_data.kamp_states )
  self.trans_kamp  = xr_kamp_data.trans_kamp
  self:init_drop_dists()
  -- Хранилище для режиссера лагеря. Режиссерем является сталкер,
  -- затеявший необычное поведение.
  self.director    = nil
  self:find_campfire()
  self:init_sectors()
  self:init_seats()
  self.seats_assigned = false
  if src_kamp then
    for npc_id, v in pairs( src_kamp.npc ) do
      local npc = level.object_by_id( npc_id )
      if npc and npc:alive() then
        local st = db.storage[ npc_id ][ src_kamp.scheme ]
        ASSERT(
          st,
          "[%s]: [%s]: storage not found for %s from %s: scheme = %s",
          script_name(), self.kamp_name, npc:name(), src_kamp.kamp_name,
          src_kamp.scheme
        )
        src_kamp:removeNpc( npc )
        st.kamp = self
        self:addNpc( npc )
      end
    end
  end
end


function CKampManager:find_campfire()
  self.campfire = ogse_campfire.get_nearest_campfire(
    level.vertex_position( self.center ), 4
  )
  if self.campfire then
    self.center_point = self.campfire.object:position()
    local find_vert = false
    local vert_ok   = level.vertex_id_by_pos( self.center_point )
    if level.valid_vertex_id( vert_ok ) then
      local pos = level.vertex_position( vert_ok )
      if pos.y - self.center_point.y > 1 then
        find_vert = true
      end
    else
      find_vert = true
    end
    if find_vert then
      vert_ok = level.vertex_id_by_pos(
        self.campfire.object:level_vertex_id(), self.center_point
      )
    end
    if level.valid_vertex_id( vert_ok ) then
      self.center = vert_ok
    end
  end
end


function CKampManager:get_pos( dist, allow_sector, min_dist, ignore_height )
  local ai_step      = 0.7 -- шаг AI сетки
  local math_pi_180  = 180 / math.pi
  local pi2          = math.pi * 2

  local center       = level.vertex_position( self.center )
  local anomalies    = amk_anoms.get_anomaly_list_for_pos( center, dist )
  local dir          = vector():set( 1, 0, 0 ):normalize()

  -- итератор вращения направления
  local rotate_angle = math.asin( ai_step / dist )
  local cur_angle    = 0
  local found, seen  = {}, {}
  while cur_angle < pi2 do
    local good_angle
    if allow_sector then
      good_angle = false
      for i = 1, table.getn( allow_sector ), 2 do
        if
          cur_angle >= allow_sector[ i ]
          and cur_angle <= allow_sector[ i + 1 ]
        then
          good_angle = true
          break
        end
      end
    else
      good_angle = true
    end
    local vertex
    if min_dist then
      local d = dist
      while d > min_dist do
        local lvid = level.vertex_id_by_pos( vector():mad( center, dir, d ) )
        if level.is_accessible_vertex_id( lvid ) then
          if seen[ lvid ] ~= nil then
            break
          elseif
            bad_position(
              anomalies, level.vertex_position( lvid ), center, ignore_height
            )
          then
            seen[ lvid ] = false
          else
            vertex = lvid
            break
          end
        end
        d = d - ai_step
      end
    elseif good_angle then
      local start_dist = 1
      local stop_dist  = math.min( self.min_radius, dist )
      local start_lvid
      while start_dist < stop_dist do
        start_lvid = level.vertex_id_by_pos(
          vector():mad( self.center_point, dir, start_dist )
        )
        if level.valid_vertex_id( start_lvid ) then
          break
        end
        start_dist = start_dist + ai_step
      end
      if start_lvid and level.valid_vertex_id( start_lvid ) then
        local start_pos   = level.vertex_position( start_lvid )
        local center_dist = start_pos:distance_to( self.center_point )
        local lvid = level.vertex_in_direction(
          start_lvid, dir, dist - center_dist
        )
        if lvid ~= start_lvid and level.is_accessible_vertex_id( lvid ) then
          if seen[ lvid ] == nil then
            if
              bad_position(
                anomalies, level.vertex_position( lvid ), center, ignore_height
              )
            then
              seen[ lvid ] = false
            else
              vertex = lvid
            end
          end
        end
      end
    end
    if vertex then
      table.insert( found, vertex )
      seen[ vertex ] = true
    end
    -- поворачиваем направление поиска
    cur_angle = cur_angle + rotate_angle
    dir       = vector_rotate_y( dir, rotate_angle * math_pi_180 )
  end
  return found
end


function CKampManager:init_sectors()
  local sect = "dsh.xr_kamp." .. self.kamp_name
  if sys_ini:section_exist( sect ) then
    local s = get_string( sect, "allow_sector" )
    if s then
      local t = parse_nums( s )
      ASSERT(
        table.getn( t ) % 2 == 0,
        "[%s]: section '%s' has wrong option 'allow_sector': %s",
        script_name(), sect, s
      )
      self.allow_sector = {}
      for _, n in ipairs( t ) do
        table.insert( self.allow_sector, math.rad( n ) )
      end
    end
  end
end


function CKampManager:getDestVertex( npc )
  if not self.seats_assigned then
    self:reassign_seats()
  end
  local st = self.npc[ npc:id() ]
  return self.active_seats[ st.seat ].vertex
end


function CKampManager:proceedState( npc )
  -- Проверка на таймаут
  local npc_id = npc:id()
  local t      = self.npc[ npc_id ]
  if not t then return end
  if
    self.begin
    and time_global() - self.begin < self.timeout[ self.kamp_state ].min
  then
    return
  end

  -- Если режиссер не закончил говорить - ждем конца фразы.
  if npc:active_sound_count() > 0 then return end

  -- В случае с историей переход обрабатывается отдельно
  if self.kamp_state == "post_story" then
    if self.story_last < self.story_max - 1 then
       t.begin         = nil
       self.director   = npc_id
       self.kamp_state = "story"
       self.begin      = time_global()
       for kk, vv in pairs( self.npc ) do
         vv.new = true
       end
       return
    else
      self.selected_story = nil
    end
  end
  -- Определяются допустимые в данный момент переходы.
  local temp    = {}
  local max_rnd = 0
  for k, v in pairs( self.trans_kamp[ self.kamp_state ] ) do
    -- Определяются допустимые состояния для лагеря.
    if self.kamp_states[ k ] then
      table.insert( temp, { [ "st" ] = k, [ "weight" ] = v } )
      max_rnd = max_rnd + v
    end
  end
  if table.getn( temp ) > 0 then
    table.sort( temp, function( a, b ) return a.weight > b.weight end )
  else
    -- Если переходить некуда - переходим в айдл
    table.insert( temp, { [ "st" ] = "idle", [ "weight" ] = 100 } )
    max_rnd = 100
  end
  -- Осуществляется рандомный взвешенный переход.
  local p = math.random( max_rnd )
  for _, v in ipairs( temp ) do
    p = p - v.weight
    if p <= 0 then
      if v.st == "idle" then
        self.director = nil
        if self.kamp_state ~= "idle" then
          t.begin = nil
        end
      else
        t.begin       = nil
        self.director = npc_id
        self.censor   = nil
      end
      self.kamp_state = v.st
      self.begin      = time_global()
      -- Меняем таймаут для истории
      if v.st == "post_story" then
        local dep = sound_theme_data.theme[ self.selected_story ].depence[ self.story_last ]
        if dep and dep.min and dep.max then
          self.timeout[ "post_story" ].min = math.random( dep.min, dep.max ) * 1000
        end
      end
      for kk, vv in pairs( self.npc ) do
        vv.new = true
      end
      return
    end
  end
  ASSERT(
    false, "[%s]: %s: unexpected state", script_name(), npc:name()
  )
end


function CKampManager:proceedRole( npc, director )
  -- Определить список доступных анимаций по состоянию лагеря.
  -- определить список доступных анимаций по наличию предметов
  -- выбрать одну из них (то же самое со звуком).
  local states = 0
  local sound  = ""
  local state  = ""
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return nil, nil end
  if
    self.npc[ npc_id ].begin == nil
    or time_global() - self.npc[ npc_id ].begin >= self.npc[ npc_id ].state_idle
  then
    if director then
      states = self.avail_state[ self.kamp_state ].directed
      sound  = self.avail_sound[ self.kamp_state ].directed
    else
      states = self.avail_state[ self.kamp_state ].undirected
      sound  = self.avail_sound[ self.kamp_state ].undirected
    end
    -- Выбирать новое состояние только раз в какое то время.
    local temp = {}
    for k, v in pairs( states ) do
      if self.npc[ npc_id ].states[ v ] == true then
        table.insert( temp, v )
      end
    end

    -- Если мы решили говорить историю, надо выбрать какую именно говорить.
    if sound == "play_story" and not self.selected_story then
      self:select_story( npc )
    end
    if table.getn( temp ) > 0 then
      state = temp[ math.random( table.getn( temp ) ) ]
      self.npc[ npc_id ].begin          = time_global()
      self.npc[ npc_id ].state_selected = state
      self.npc[ npc_id ].state_idle     = math.random( 15000, 20000 )
    else
      state = self.npc[ npc_id ].state_selected
    end
  else
    if director then
      sound = self.avail_sound[ self.kamp_state ].directed
    else
      sound = self.avail_sound[ self.kamp_state ].undirected
    end
    state = self.npc[ npc_id ].state_selected
  end
  return state, sound
end


function CKampManager:updateNpc( npc )
  if self.debug then
    log2(
      "[%s]: %s: updateNpc: %s", script_name(), self.kamp_name, npc:name()
    )
  end
  -- Проверка что сталкер может делать, а что нет.
  self:checkNpcAbility( npc )
  -- Просим лагерь выбрать текущее состояние. Менять состояние лагеря
  -- имеет право только режиссер.
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return nil, nil, nil end
  local director = ( self.director == nil or self.director == npc_id )
    and npc_id ~= self.forbiddendirector
  if director then
    self:proceedState( npc )
  end
  -- Говорим чудаку выбрать себе состояние для текущего состояния лагеря.
  local state, sound = self:proceedRole( npc, director )

  local substate
  if state == "wait_harmonica" then
    if sound == "pre_harmonica" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "harmonica"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_harmonica" then
    state    = "harmonica"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "wait_guitar" then
    if sound == "pre_guitar" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "guitar"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_guitar" then
    state    = "guitar"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "wait_balalaika" then
    if sound == "pre_balalaika" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "balalaika"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_balalaika" then
    state    = "balalaika"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "declarate" then
    kamp_stalkers[ npc_id ] = false
    if self.npc[ npc_id ].new == true then
      if sound == "pre_joke" then
        xr_sound.set_sound_play( npc, "intro_joke", math.random( 2000,3000 ) )
      elseif sound == "play_joke" then
        xr_sound.set_sound_play( npc, "joke", math.random( 2000, 3000 ) )
      elseif sound == "play_story" then
        xr_sound.set_sound_play( npc, self.selected_story )
        self.story_last, self.story_max = xr_sound.get_last_IDS(
          npc, self.selected_story
        )
        if self.story_last == nil then
          self.story_last = 0
          self.story_max  = 1
          -- xr_sound.set_sound_play(
          --   npc, "threat_back", math.random( 1000, 2000 )
          -- )
          --- dirty hack
          self.kamp_state         = "idle"
          self.forbiddendirector  = self.director
          self.director           = nil
          kamp_stalkers[ npc_id ] = true
          sound = "idle"
        end
      end
      self.npc[ npc_id ].new = false
    end
    if npc:character_community() == "monolith" then
      local t = math.fmod( npc_id, 2 )
      if t == 0 then
        state = "trans_0"
      else
        state = "trans_1"
      end
    elseif npc:character_community() == "zombied" then
      state = "trans_zombied"
    else
      local t = math.fmod( npc_id, 3 )
      if t == 0 then
        state = "sit"
      elseif t == 1 then
        state = "sit_ass"
      else
        state = "sit_knee"
      end
    end
  elseif state == "trans" then
    kamp_stalkers[ npc_id ] = false
    if npc:character_community() == "monolith" then
      local t = math.fmod( npc_id, 2 )
      if t == 0 then
        state = "trans_0"
      else
        state = "trans_1"
      end
    elseif npc:character_community() == "zombied" then
      state = "trans_zombied"
    else
      kamp_stalkers[ npc_id ] = true
    end
  else
    kamp_stalkers[ npc_id ] = true
  end
  -- Выбор реальных звуков
  if sound == "idle" then
    sound = "weather, state"
  elseif sound == "reac_guitar" then
    sound = "reac_music"
  elseif sound == "reac_balalaika" then
    sound = "reac_music"
  elseif sound == "reac_harmonica" then
    sound = "reac_music"
  elseif sound == "reac_joke" then
    sound = ""
    if self.npc[ npc_id ].new == true then
      if self.censor == nil then
        xr_sound.set_sound_play( npc, "reac_joke", math.random( 2000,3000 ) )
        self.censor = npc_id
      else
        xr_sound.set_sound_play(
          npc, "story_reac_laughter", math.random( 100,300 )
        )
      end
      self.npc[ npc_id ].new = false
    end
  elseif sound == "reac_story" then
    sound = ""
    if self.npc[ npc_id ].new == true then
      local dep
      if self.story_last then
        dep = sound_theme.theme[ self.selected_story ].depence[ self.story_last + 1 ]
      end
      if dep then
        if dep.type == "all" then
          xr_sound.set_sound_play( npc, dep.theme, math.random( 100,300 ) )
        else
          sound = dep.theme
        end
      end
    end
  else
    sound = ""
  end

  return state, sound, substate
end


function CKampManager:checkNpcAbility( npc )
  if
    npc:character_community() == "monolith"
    or npc:character_community() == "zombied"
  then
    return
  end
  local npc_id = npc:id()
  local states = self.npc[ npc_id ].states
  if not states then return end
  states[ "trans" ] = false
  local has_listeners = (
    self.population_comed > 1 and self.npc[ npc_id ].can_talk
  )
  if self.npc[ npc_id ].can_eat then
    -- есть колбасу
    if npc:object( "kolbasa" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "eat_kolbasa" ] = true
    else
      states[ "eat_kolbasa" ] = false
    end
    -- пить водку
    if npc:object( "vodka" ) and math.random( 100 ) > 60 then
      -- вероятность 40%
      states[ "eat_vodka" ] = true
    else
      states[ "eat_vodka" ] = false
    end
    -- пить енергитический напиток
    if npc:object( "energy_drink" ) and math.random( 100 ) > 40 then
      -- вероятность 60%
      states[ "eat_energy" ] = true
    else
      states[ "eat_energy" ] = false
    end
    -- есть хлеб
    if npc:object( "bread" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "eat_bread" ] = true
    else
      states[ "eat_bread" ] = false
    end
    -- курит
    if npc:object( "sigaret" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "kurit" ] = true
    else
      states[ "kurit" ] = false
    end
    -- пить из фляжки
    if npc:object( "flaska" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "flaska" ] = true
    else
      states[ "flaska" ] = false
    end
    -- пить пиво
    if npc:object( "beer_a" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "beer_a" ] = true
    else
      states[ "beer_a" ] = false
    end
    -- курит сигару
    if npc:object( "cigara" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "kurit_cigara" ] = true
    else
      states[ "kurit_cigara" ] = false
    end
    -- есть бутерброд
    if npc:object( "sandwich" ) and math.random( 100 ) > 20 then
      -- вероятность 80%
      states[ "eat_sandwich" ] = true
    else
      states[ "eat_sandwich" ] = false
    end
    -- играть на гармошке
    if has_listeners and npc:object( "harmonica_a" ) then
      states[ "play_harmonica" ] = true
      states[ "wait_harmonica" ] = true
      self.kamp_states[ "pre_harmonica"  ] = true
      self.kamp_states[ "harmonica"      ] = true
      self.kamp_states[ "post_harmonica" ] = true
    else
      states[ "play_harmonica" ] = false
      states[ "wait_harmonica" ] = false
      self.kamp_states[ "pre_harmonica"  ] = false
      self.kamp_states[ "harmonica"      ] = false
      self.kamp_states[ "post_harmonica" ] = false
    end
  else
    states[ "eat_kolbasa"    ] = false
    states[ "eat_vodka"      ] = false
    states[ "eat_energy"     ] = false
    states[ "eat_bread"      ] = false
    states[ "kurit"          ] = false
    states[ "flaska"         ] = false
    states[ "beer_a"         ] = false
    states[ "kurit_cigara"   ] = false
    states[ "eat_sandwich"   ] = false
    states[ "play_harmonica" ] = false
    states[ "wait_harmonica" ] = false
    self.kamp_states[ "pre_harmonica"  ] = false
    self.kamp_states[ "harmonica"      ] = false
    self.kamp_states[ "post_harmonica" ] = false
  end

  -- втыкать в интернеты
  if npc:object( "device_pda" ) and math.random( 100 ) > 50 then
    -- вероятность 50%
    states[ "use_pda" ] = true
  else
    states[ "use_pda" ] = false
  end
  -- играть на гитаре
  if has_listeners and npc:object( "guitar_a" ) then
    states[ "play_guitar" ] = true
    states[ "wait_guitar" ] = true
    self.kamp_states[ "pre_guitar"  ] = true
    self.kamp_states[ "guitar"      ] = true
    self.kamp_states[ "post_guitar" ] = true
  else
    states[ "play_guitar" ] = false
    states[ "wait_guitar" ] = false
    self.kamp_states[ "pre_guitar"  ] = false
    self.kamp_states[ "guitar"      ] = false
    self.kamp_states[ "post_guitar" ] = false
  end
  -- играть на балалайке
  if has_listeners and npc:object( "balalaika_a" ) then
    states[ "play_balalaika" ] = true
    states[ "wait_balalaika" ] = true
    self.kamp_states[ "pre_balalaika"  ] = true
    self.kamp_states[ "balalaika"      ] = true
    self.kamp_states[ "post_balalaika" ] = true
  else
    states[ "play_balalaika" ] = false
    states[ "wait_balalaika" ] = false
    self.kamp_states[ "pre_balalaika"  ] = false
    self.kamp_states[ "balalaika"      ] = false
    self.kamp_states[ "post_balalaika" ] = false
  end

  -- анекдоты
  self.kamp_states[ "pre_joke"   ] = has_listeners
  self.kamp_states[ "joke"       ] = has_listeners
  self.kamp_states[ "post_joke"  ] = has_listeners

  -- Если чувак знает истории, надо добавить их к лагерю
  self.kamp_states[ "story"      ] = has_listeners
  self.kamp_states[ "post_story" ] = has_listeners
end


function CKampManager:addNpc( npc )
  if self.npc[ npc:id() ] ~= nil then return end
  self.npc[ npc:id() ] = {
    name     = npc:name(),
    can_eat  = ogse_kamp_eating.can_eat( npc ),
    can_talk = ( not is_woman_visual( npc ) ),
    speak    = 0,
  }
  if
    npc:character_community() == "monolith"
    or npc:character_community() == "zombied"
  then
    self.npc[ npc:id() ].states = {
      beer_a         = false,
      declarate      = true,
      eat_bread      = false,
      eat_energy     = false,
      eat_kolbasa    = false,
      eat_sandwich   = false,
      eat_vodka      = false,
      flaska         = false,
      kurit          = false,
      kurit_cigara   = false,
      play_balalaika = false,
      play_guitar    = false,
      play_harmonica = false,
      play_joke      = false,
      play_story     = false,
      sit            = false,
      sit_ass        = false,
      sit_knee       = false,
      sweetness      = false,
      trans          = true,
      use_pda        = false,
    }
  else
    self.npc[ npc:id() ].states = {
      beer_a         = false,
      declarate      = true,
      eat_bread      = false,
      eat_energy     = false,
      eat_kolbasa    = false,
      eat_sandwich   = false,
      eat_vodka      = false,
      flaska         = false,
      kurit          = false,
      kurit_cigara   = false,
      play_balalaika = false,
      play_guitar    = false,
      play_harmonica = false,
      play_joke      = false,
      play_story     = false,
      sit            = true,
      sit_ass        = true,
      sit_knee       = true,
      sweetness      = false,
      trans          = false,
      use_pda        = false,
    }
  end
  self.population     = self.population + 1
  self.seats_assigned = false
  local sobj = alife():object( npc:id() )
  ASSERT(
    sobj,
    "[%s]: [%s]: %s not found in alife()",
    script_name(), self.kamp_name, npc:name()
  )
  if
    ( not self.smart_terrain_id )
    or sobj:smart_terrain_id() < self.smart_terrain_id
  then
    self.smart_terrain_id = sobj:smart_terrain_id()
  end
  kamp_stalkers[ npc:id() ] = nil
end


function CKampManager:reset_director( npc )
  if self.director ~= npc:id() then return end
  self.npc[ npc:id() ].begin = nil
  self.director   = nil
  self.censor     = nil
  self.kamp_state = "idle"
  self.begin      = time_global()
  for kk, vv in pairs( self.npc ) do
    vv.new = true
  end
  xr_sound.set_sound( npc, nil, true )
end


function CKampManager:removeNpc( npc )
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return end
  -- Если удаляем режиссера - необходимо форсированно перевести лагерь
  -- в идловое состояние.
  self:reset_director( npc )
  self:free_seat( npc )
  self.npc[ npc_id ] = nil
  self.population = self.population - 1
  kamp_stalkers[ npc:id() ] = nil
end


function CKampManager:increasePops( npc )
  self.population_comed = self.population_comed + 1
  if self.population_comed == 1 then
    if not self.campfire then
      self.campfire = ogse_campfire.get_nearest_campfire(
        level.vertex_position( self.center ), 4
      )
    end
    if self.campfire then
      self.campfire.has_users = true
    end
  end
  self:reset_director( npc )
  kamp_stalkers[ npc:id() ] = nil
end


function CKampManager:decreasePops( npc )
  self.population_comed = self.population_comed - 1
  if self.population_comed == 0 and self.campfire then
    self.campfire.has_users = false
  end
  kamp_stalkers[ npc:id() ] = nil
end


function CKampManager:init_drop_dists()
  self.drop_dist_min = 10
  self.drop_dist_mid = 15
  self.drop_dist_max = 20
  self.drop_enabled  = true
  self.drop_height_max = 1.5
  local sect = "dsh.xr_kamp." .. self.kamp_name
  if sys_ini:section_exist( sect ) then
     self.drop_enabled = get_bool( sect, "drop_enabled", self.drop_enabled )
  end
end


function CKampManager:get_nearest_drop_point( obj )
  if not self.drop_points then
    self.drop_points = self:get_pos(
      self.drop_dist_max, false, self.drop_dist_mid, true
    )
    ASSERT(
      table.getn( self.drop_points ) > 0,
      "[%s]: %s: empty drop_points", script_name(), self.kamp_name
    )
  end
  local obj_pos = obj:position()
  table.sort(
    self.drop_points,
    function( a, b )
      local dist_a = level.vertex_position( a ):distance_to( obj_pos )
      local dist_b = level.vertex_position( b ):distance_to( obj_pos )
      return dist_a < dist_b
    end
  )
  return self.drop_points[ 1 ]
end


function CKampManager:init_seats()
  local sect = "dsh.xr_kamp." .. self.kamp_name
  if sys_ini:section_exist( sect ) then
    local seats = get_string( sect, "preferred_seats" )
    if seats then
      local preferred_seats = get_numbers( sect, "preferred_seats" )
      if table.getn( preferred_seats ) > 0 then
        self.preferred_seats  = {}
        for _, vertex in ipairs( preferred_seats ) do
          table.insert( self.preferred_seats, {
            [ "vertex" ] = vertex,
          });
        end
      end
    end
  end
  self.seats = {}
  local ai_step = 0.7 -- шаг AI сетки
  local dist    = self.min_radius
  while dist < self.drop_dist_mid do
    local found = self:get_pos( dist, self.allow_sector )
    local seats = {}
    for _, vertex in ipairs( found ) do
      table.insert( seats, {
        [ "vertex" ] = vertex,
      });
    end
    if table.getn( seats ) > 0 then
      table.insert( self.seats, seats )
    end
    dist = dist + ai_step
  end
end


function CKampManager:get_accessible_seats()
  local members = {}
  for npc_id, st in pairs( self.npc ) do
    local npc = level.object_by_id( npc_id )
    if npc and npc:alive() then
      table.insert( members, npc )
    end
  end
  local accessible = {}
  for _, seats in ipairs( self.seats ) do
    local good_seats = {}
    for _, seat in ipairs( seats ) do
      local bad = false
      for _, npc in ipairs( members ) do
        if not npc:accessible( seat.vertex ) then
          bad = true
          break
        end
      end
      if not bad then
        table.insert( good_seats, seat )
      end
    end
    if table.getn( good_seats ) > 0 then
      table.insert( accessible, good_seats )
    end
  end
  return accessible
end


function CKampManager:reassign_seats()
  if self.active_seats then
    for _, seat in ipairs( self.active_seats ) do
      seat.npc = nil
    end
  end
  self.active_seats   = nil
  self.seats_assigned = false
  local accessible_seats = self:get_accessible_seats()
  local found_seats
  for k = 2, 1, -1 do
    for i, seats in ipairs( accessible_seats ) do
      if table.getn( seats ) >= self.population * k then
        found_seats = i
        break
      end
    end
    if found_seats then break end
  end
--[=[
  ASSERT(
    found_seats,
    "[%s]: can't find active_seats for %s", script_name(), self.kamp_name
  )
--]=]
  for npc_id, st in pairs( self.npc ) do
    st.seat = nil
  end
  local avail_seats = {}
  if self.preferred_seats then
    table.insert( avail_seats, self.preferred_seats )
  end
  if found_seats then
    for i = found_seats, table.getn( accessible_seats ) do
      table.insert( avail_seats, accessible_seats[ i ] )
    end
  end
  for _, seats in ipairs( avail_seats ) do
    self.active_seats = seats
    local cnt  = 0
    local step = math.floor(
      table.getn( self.active_seats ) / self.population
    )
    for j = 1, table.getn( self.active_seats ), step do
      local seat     = self.active_seats[ j ]
      local seat_pos = level.vertex_position( seat.vertex )
      local min_dist, nearest_npc
      for npc_id, st in pairs( self.npc ) do
        local npc = level.object_by_id( npc_id )
        ASSERT(
          ( npc and npc:alive() ),
          "[%s]: [%s]: npc_id = %s not found or dead",
          script_name(), self.kamp_name, npc_id
        )
        if not st.seat then
          local dist = npc:position():distance_to( seat_pos )
          if ( not min_dist ) or dist < min_dist then
            min_dist    = dist
            nearest_npc = npc
          end
        end
      end
      if not nearest_npc then break end
      seat.npc = nearest_npc:id()
      self.npc[ nearest_npc:id() ].seat = j
      self:reset_position( nearest_npc )
      cnt = cnt + 1
      if cnt == self.population then
        self.seats_assigned = true
        break
      end
    end
    if self.seats_assigned then break end
  end
  ASSERT(
    self.seats_assigned,
    "[%s]: [%s]: can't reassign seats", script_name(), self.kamp_name
  )
end


function CKampManager:reset_position( npc )
  local t = db.storage[ npc:id() ][ self.scheme ]
  t.go_position = nil
  t.on_position = nil
  t.pos_vertex  = nil
end


function CKampManager:free_seat( npc )
  local npc_id = npc:id()
  local st     = self.npc[ npc_id ]
  if st.seat then
    local seat = self.active_seats[ st.seat ]
    seat.npc = nil
    st.seat  = nil
  end
end


function CKampManager:select_story( npc )
  local t = known_stories
  local story_by_id = db.story_by_id[ npc:id() ]
  if story_by_id and table.getn( story_by_id ) > 0 then
    t = {}
    for _, v in ipairs( known_stories ) do
      table.insert( t, v )
    end
    for _, v in ipairs( story_by_id ) do
      table.insert( t, v )
    end
  end
  self.selected_story = t[ math.random( table.getn( t ) ) ]
  npc:give_info_portion( self.selected_story )
end


-- Evaluators
-- Условие завершения скрипта
class "evaluator_kamp_end" ( property_evaluator )
function evaluator_kamp_end:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_kamp_end:evaluate()
  return not xr_logic.is_active( self.object, self.a )
end


-- Находимся ли мы на заданной позиции
class "evaluator_on_position" ( property_evaluator )
function evaluator_on_position:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_on_position:evaluate()
  self.a.updates_passed = 10
--[=[
  if not self.a.updates_passed then
    self.a.updates_passed = 0
  elseif self.a.updates_passed < 10 then
    self.a.updates_passed = self.a.updates_passed + 1
    return false
  end
--]=]
  if not self.a.pos_vertex then return false end
  local npc = self.object
  if self.a.on_position then
    self.a.go_position = nil
    if
      npc:level_vertex_id() == self.a.on_position[ 1 ]
      and npc:position():distance_to( self.a.on_position[ 2 ] ) < 1
    then
      ogse_debug.add_active_eval( npc, script_name(), "on_position" )
      return true
    else
      self.a.on_position = nil
      return false
    end
  elseif self.a.go_position then
    if npc:path_completed() then
      self.a.go_position = nil
      -- self.a.on_position = { npc:level_vertex_id(), npc:position() }
      self.a.on_position = {
        self.a.pos_vertex, level.vertex_position( self.a.pos_vertex )
      }
      return true
    end
    ogse_debug.add_active_eval( npc, script_name(), "go_position" )
  end
  return false
end


--added by xStream--
-- Оп-па! Увидели труп поблизости от костра, непорядок...
class "evaluator_see_deadman" ( property_evaluator )
function evaluator_see_deadman:__init( name, storage ) super( nil, name )
  self.a = storage
end


function evaluator_see_deadman:evaluate()
  if not self.a.kamp.drop_enabled then return false end
  local npc = self.object
  -- Есть дела поважнее, чем трупы складировать...
  if not xr_logic.is_active( self.object, self.a ) then
    if self.a.choosed_deadman then
      deadmansids[ self.a.choosed_deadman ] = nil
    end
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = nil
    self.a.reached         = nil
    -- log2(
    --   "[%s]: %s: reset because logic inactive",
    --   script_name(), self.object:name()
    -- )
    return false
  end

  -- Труп себе уже выбрали, не спускаем с него глаз...
  local point0 = level.vertex_position( self.a.kamp.center )
  if self.a.choosed_deadman then
    local obj
    if alife():object( self.a.choosed_deadman ) then
      obj = level.object_by_id( self.a.choosed_deadman )
    end
    if
      obj
      and obj:position():distance_to( point0 ) < self.a.kamp.drop_dist_min
      and math.abs( point0.y - obj:position().y ) < self.a.kamp.drop_height_max
    then
      ogse_debug.add_active_eval( self.object, script_name(), "see_deadman" )
      return true
    end
    -- если утащен далеко, то ну его нафиг...
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = true
    self.a.reached         = nil
    tried_too_much( obj, true )
    -- log2(
    --   "[%s]: %s: reset because coprse[%s] distance",
    --   script_name(), self.object:name(), ( obj and obj:name() or "nil" )
    -- )
    return false
  elseif self.a.failed then
    return false
  end

  if
    not (
      self.a.see_deadman_t
      and (
        ( not last_death_t ) or self.a.see_deadman_t > last_death_t
      )
    )
  then
    local clean    = true
    local creature = {}
    for id, _ in pairs( db.creature ) do
      table.insert( creature, id )
    end
    dsh.shuffle( creature )
    for _, id in ipairs( creature ) do
      local res = self:check_item( level.object_by_id( id ), point0 )
      if res then return true end
      if res == false then clean = false end
    end
    if clean then
      -- log2(
      --   "[%s]: %s: stop object loop, all clean",
      --   script_name(), self.object:name()
      -- )
      self.a.see_deadman_t = time_global()
    end
  end
  return false
end


function deadman_assigned( id )
  local npc_id = deadmansids[ id ]
  if not npc_id then return false end
  if alife():object( npc_id ) then
    local obj = level.object_by_id( npc_id )
    if obj and obj:alive() then
      return npc_id
    end
  end
  return false
end


function evaluator_see_deadman:choosed_by_somebody( id )
  local npc_id = deadman_assigned( id )
  if npc_id and self.a.kamp.npc[ npc_id ] then
    return true
  end
  return false
end


function tried_too_much( obj, inc )
  if not obj then return end
  local binder = obj:binded_object()
  local t = binder[ script_name() ]
  if not t then
    t = {}
    binder[ script_name() ] = t
  end
  if inc then
    t.tried_too_much = ( t.tried_too_much or 0 ) + 1
  end
  if t.tried_too_much and t.tried_too_much >= 5 then
    -- log2(
    --   "[%s]: %s: tried_too_much[%s]",
    --   script_name(), obj:name(), t.tried_too_much
    -- )
    return true
  end
  return false
end


function evaluator_see_deadman:check_item( obj, point0 )
  local npc = self.object
  -- если есть рядом с костром труп сталкера или монстра, его еще
  -- никто не прихватил себе и трупец нигде не застрял, то забираем
  -- его...
  if not ( obj and alife():object( obj:id() ) ) then return end
  obj = level.object_by_id( obj:id() )
  if
    not (
      obj and obj:is_custom_monster()
      and ( not obj:alive() )
      and obj:position():distance_to( point0 ) < self.a.kamp.drop_dist_min
      and math.abs( point0.y - obj:position().y ) < self.a.kamp.drop_height_max
      and not tried_too_much( obj )
    )
  then
    return
  end
  if self:choosed_by_somebody( obj:id() ) then return false end
  self.a.pre_choosed_deadman = obj:id()
  ogse_debug.add_active_eval( self.object, script_name(), "see_deadman_2" )
  return true
end


-- Тащим труп
class "evaluator_can_move_deadman" ( property_evaluator )
function evaluator_can_move_deadman:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_can_move_deadman:evaluate()
  if not self.a.choosed_deadman then return false end
  if not self.a.reached then return false end
  if not alife():object( self.a.choosed_deadman ) then return false end
  local obj = level.object_by_id( self.a.choosed_deadman )
  if not obj then return false end
  local npc = self.object
  if not npc:ph_capture() then
    ogse_debug.add_active_eval( self.object, script_name(), "can_move_1" )
    return true
  end
  if npc:ph_capture().e_state == ph_capture.pulling then
    ogse_debug.add_active_eval( self.object, script_name(), "can_move_2" )
    return true
  end
  -- если труп застрял (расстояние увеличилось), то возвращаемся к нему
  local dist = obj:position():distance_to( npc:position() )
    - obj:radius() - npc:radius()
  if dist < 1 then
    ogse_debug.add_active_eval( self.object, script_name(), "can_move_3" )
    return true
  end
  self.a.reached = nil
  return false
end


-- Actions
-- Идет в заданную область
class "action_go_position" ( action_base )
function action_go_position:__init( npc_name, action_name, storage)
  super( nil, action_name )
  self.a = storage
end


function action_go_position:initialize()
  action_base.initialize( self )
  self.object:set_desired_position()
  self.object:set_desired_direction()
  self.object:set_detail_path_type( move.curve )
  self.object:set_path_type( game_object.level_path )
  self.a.pos_vertex = nil
  local npc = self.object
  npc:set_movement_type( move.stand )
  npc:set_body_state( move.standing )
  state_mgr.set_state( self.object, "idle", nil, nil, nil, { animation = true } )
end


function action_go_position:execute()
  action_base.execute( self )
  if
    db.actor
    and xr_logic.try_switch_to_another_section( self.object, self.a, db.actor )
  then
    return
  end
  if ( not self.a.updates_passed ) or self.a.updates_passed < 10 then
    return
  end
  local npc = self.object
  if not self.ready_state then
    if xrs_battle_ai.is_not_ready_state( npc ) then return end
    self.ready_state = true
  end
  local target_vertex = self.a.kamp:getDestVertex( npc )
  if self.a.pos_vertex ~= target_vertex then
    self.a.pos_vertex = target_vertex
    npc:set_desired_position(
      level.vertex_position( self.a.pos_vertex )
    )
  end
  npc:set_dest_level_vertex_id( self.a.pos_vertex )
  state_mgr.set_state( npc, self.a.def_state_moving )
  self.a.go_position = ( self.a.go_position or 0 ) + 1
  self.a.on_position = nil
end


function action_go_position:finalize()
  action_base.finalize( self )
  self.ready_state = nil
end


-- Просто сидит и втыкает
class "action_wait" ( action_base )
function action_wait:__init( npc_name, action_name, storage)
  super( nil, action_name )
  self.a = storage
  self.a.signals = {}
end


function action_wait:initialize()
  action_base.initialize( self )
  local npc = self.object
  npc:set_desired_position()
  npc:set_desired_direction()
  if not self.a.kamp_user then
    self.a.kamp:increasePops( npc )
    self.a.kamp_user = true
  end
  self.a.signals.endpoint = true
  -- если пушка в руках - прячем, а то сидеть неудобно
  npc:set_item( object.idle, nil )
end


function action_wait:activate_scheme()
end


function action_wait:execute()
  action_base.execute( self )
  if not self.object:alive() then return end
  if
    xr_logic.try_switch_to_another_section( self.object, self.a, db.actor )
  then
    return
  end
  if not self.a.kamp_user then return end
  local state, sound, substate = self.a.kamp:updateNpc( self.object )
  if state == nil then
    state = "wait"
  end
  -- повернуть его лицом к центру
  local t = {}
  if self.a.kamp.campfire then
    t.look_object   = self.a.kamp.campfire.object
  else
    t.look_position = level.vertex_position( self.a.kamp.center )
  end
  state_mgr.set_state(
    self.object, state, nil, nil, t, nil, nil, { subanim = substate }
  )
  xr_sound.set_sound( self.object, sound )
end


function action_wait:finalize()
  self.a.go_position = nil
  self.a.on_position = nil
  self.a.signals     = {}
  if self.a.kamp_user then
    self.a.kamp:decreasePops( self.object )
    self.a.kamp_user = false
  end
  action_base.finalize( self )
  state_mgr.set_state( self.object, "idle", nil, nil, nil, { animation = true } )
end


function action_wait:deactivate( npc )
  if self.a.kamp_user then
    self.a.kamp:decreasePops( self.object )
    self.a.kamp_user = false
  end
  self.a.kamp:removeNpc( npc )
end


function action_wait:death_callback( npc )
  if self.a.kamp_user then
    self.a.kamp:decreasePops( self.object )
    self.a.kamp_user = false
  end
  self.a.kamp:removeNpc( npc )
end


function action_wait:net_destroy( npc )
  if self.a.kamp_user then
    self.a.kamp:decreasePops( self.object )
    self.a.kamp_user = false
  end
  self.a.kamp:removeNpc( npc )
end


-- added by xStream--
-- Идет к бездыханному товарищу
class "action_go_to_deadman" ( action_base )
function action_go_to_deadman:__init( npc_name, action_name, storage)
  super( nil, action_name )
  self.a = storage
end


function action_go_to_deadman:initialize()
  action_base.initialize( self )
  local npc = self.object
  local id  = self.a.pre_choosed_deadman
  local gi
  if alife():object( id ) then
    gi = level.object_by_id( id )
  end
  if gi then
    self.a.choosed_deadman  = gi:id()
    self.a.drop_lvid        = self.a.kamp:get_nearest_drop_point( gi )
    deadmansids[ gi:id() ] = npc:id()
  end

  npc:set_desired_position()
  npc:set_desired_direction()
  npc:set_path_type( game_object.level_path )

  local diff = level.vertex_position( self.a.drop_lvid ):sub( gi:position() )
  diff.y = 0
  diff:normalize()
  local pos  = vector():mad( gi:position(), diff, gi:radius() )
  local lvid = level.vertex_id_by_pos( pos )
  if not level.valid_vertex_id( lvid ) then
    lvid = level.vertex_id_by_pos( gi:level_vertex_id(), pos )
  end
  if level.valid_vertex_id( lvid ) then
    local pos = level.vertex_position( lvid )
    if
      math.abs( gi:position().y - pos.y ) > 2
      or is_geom_between( gi:position(), pos )
    then
      lvid = gi:level_vertex_id()
    end
  else
    lvid = gi:level_vertex_id()
  end
  self.target_lvid = lvid
  self.dest_lvid   = lvid
  if not npc:accessible( self.dest_lvid ) then
    self.dest_lvid = npc:accessible_nearest(
      level.vertex_position( self.target_lvid ), vector():set( 0, 0, 0 )
    )
  end

  self.a.failed      = nil
  self.a.no_loot     = true
  self.a.reached     = nil
  self.cur_dead_lvid = gi:level_vertex_id()
  -- на все гулянки в сторону трупа дается 30 секунд, если не успел, то
  -- да ну нафиг заморачиваться :)
  self.go_time_end   = time_global() + 30000
  npc:set_movement_type( move.stand )
  npc:set_body_state( move.standing )
  state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
  xr_sound.set_sound( npc, nil )
  stop_play_sound( npc )
end


function is_geom_between( pos1, pos2 )
  pos1.y = pos1.y + 1
  pos2.y = pos2.y + 1
  local diff = pos2:sub( pos1 )
  diff:normalize()
  local rq = level.ray_query(
    pos1, diff, pos1:distance_to( pos2 ), rq_target.rqtStatic, db.actor
  )
  return rq.result
end


function action_go_to_deadman:execute()
  action_base.execute ( self )
  -- если initialize() не смог назначить choosed_deadman
  if not self.a.choosed_deadman then return end
  local npc = self.object
  if not self.ready_state then
    if xrs_battle_ai.is_not_ready_state( npc ) then return end
    self.ready_state = true
  end
  local gi
  if alife():object( self.a.choosed_deadman ) then
     gi = level.object_by_id( self.a.choosed_deadman )
  end

  -- если уже задолбало дергать труп, а он застрял (дергаем 3 раза),
  -- то нафиг его. так же если какой то мимопроходящий товарищ труп с
  -- места сдвинул - то туда ему и дорога (трупу), а нам он больше не
  -- интересен.
  if
    self.go_time_end < time_global()
    or ( self.a.captures and self.a.captures == 5 )
    or ( not gi )
    or gi:level_vertex_id() ~= self.cur_dead_lvid
  then
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = true
    self.a.reached         = nil
    tried_too_much( gi, true )
    -- log2(
    --   "[%s]: %s: reset in action_go_to_deadman:execute(): gi[%s] go_time_end[%s] captures[%s] level_vertex_id[%s] cur_dead_lvid[%s]",
    --   script_name(), self.object:name(), ( gi and gi:name() or "nil" ),
    --   tostring( self.go_time_end < time_global() ),
    --   tostring( self.a.captures and self.a.captures == 5 ),
    --   gi:level_vertex_id(), tostring( self.cur_dead_lvid )
    -- )
    return
  end

  if not npc:accessible( self.dest_lvid ) then
    self.dest_lvid = npc:accessible_nearest(
      level.vertex_position( self.target_lvid ), vector():set( 0, 0, 0 )
    )
  end
  npc:set_detail_path_type( move.curve )
  npc:set_path_type( game_object.level_path )
  npc:set_dest_level_vertex_id( self.dest_lvid )
  state_mgr.set_state( self.object, self.a.def_state_moving )
  -- долгое путешествие до трупа успешно завершилось, ура, товарищи
  if
    npc:path_completed() or self.dest_lvid == npc:level_vertex_id()
    or (
      npc:position():distance_to( gi:position() ) < gi:radius() + npc:radius()
      and math.abs( gi:position().y - npc:position().y ) < 2
      and not is_geom_between( gi:position(), npc:position() )
    )
  then
    self.a.reached = true
  end
end


function action_go_to_deadman:finalize()
  action_base.finalize( self )
  self.a.failed  = nil
  self.a.no_loot = nil
  if self.a.reached then
    self.a.captures = ( self.a.captures or 0 ) + 1
  else
    -- log2(
    --   "[%s]: %s: reset in action_go_to_deadman:finalize()",
    --   script_name(), self.object:name()
    -- )
    if self.a.choosed_deadman then
      deadmansids[ self.a.choosed_deadman ] = nil
    end
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.reached         = nil
  end
  self.ready_state = nil
  state_mgr.set_state( self.object, "idle", nil, nil, nil, { animation = true } )
end


-- Тащит трупец
class "action_moving_deadman"( action_base )
function action_moving_deadman:__init( npc_name, action_name, storage )
  super( nil, action_name )
  self.a = storage
end


function action_moving_deadman:initialize()
  action_base.initialize( self )
  local gi
  if alife():object( self.a.choosed_deadman ) then
    gi = level.object_by_id( self.a.choosed_deadman )
  end
  local ps = gi and gi:get_physics_shell()
  if not ps then
    -- log2(
    --   "[%s]: %s: reset in action_moving_deadman:initialize(): gi[%s]",
    --   script_name(), self.object:name(),
    --   ( gi and gi:name() or "nil" )
    -- )
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = true
    self.a.reached         = nil
    return
  end

  local npc = self.object
  -- если пушка в руках - прячем, а то тащить неудобно
  if npc:weapon_unstrapped() then
    npc:set_item( object.idle, nil )
  end

  -- state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )

  -- на таскание трупа в грязи даем 30 секунд
  self.time_end  = time_global() + 30000
  -- на приседание рядом с трупом и разворот лицом дадим секунду
  self.time_drag = time_global() +   500

  self.drop_lvid   = self.a.drop_lvid
  self.target_lvid = self.a.drop_lvid
  self.a.failed    = nil
  self.a.no_loot   = true
end


function action_moving_deadman:execute()
  action_base.execute( self )
  if not self.a.choosed_deadman then return end
  local npc = self.object
  local gi
  if alife():object( self.a.choosed_deadman ) then
    gi = level.object_by_id( self.a.choosed_deadman )
  end

  -- хватит таскать труп - время истекло, пусть другие этим занимаются
  if self.time_end < time_global() or not gi then
    -- log2(
    --   "[%s]: %s: reset in action_moving_deadman:execute(): gi[%s] time_end[%s]",
    --   script_name(), self.object:name(), ( gi and gi:name() or "nil" ),
    --   tostring( self.time_end < time_global() )
    -- )
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = true
    self.a.reached         = nil
    if gi then tried_too_much( gi, true ) end
    return
  end

  local dir = gi:position():sub( npc:position() )
  dir.y = 0
  npc:set_sight( look.direction, dir, true )
  npc:set_movement_type( move.walk )
  npc:set_mental_state( anim.danger )
  npc:set_body_state( move.crouch )
  npc:movement_enabled( true )

  if self.time_drag > time_global() then return end

  if not npc:accessible( self.drop_lvid ) then
    self.drop_lvid = npc:accessible_nearest(
      level.vertex_position( self.target_lvid ), vector():set( 0, 0, 0 )
    )
  end
  if not npc:ph_capture() then
    npc:ph_capture_object( gi, "bip01_l_hand" )
    local cap  = self.object:ph_capture()
    local dist = npc:position():distance_to( gi:position() )
    if dist > cap.pull_distance then
      cap.pull_distance = dist
    end
    cap.hard_mode = true
    -- cap.capture_force = 100000
    -- cap.pull_force    = 100000
    return
  elseif npc:ph_capture().e_state == ph_capture.pulling then
    return
  end

  npc:set_detail_path_type( move.curve )
  npc:set_path_type( game_object.level_path )
  npc:set_dest_level_vertex_id( self.drop_lvid )
  -- уф! дотащили... всем спасибо, все свободны...
  if npc:path_completed() or self.drop_lvid == npc:level_vertex_id() then
    -- log2(
    --   "[%s]: %s: reset 2 in action_moving_deadman:execute(): gi[%s]",
    --   script_name(), self.object:name(),
    --   ( gi and gi:name() or "nil" )
    -- )
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.failed          = true
    self.a.reached         = nil
    tried_too_much( gi, true )
  end
end


function action_moving_deadman:finalize()
  action_base.finalize( self )
  self.a.failed  = nil
  self.a.no_loot = nil
  if self.object:ph_capture() then
    self.object:ph_release_object()
  end
  if self.a.reached then
    -- log2(
    --   "[%s]: %s: reset in action_moving_deadman:finalize()",
    --   script_name(), self.object:name()
    -- )
    if self.a.choosed_deadman then
      deadmansids[ self.a.choosed_deadman ] = nil
    end
    self.a.captures        = nil
    self.a.choosed_deadman = nil
    self.a.reached         = nil
  end
  local npc = self.object
  npc:set_movement_type( move.stand )
  npc:set_body_state( move.standing )
  state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
end


evid_see_deadman = xr_evaluators_id.stohe_kamp_base + 3

-- Kamp binder
function add_to_binder( object, ini, scheme, section, storage )
  local properties = {
    [ "kamp_end"         ] = xr_evaluators_id.stohe_kamp_base + 1,
    [ "on_position"      ] = xr_evaluators_id.stohe_kamp_base + 2,
    [ "see_deadman"      ] = evid_see_deadman,
    [ "can_move_deadman" ] = xr_evaluators_id.stohe_kamp_base + 5,
  }

  local operators  = {
    [ "go_position"   ] = xr_actions_id.stohe_kamp_base + 1,
    [ "wait"          ] = xr_actions_id.stohe_kamp_base + 3,
    [ "go_to_deadman" ] = xr_actions_id.stohe_kamp_base + 4,
    [ "move_deadman"  ] = xr_actions_id.stohe_kamp_base + 5,
  }

  -- Evaluators
  local manager = object:motivation_action_manager()
  manager:add_evaluator(
    properties.kamp_end,
    this.evaluator_kamp_end( "kamp_end", storage, "kamp_end" )
  )
  manager:add_evaluator(
    properties.on_position,
    this.evaluator_on_position(
      "kamp_on_position", storage, "kamp_on_position"
    )
  )

  local zombi = object:character_community() == "zombied"
    or object:character_community() == "trader"
    or object:character_community() == "arena_enemy"
    or object:name() == "mil_stalker0012"
    or object:name() == "yantar_ecolog_general"
  if zombi then
    manager:add_evaluator(
      properties.see_deadman, property_evaluator_const( false )
    )
    manager:add_evaluator(
      properties.can_move_deadman, property_evaluator_const( false )
    )
  else
    manager:add_evaluator(
      properties.see_deadman,
      this.evaluator_see_deadman( "see_deadman", storage, "see_deadman" )
    )
    manager:add_evaluator(
      properties.can_move_deadman,
      this.evaluator_can_move_deadman(
        "can_move_deadman", storage, "can_move_deadman"
      )
    )
  end

  -- Actions
  local action = this.action_wait( object:name(), "action_kamp_wait", storage )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  action:add_precondition(
    world_property( properties.see_deadman,       false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.on_position,       true  )
  )
  action:add_effect( world_property( properties.kamp_end, true ) )
  manager:add_action( operators.wait, action )
  xr_logic.subscribe_action_for_events( object, storage, action )

  action = this.action_go_position( object:name(), "action_go_kamp", storage )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  action:add_precondition(
    world_property( properties.see_deadman,       false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.on_position,       false )
  )
  action:add_effect( world_property( properties.on_position, true ) )
  manager:add_action( operators.go_position, action )

  -- видим труп - идем разбираться...
  action = this.action_go_to_deadman(
    object:name(), "action_go_to_deadman", storage
  )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.see_deadman,       true  )
  )
  action:add_precondition(
    world_property( properties.can_move_deadman,  false )
  )
  action:add_precondition(
    world_property( properties.kamp_end,          false )
  )
  action:add_effect( world_property( properties.can_move_deadman, true ) )
  manager:add_action( operators.go_to_deadman, action )

  -- тащим труп подальше от тусовки
  action = this.action_moving_deadman(
    object:name(), "action_moving_deadman", storage
  )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.see_deadman,       true  )
  )
  action:add_precondition(
    world_property( properties.can_move_deadman,  true  )
  )
  action:add_precondition(
    world_property( properties.kamp_end,          false )
  )
  action:add_effect( world_property( properties.see_deadman,      false ) )
  action:add_effect( world_property( properties.can_move_deadman, false ) )
  manager:add_action( operators.move_deadman, action )

  action = manager:action(xr_actions_id.alife )
  action:add_precondition(
    world_property( properties.kamp_end, true )
  )
end


-- включение лагеря
function set_scheme( npc, ini, scheme, section, gulag_name )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  st.logic = xr_logic.cfg_get_switch_conditions( ini, section, npc )
  local center_point = utils.cfg_get_string(
    ini, section, "center_point", npc, true, gulag_name
  )
  local radius       = get_float( section, "radius", nil, ini )
  st.kamp            = get_my_kamp( npc, center_point, scheme, radius )
  st.kamp:addNpc( npc )
  st.kamp_user       = false
  st.pos_vertex      = nil

  st.def_state_moving = utils.cfg_get_string(
    ini, section, "def_state_moving", npc, false, "", "walk"
  )
  if st.def_state_moving == nil or st.def_state_moving == "nil" then
    st.def_state_moving = "walk"
  end
end


function can_talk( npc )
  return kamp_stalkers[ npc:id() ] ~= false
end
