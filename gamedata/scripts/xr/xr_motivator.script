-- -*- mode: lua; coding: windows-1251-dos -*-
--/amk_rel_1/
-- автор: Диденко Руслан (Stohe)
-- порядок вызова методов биндера:
-- reload
-- reinit
-- load
-- net_spawn

function look_to_shot( object, who )
  if not who then return end
  if
    ( who:is_actor() or who:is_custom_monster() )
    and ( object:alive() and who:alive() )
    and ( not xr_wounded.is_wounded( object ) )
  then
    if object:best_enemy() then
      local be         = object:best_enemy()
      local enemy_dist = object:position():distance_to( be:position() )
      local who_dist   = object:position():distance_to( who:position() )
      if who_dist < enemy_dist then
        object:set_sight( look.danger, who:bone_position( "bip01_head" ) )
      end
    else
      object:set_sight( look.danger, who:bone_position( "bip01_head" ) )
    end
  end
end


function recognize_sound( sound_type )
  -- Выясняем тип звука
  local sn_t
  if bit_and( sound_type, snd_type.weapon ) == snd_type.weapon then
    sn_t = "WPN"
    if bit_and( sound_type, snd_type.weapon_shoot ) == snd_type.weapon_shoot then
      sn_t = "WPN_shoot"
    elseif
      bit_and( sound_type, snd_type.weapon_empty ) == snd_type.weapon_empty
    then
      sn_t = "WPN_empty"
    elseif
      bit_and( sound_type, snd_type.weapon_bullet_hit ) == snd_type.weapon_bullet_hit
    then
      sn_t = "WPN_hit"
    elseif
      bit_and( sound_type, snd_type.weapon_reload ) == snd_type.weapon_reload
    then
      sn_t = "WPN_reload"
    end
  elseif bit_and( sound_type, snd_type.item ) == snd_type.item then
    sn_t = "ITM"
    if
      bit_and( sound_type, snd_type.item_pick_up ) == snd_type.item_pick_up
    then
      sn_t = "ITM_pckup"
    elseif bit_and( sound_type, snd_type.item_drop ) == snd_type.item_drop then
      sn_t = "ITM_drop"
    elseif bit_and( sound_type, snd_type.item_hide ) == snd_type.item_hide then
      sn_t = "ITM_hide"
    elseif bit_and( sound_type, snd_type.item_take ) == snd_type.item_take then
      sn_t = "ITM_take"
    elseif bit_and( sound_type, snd_type.item_use ) == snd_type.item_use then
      sn_t = "ITM_use"
    end
  elseif bit_and( sound_type, snd_type.monster ) == snd_type.monster then
    sn_t = "MST"
    if bit_and( sound_type, snd_type.monster_die ) == snd_type.monster_die then
      sn_t = "MST_die"
    elseif
      bit_and( sound_type, snd_type.monster_injure ) == snd_type.monster_injure
    then
      sn_t = "MST_damage"
    elseif
      bit_and( sound_type, snd_type.monster_step ) == snd_type.monster_step
    then
      sn_t = "MST_step"
    elseif
      bit_and( sound_type, snd_type.monster_talk ) == snd_type.monster_talk
    then
      sn_t = "MST_talk"
    elseif
      bit_and( sound_type, snd_type.monster_attack ) == snd_type.monster_attack
    then
      sn_t = "MST_attack"
    elseif
      bit_and( sound_type, snd_type.monster_eat ) == snd_type.monster_eat
    then
      sn_t = "MST_eat"
    end
  elseif sound_type == snd_type.attack then
    sn_t = "ATTCK"
  elseif sound_type == snd_type.bullet_hit then
    sn_t = "BULLET"
  elseif sound_type == snd_type.die then
    sn_t = "DIE"
  elseif sound_type == snd_type.injure then
    sn_t = "INJURE"
  end
  return sn_t
end


local hear_something = {
  [ 1 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_1",
  [ 2 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_2",
  [ 3 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_3",
  [ 4 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_4",
  [ 5 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_5",
  [ 6 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_6",
  [ 7 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_7",
  [ 8 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_8",
  [ 9 ] = "characters_voice\\human_01\\dolg\\reactions\\hear_something\\hear_9",
}

local nothing_there = {
  [ 1 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_1",
  [ 2 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_2",
  [ 3 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_3",
  [ 4 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_4",
  [ 5 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_5",
  [ 6 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_6",
  [ 7 ] = "characters_voice\\human_01\\dolg\\reactions\\nothing\\nothing_7",
}


function silent_level()
  if
    level.name() == "l08u_brainlab"
    or level.name() == "l10u_bunker"
    or level.name() == "l12_stancia"
    or level.name() == "l12u_sarcofag"
    or level.name() == "l12u_control_monolith"
    or level.name() == "l12_stancia_2"
  then
    return true
  else
    return false
  end
end


function check_art_weapon( npc )
  ------------------------------
  -- Изредка движок сглюкивает, назначая неписю в слот артефакт этого
  -- следует избежать, так как такие неписи застревают на попытке
  -- применения арта как оружия
  ------------------------------
  local item_in_slot = npc:item_in_slot( 1 )
  local act_item     = npc:active_item()
  if act_item and item_in_slot and act_item:id() == item_in_slot:id() then
    local item_in_slot_sec = act_item:section()
    local item_in_slot_id  = act_item:id()
    if
      item_in_slot_sec and item_in_slot_id
      and (
        string.find( item_in_slot_sec, "af_", 1, true )
        or string.find( item_in_slot_sec, "caps_", 1, true )
        or string.find( item_in_slot_sec, "_cocoon", -7, true )
      )
    then
      -- Если непись получил арт в слот по ошибке при загрузке игры,
      -- мы просто обновим ему оружие в руках и всё. Иначе, если он
      -- взял арт в руки и отказывается его убирать, а лучшее оружие
      -- получить не удаётся, придётся арт выбросить, отрелизить и
      -- вернуть ему в рюкзак.
      local bw     = npc:best_weapon()
      local be     = npc:best_enemy()
      local rem_id = npc:active_item():id()
      npc:drop_item( npc:active_item() )
      local s_obj = alife():object( rem_id )
      if s_obj then
        alife():release( s_obj, true )
        alife():create(
          item_in_slot_sec,
          npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
        )
      end
      if bw and bw:is_weapon() then
        if be then
          npc:set_item( object.fire1, bw )
        else
          npc:set_item( object.idle, bw )
        end
      end
    end
  end
end


class "motivator_binder" ( object_binder )
function motivator_binder:__init( obj ) super( obj )
  self.loaded             = false
  self.first_update       = false
  self.treasure_processed = false
  self.rot_time           = 65535
  self.am = ogse_signals.get_mgr()
  self.am:call( "on_npc_init", obj, self )
end


function motivator_binder:extrapolate_callback( cur_pt )
  if self.object == nil then return false end
  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "extrapolate_callback"
    )
    self.st.move_mgr:extrapolate_callback( self.object, cur_pt )
  end
  if patrol( self.object:patrol() ):flags( cur_pt ):get() == 0 then
    return true
  end
  return false
end


function motivator_binder:reinit()
  if self.object == nil then return end
  object_binder.reinit(self)
  db.storage[ self.object:id() ] = {  followers = {} }
  self.st = db.storage[ self.object:id() ]
  --' Создание менеджера контроля положений тела
  self.st.state_mgr = state_mgr.bind_manager( self.object )
  self.st.move_mgr  = move_mgr.move_mgr( self.object )
  self.st.move_mgr:initialize()
end


function motivator_binder:net_spawn( sobject )
  ASSERT(
    not db.net_spawning_obj,
    "found net_spawning_obj = %s",
    tostring( db.net_spawning_obj and db.net_spawning_obj:name() or nil )
  )
  db.net_spawning_obj = self.object
  self.rot = self.rot_time <= amk.game_hours()
--  ogse.fix_restrictors( self.object )
  db.add_obj( self.object )

  if not self.loaded then
    self.loaded = xr_logic.load_logic_online( self.object )
    for _, k in ipairs({
      "active_section", "ini_filename", "section_logic", "gulag_name"
    }) do
      self.st[ "loaded_" .. k ] = self.st[ k ]
    end
  end

  -- Все CALLBACK-и ставить здесь:
  if self.object:alive() then
    self.object:set_patrol_extrapolate_callback(
      motivator_binder.extrapolate_callback, self
    )
    self.object:set_callback(
      callback.hit, motivator_binder.hit_callback, self
    )
    self.object:set_callback(
      callback.death, motivator_binder.death_callback, self
    )
    self.object:set_callback(
      callback.entity_alive_before_hit, self.before_hit_callback, self
    )
    self.object:set_callback( callback.on_item_drop, self.on_item_drop, self )
    self.object:set_callback( callback.on_item_take, self.on_item_take, self )
    self.object:set_callback(
      callback.on_throw_grenade, self.on_throw_grenade, self
    )
    self.object:set_enemy_callback( self.enemy_callback, self )
--[=[
    if not ogse.is_quest_npc( self.object ) then
      self.object:set_callback(
        callback.sound, motivator_binder.hear_callback, self
      )
    end
--]=]
  else
    self:set_slowest_scheduler()
  end
  self.object:set_callback(
    callback.use_object, motivator_binder.use_callback, self
  )

  self.am:call( "on_npc_before_spawn", self.object, self )

  --' Загрузка историй для лагеря.
  if self.loaded == false then
    local char_ini = self.object:spawn_ini()
      or dsh.cached_ini_file( "scripts\\dummy.ltx" )
    xr_info.loadInfo( self.object, char_ini )
  end

  if not self.object:alive() then
    self.treasure_processed = true
    self.am:call( "on_npc_spawn", self.object, self )
    db.net_spawning_obj = false
    return true
  end

  local manager = self.object:motivation_action_manager()
  manager:remove_evaluator( stalker_ids.property_anomaly )
  manager:add_evaluator(
    stalker_ids.property_anomaly, property_evaluator_const( false )
  )

  manager:add_evaluator(
    xrs_battle_ai.evid_altcombat, property_evaluator_const( false )
  )

  manager:add_evaluator(
    blowout_scheme.evid_outside, property_evaluator_const( false )
  )
  manager:add_evaluator(
    blowout_scheme.evid_blowout, property_evaluator_const( false )
  )
  manager:add_evaluator(
    blowout_scheme.evid_preblowout, property_evaluator_const( false )
  )

  xr_gulag.setup_gulag_and_logic_on_spawn(
    self.object, self.st, sobject, modules.stype_stalker, self.loaded
  )

  -- торговля должна быть инициализирована всегда, поэтому нужно вызвать
  -- trade_init(), если xr_logic.initialize_obj() не был вызван в
  -- setup_gulag_and_logic_on_spawn()
  if not trade_manager.get_cfg( self.object ) then
    trade_manager.trade_init( self.object )
  end

  if not ogse.is_quest_npc( self.object ) then
    news_main.on_spawn( self.object )
  end

  -- added by xStream for AMK miniSDK
  amk.on_npc_spawn( self.object )
  amk.on_net_spawn( self.object )
  -- end of addition

  local particle_param = utils.cfg_get_string(
    sys_ini, self.object:section(), "bones_particles", nil, false, false, nil
  )
  if particle_param and sys_ini:section_exist( particle_param ) then
    local tmp = amk.parse_ini_section_to_array( sys_ini, particle_param )
    for k, v in pairs( tmp ) do
      local t = amk.parse_ini_section_to_array( sys_ini, v )
      t.obj = self.object
      if not t.stop_on_death or self.object:alive() then
        play_particle( self.object, t )
      end
    end
  end

  self.am:call( "on_npc_spawn", self.object, self )
  db.net_spawning_obj = false

  return true
end


function motivator_binder:net_destroy()
  xr_logic.save_logic_online( self.object )
  local st = db.storage[ self.object:id() ]
  if st.active_scheme then
    xr_logic.issue_event(
      self.object, st[ st.active_scheme ], "net_destroy", self.object
    )
  end

  self.am:call( "on_npc_net_destroy", self.object, self )
  self.am:cleanup_signal_subs( "on_npc_update." .. self.object:id() )

  if self.object == nil then return end
  db.del_obj( self.object )
  db.storage[ self.object:id() ] = nil
  self:clear_callbacks()
  self.object:set_callback( callback.use_object, nil )

  object_binder.net_destroy( self )

  -- АМК. Очистка рестрикторов
  local id   = self.object:id()
  local sobj = alife():object( id )
  if sobj then
    alife():remove_in_restrictions( sobj )
  end
end


function motivator_binder:clear_callbacks()
  self.object:set_patrol_extrapolate_callback( nil )
  self.object:set_callback( callback.hit, nil )
  self.object:set_callback( callback.death, nil )
  self.object:set_callback( callback.on_item_drop, nil )
  self.object:set_callback( callback.on_item_take, nil )
  self.object:set_callback( callback.entity_alive_before_hit, nil )
  self.object:set_callback( callback.sound, nil )
  self.object:set_callback( callback.on_throw_grenade, nil )
  self.object:set_enemy_callback()
end


function motivator_binder:before_hit_callback( hit_data )
  if not self.last_hit_data then
    self.last_hit_data = {}
  end
  dsh.copy_hit_data( hit_data, self.last_hit_data )
  local ignored = false
  local obj     = level.object_by_id( hit_data.who_id )
  if obj then -- если есть виновник хита
    local blame_actor =
      get_bool( obj:section(), "dsh.hit_who_is_actor", false )
      or obj:is_grenade()
      or smart_monster_parts.is_handmade_monster( obj )
    -- проверяем условия игнорирования урона от дружественного огня
    if
      obj:id() == self.object:id()
      or ( obj:is_stalker() and is_friendly_fire( self.object, obj ) )
      or (
        ( blame_actor or obj:is_actor() )
        and db.actor:has_info( "volna_goodwill" )
        and level.name() == "zaton"
        and not self.object:is_relation_enemy( db.actor )
      )
    then
      -- подстрелил друг, игнорируем
      hit_data.ignore_hit = true
    elseif blame_actor then
      hit_data.who    = db.actor
      hit_data.who_id = db.actor:id()
    end
  end

  if not hit_data.ignore_hit then
    local hit_power = hit_data.power
    self.am:call( "on_npc_before_hit", self.object, hit_data )
    if not hit_data.ignore_hit then
      if hit_data.power < hit_power and hit_data.power == 0 then
        self.fake_hit_power = hit_power
      end
    end
  end
end


function is_friendly_fire( npc, who )
  local enemy = xrs_battle_ai.get_target( who ) or who:best_enemy()
  if enemy and enemy:id() == npc:id() then
    return false
  end
  if not (
    npc:is_relation_enemy( who )
    or who:is_relation_enemy( npc )
  ) then
    return true
  end
  if
    who:name() == "sak_military_stalker"
    or npc:name() == "sak_military_stalker"
  then
    return not xrs_battle_ai.check_is_enemy( npc, who )
  end
  return false
end


function motivator_binder:hit_callback( obj, amount, local_direction, who, bone_index )
  if not self.object then self.object = obj end
  if self.fake_hit_power then
    amount = self.fake_hit_power
    self.fake_hit_power = nil
  end

  if self.object:alive() then
    local dist = self.object:position():distance_to( who:position() )
    if dist > self.object:range() then
      self.object:set_range( dist * 1.1 )
    end
    if self.object:fov() < 180 then
      self.object:set_fov( 180 )
    end
    -- self.object:make_object_visible_somewhen( who )
  end

  -- FIXME: коллбеки неплохо было бы регистрировать в общем storage, а не посхемно...
  -- просто всегда ставить их при включении схемы и снимать при отключении.
  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "hit_callback",
      obj, amount, local_direction, who, bone_index
    )
  end

  if self.st.combat_ignore then
    xr_logic.issue_event(
      self.object, self.st.combat_ignore, "hit_callback",
      obj, amount, local_direction, who, bone_index
    )
  end

  if self.st.combat then
    xr_logic.issue_event(
      self.object, self.st.combat, "hit_callback",
      obj, amount, local_direction, who, bone_index
    )
  end

  if self.st.hit then
    xr_logic.issue_event(
      self.object, self.st.hit, "hit_callback",
      obj, amount, local_direction, who, bone_index
    )
  end

  if amount > 0 then
    sr_territory.issue_event(
      self.object, "hit_callback", obj, amount, local_direction, who, bone_index
    )
    if self.object then
      xr_wounded.hit_callback( self.object:id() )
    else
      xr_wounded.hit_callback( obj:id() )
    end
  end

--[=[
  if not ogse.is_quest_npc( obj ) then
    if
      ( not self.look_to_shot_t ) or self.look_to_shot_t < time_global()
    then
      look_to_shot( self.object, who )
      self.look_to_shot_t = time_global() + math.random( 1000, 2000 )
    end
  end
--]=]

  self.am:call(
    "on_npc_hit", self.object, amount, local_direction, who, bone_index
  )
end


function motivator_binder:death_callback( victim, who )
  xr_statistic.addKillCount( who, self.object )

  if self.st.death then
    xr_logic.issue_event(
      self.object, self.st.death, "death_callback", self.object, who
    )
  end

  if self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "death_callback",
      self.object, who
    )
  end

  sr_territory.issue_event( self.object, "death_callback", self.object, who )
  smart_terrain.on_death( self.object:id() )

  -- added by xStream for AMK miniSDK
  news_main.on_death( self.object, who )
  amk.on_death( self.object, who )
  -- end of addition

  self:clear_callbacks()
  self.reschedule_later = time_global() + 5000;

  actor_stats.remove_from_ranking( self.object:id() )

  self.am:call( "on_npc_death", self.object, who )
end


function motivator_binder:use_callback( obj, who )
  if not self.object then
    if obj then
      self.object = obj
    else
      return
    end
  end

  if self.object:alive() then
    xr_use.notify_on_use( obj, who )
    if self.st.active_section then
      xr_logic.issue_event(
        self.object, self.st[ self.st.active_scheme ], "use_callback", obj, who
      )
    end
  else
    if self.treasure_processed == false then
      treasure_manager:get_treasure_manager():use( self.object )
      self.treasure_processed = true
    end
    if self.object:name() == "rostok_dead_stalker_0000" then
      db.actor:give_info_portion( "acv_vandal" )
    end
  end

  if self.object and not self.dsh_busy_hands_nonusable then
    if string.find( self.object:section(), "zombie" ) then
      sak.zombie_checkup()
    end
  end

  -- added by xStream for AMK miniSDK
  amk.on_use( obj, who )
  -- end of addition

  self.am:call( "npc_use", self.object, who )
end


function motivator_binder:update( delta )
  object_binder.update( self, delta )

  if amk.oau_watchdog ~= 0 then
    if db.actor and not device():is_paused() then
      local snd_obj = xr_sound.get_safe_sound_object( "detectors\\da-2_beep1" )
      snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 2.5 )
    end
    abort( "Watchdog "..amk.oau_watchdog..".Reason "..amk.oau_reason )
  end
  if self.object == nil then return end

  local self_object_id = self.object:id()
  db.storage[ self_object_id ].us = 99

  if self.object:alive() then
    if self.object:is_talk_enabled() then
      self.object:set_tip_text( "character_use" )
    else
      self.object:set_tip_text( "" )
    end
  elseif self.reschedule_later and self.reschedule_later < time_global() then
    self:set_slowest_scheduler()
    self.reschedule_later = nil
  end

  db.storage[ self_object_id ].us =  0

  if not self.first_update then
    self.first_update = true
    check_art_weapon( self.object )
    self.am:call( "on_npc_first_update", self.object, delta )
  end
  self.am:call( "on_npc_update", self.object, delta )
  self.am:call( "on_npc_update." .. self.object:id(), self.object, delta )

--[=[
  if not self.snd_check_timer then
    self.snd_check_timer = time_global() + math.random( 1000, 2000 )
  end
--]=]
end


function motivator_binder:reload( section )
  object_binder.reload( self, section )
end


function motivator_binder:net_save_relevant()
  return true
end


function motivator_binder:save( packet )
  ASSERT(
    not db.saving_obj,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  if rx_wmgr then
    rx_wmgr.return_all()
  end
  object_binder.save( self, packet )
  packet:w_bool( self.treasure_processed )
  xr_logic.save_obj( self.object, packet )
  dialog_manager.save( self.object, packet )
  trade_manager.save( self.object, packet )
  if self.rot_time == 65535 and not self.object:alive() then
    -- помер, либо гг нашел труп - выставляем время гниения
    self.rot_time = amk.game_hours() + 24
  end
  packet:w_u16( self.rot_time )
  if utils.level_changing() then
    xr_logic.save_logic_online( self.object )
  end
  db.saving_obj = false
end


function motivator_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  if reader:r_eof() then
    if self.object:alive() then
      log1( "SAVE FILE IS CORRUPT - XR_MOTIV, OBJ: "..tostring(self.object:name()).." ID "..self.object:id().." PRO: "..self.object:profile_name() )
    else
      log1( "ERROR: CORRUPTED QUEST BODY FOUND! "..tostring(self.object:name()).." ID "..self.object:id().." PRO: "..self.object:profile_name() )
      db.actor:give_game_news( "ВНИМАНИЕ! Обнаружен повреждённый квестовый труп! Объект: "..self.object:character_name().." ИД: "..self.object:id().." Профиль: "..self.object:profile_name().." Убедитесь что с телом всё в порядке, и с него выдаются все необходимые инфопоршены и вещи!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000 )
    end
    remove_zavis.remove_obj( self.object )
    return true
  end
  self.treasure_processed = reader:r_bool()
  xr_logic.load_obj( self.object, reader )
  self.npc_script_version = alife():object( self.object:id() ).script_version
  dialog_manager.load( self.object, reader, self.npc_script_version )
  trade_manager.load( self.object, reader )
  if not reader:r_eof() then -- для обратной совместимости
    self.rot_time = reader:r_u16()
  end
end


function motivator_binder:hear_callback( obj, who, sound_type, sound_position, sound_power )
  if self.snd_check_timer and self.snd_check_timer > time_global() then
    return
  end
  self:check_sound( who, sound_type, sound_position, sound_power )
  self.snd_check_timer = nil
end


function motivator_binder:check_sound( who, sound_type, sound_position, sound_power )
  local npc = self.object
  if
    not (
      who and alife():object( who:id() )
      and who:id() ~= npc:id()
      and ( who:is_actor() or who:is_custom_monster() ) and who:alive()
      and ( not npc:best_enemy() )
      and ( not xr_wounded.is_wounded( npc ) )
      and sound_type and sound_position and sound_power
    )
  then
    return
  end

  local who_dist = npc:position():distance_to( who:position() )
  if who_dist > 100 then
    return
  end

  local actsch
  if db.storage[ npc:id() ] then
    actsch = db.storage[ npc:id() ].active_scheme
  end

  if
    actsch and (
      actsch == "remark" or actsch == "wounded" or actsch == "actor_dialogs"
    )
  then
    return
  end

  local snd_t = recognize_sound( sound_type )
  if not snd_t then return end

  -- Если тип задан проверим реакцию на него
  if
    ( who:is_actor() or who:is_stalker() )
    and xrs_battle_ai.check_is_enemy( npc, who )
  then
    if
      snd_t == "WPN_empty" or snd_t == "WPN_reload"
      or snd_t == "ITM_drop" or snd_t == "ITM_use"
    then
      local check_dist = 8 * sound_power
      if who_dist > check_dist and not silent_level() then
        if
          npc:character_community() ~= "zombied"
          and (
            ( not self.warn_check_timer )
            or self.warn_check_timer < time_global()
          )
        then
          local snd_name = nothing_there[
            math.random( table.getn( nothing_there ) )
          ]
          local snd_obj = xr_sound.get_safe_sound_object( snd_name )
          if snd_obj and not snd_obj:playing() then
            npc:set_sight( look.point, sound_position )
            snd_obj:play_no_feedback(
              npc, sound_object.s3d, 0, npc:position(), 1.0
            )
            self.warn_check_timer = time_global()
              + math.random( 15000, 25000 )
          end
        end
      else                      -- if who_dist > check_dist
        if npc:character_community() ~= "zombied" and not silent_level() then
          if
            ( not self.warn_check_timer )
            or self.warn_check_timer < time_global()
          then
            local snd_name = hear_something[
              math.random( table.getn( hear_something ) )
            ]
            local snd_obj = xr_sound.get_safe_sound_object( snd_name )
            if snd_obj and not snd_obj:playing() then
              npc:set_sight( look.point, sound_position )
              snd_obj:play_no_feedback(
                npc, sound_object.s3d, 0, npc:position(), 1.0
              )
              self.warn_check_timer = time_global()
                + math.random( 5000, 10000 )
            end
          end
        end
        npc:set_sight( look.point, sound_position )
        npc:set_mental_state( anim.danger )
      end
    elseif snd_t == "WPN_shoot" then
      stop_play_sound( npc )
      npc:set_mental_state( anim.danger )
      npc:set_sight( look.point, sound_position )
    end
    return
  end

  if who:is_actor() or who:is_stalker() then
    if
      snd_t == "ATTCK" or snd_t == "BULLET" or snd_t == "DIE" or snd_t == "INJURE"
    then
      npc:set_sight( look.point, sound_position )
      npc:set_mental_state( anim.danger )
    end
    return
  end

  if who:is_monster() and xrs_battle_ai.check_is_enemy( npc, who ) then
    local check_dist = 25 * sound_power
    if who_dist > check_dist then
      if
        npc:character_community() ~= "zombied"
        and ( not silent_level() )
        and (
          ( not self.warn_check_timer )
          or self.warn_check_timer < time_global()
        )
      then
        local snd_name = nothing_there[
          math.random( table.getn( nothing_there ) )
        ]
        local snd_obj = xr_sound.get_safe_sound_object( snd_name )
        if snd_obj and not snd_obj:playing() then
          npc:set_sight( look.point, sound_position )
          snd_obj:play_no_feedback(
            npc, sound_object.s3d, 0, npc:position(), 1.0
          )
          self.warn_check_timer = time_global()
            + math.random( 15000, 25000 )
        end
      end
    else
      if snd_t == "MST_step" or snd_t == "MST_talk" then
        npc:set_sight( look.point, sound_position )
        npc:set_mental_state( anim.danger )
      elseif snd_t == "MST_attack" then
        local blow  = hit()
        blow.power     = 0.001
        blow.impulse   = 1
        blow.draftsman = who
        blow.type      = hit.wound
        blow.direction = utils.vector_copy_by_val(
          npc:position()
        ):sub( who:position() )
        npc:hit( blow )
        stop_play_sound( npc )
        npc:set_sight( look.point, sound_position )
        npc:set_mental_state( anim.danger )
      end
    end
  end
end


class "timer_drop_weapon" ( ogse_qt.quick_timer )
function timer_drop_weapon:__init( item, parent_id ) super()
  self.item_id   = item:id()
  self.parent_id = parent_id
end

function timer_drop_weapon:condition()
  local item = level.object_by_id( self.item_id )
  local sobj = alife():object( self.item_id )
  if not ( item and sobj ) then
    self:stop()
  elseif item:parent() == nil or sobj.parent_id == 65535 then
    return true
  elseif
    item:parent():id() ~= self.parent_id or sobj.parent_id ~= self.parent_id
  then
    self:stop()
  end
  return false
end

function timer_drop_weapon:action()
  -- local npc = level.object_by_id( self.parent_id )
  -- if npc and npc:is_stalker() and npc:alive() then return end
  local item = level.object_by_id( self.item_id )
  if item then
    death_manager.drop_manager( self.parent_id ):set_weapon_drop_condition( item )
  end
end


function motivator_binder:on_item_drop( obj )
  if not obj then return end
  local sobj = alife():object( obj:id() )
  if not sobj then return end
  local npc = self.object
  if obj:is_weapon() and npc:alive() and not level.main_input_receiver() then
    timer_drop_weapon( obj, self.object:id() ):start()
  end
  self.am:call( "on_npc_item_drop", npc, obj, sobj )
end


function motivator_binder:on_item_take( obj )
  local sobj
  if not obj then
    return
  else
    local id = obj:id()
    sobj     = alife():object( id )
    if not sobj then return end
  end
  if obj:is_torch() then
    local torch = get_torch_obj( obj )
    if torch.on then
      torch:switch( false )
    end
  end
  self.am:call( "on_npc_item_take", self.object, obj, sobj )
  self.am:call(
    "on_npc_item_take." .. self.object:id(), self.object, obj, sobj
  )
end


function motivator_binder:enemy_callback( obj, enemy_st )
  if not obj:alive() then return false end
  local valid, enemy = validate_enemy_object( enemy_st )
  if valid then
    local result = {}
    if enemy:alive() then
      self.am:call( "on_npc_enemy_callback", obj, enemy, result )
    else
      table.insert( result, false )
    end
    for _, v in ipairs( result ) do
      if not v then
        disable_memory_object( obj, enemy )
        return false
      end
    end
  end
  return true
end


function motivator_binder:on_throw_grenade( obj )
  self.am:call( "on_npc_throw_grenade", self.object, obj )
end


function motivator_binder:set_slowest_scheduler()
  self.object:configure_scheduler( 100, 1000 )
  self.object:set_slowest_scheduler( true )
end


function AddToMotivator( npc )
  if alife() then
    npc:bind_object( this.motivator_binder( npc ) )
        end
end


-- Эвалюаторы, которые имеют высший приоритет, и, соответственно,
-- перебивают остальные скрипты собой
function addCommonPrecondition( action )
  action:add_precondition(
    world_property( xr_evaluators_id.stohe_meet_base + 1, false )
  )
  action:add_precondition(
    world_property( xr_evaluators_id.sidor_wounded_base + 0, false )
  )
  -- action:add_precondition(
  --   world_property( xr_evaluators_id.chugai_heli_hunter_base, false )
  -- )
  action:add_precondition(
    world_property( xr_evaluators_id.abuse_base, false )
  )

  action:add_precondition(
    world_property( blowout_scheme.evid_outside, false )
  )
  action:add_precondition(
    world_property( blowout_scheme.evid_blowout, false )
  )
  action:add_precondition(
    world_property( blowout_scheme.evid_preblowout, false )
  )

  xrs_ai.addCommonPrecondition( action )
  action:add_precondition(
    world_property( watcher_act.evid_see_stuff, false )
  )
  action:add_precondition(
    world_property( watcher_act.evid_near_stuff, false )
  )
end


function play_particle( ... )
  dsh_particles.play_particle( ... )
end
