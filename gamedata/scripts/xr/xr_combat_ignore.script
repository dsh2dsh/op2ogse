-- -*- mode: lua; coding: windows-1251-dos -*-
--[[-----------------------------------------------------------------------------
Игнорирование врагов
Чугай Александр
-------------------------------------------------------------------------------]]


function attach( sm )
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_destroy    })
  sm:subscribe({ signal = "on_npc_enemy_callback", fun = this.enemy_callback })
  sm:subscribe({ signal = "on_npc_net_destroy",     fun = this.on_destroy    })
end


local freq = 1000

function add_cache_rec( obj, enemy, is_enemy, freq )
  local binder = obj:binded_object()
  local cached = binder[ "xr_combat_ignore.cached" ]
  if cached then
    cached[ enemy:id() ] = { is_enemy, time_global() + freq }
  else
    binder[ "xr_combat_ignore.cached" ] = {
      [ enemy:id() ] = { is_enemy, time_global() + freq }
    }
  end
end


function get_cache_rec( obj, enemy, action )
  local is_enemy
  local binder = obj:binded_object()
  local cached = binder[ "xr_combat_ignore.cached" ]
  if cached and cached[ enemy:id() ] then
    local res, ttl = unpack( cached[ enemy:id() ] )
    if ttl <= time_global() then
      res = action:enemy_callback( obj, enemy )
      add_cache_rec( obj, enemy, res, freq )
    end
    is_enemy = res
  else
    is_enemy = action:enemy_callback( obj, enemy )
    add_cache_rec( obj, enemy, is_enemy, freq )
  end
  return is_enemy
end

function expire_cache_rec( obj, enemy )
  local binder = obj:binded_object()
  local cached = binder[ "xr_combat_ignore.cached" ]
  if cached and cached[ enemy:id() ] then
    cached[ enemy:id() ][ 2 ] = 0
  end
end


function enemy_callback( obj, enemy, result )
  local st = db.storage[ obj:id() ].combat_ignore
  if st and st.enabled then
    local res = get_cache_rec( obj, enemy, st.action )
    if res == false then
      table.insert( result, res )
      return true
    end
  end
end


local hits = {}
function register_hit( to, from )
  if not hits[ to:id()   ] then
    hits[ to:id()   ] = { from = {}, to = {} }
  end
  if not hits[ from:id() ] then
    hits[ from:id() ] = { from = {}, to = {} }
  end
  hits[ to:id()   ].from[ from:id() ] = true
  hits[ from:id() ].to[     to:id() ] = true
  expire_cache_rec( to, from )
end


function unregister_hits( npc )
  local t = hits[ npc:id() ]
  if t then
    for id, _ in pairs( t.from ) do
      hits[ id ].to[   npc:id() ] = nil
    end
    for id, _ in pairs( t.to   ) do
      hits[ id ].from[ npc:id() ] = nil
    end
  end
end


function got_hit_from( npc, from )
  if hits[ npc:id() ] and hits[ npc:id() ].from[ from:id() ] then
    return true
  end
  return false
end


function on_destroy( obj )
  unregister_hits( obj )
end


function is_enemy( obj, enemy, st )
  if obj:critically_wounded() then
    return true
  end

  if not st then
    st = db.storage[ obj:id() ].combat_ignore
    if not st then
      return true
    end
  end
  if not st.enabled then return true end

  local overrides = xr_logic.generic_scheme_overrides( obj )
  if overrides and overrides.combat_ignore then
    if enemy then
      db.storage[ obj:id() ].enemy = enemy
      local res = xr_logic.pick_section_from_condlist(
        db.actor, obj, overrides.combat_ignore.condlist
      ) == nil
      if not res then
        if
          got_hit_from( obj, enemy )
          and not overrides.combat_ignore_keep_when_attacked
        then
          return true
        end
      end
      return res
    else
      return overrides.combat_ignore.cached_condlist
        :pick_section_from_condlist( db.actor, obj ) == nil
    end
  end

  return true
end


class "action_process_enemy"
function action_process_enemy:__init( obj, storage )
  self.object = obj
  self.st     = storage
end


function action_process_enemy:enemy_callback( obj, enemy )
  return is_enemy( obj, enemy, self.st )
end


function action_process_enemy:hit_callback( obj, amount, local_direction, who, bone_index )
  if who and who:id() ~= obj:id() and amount > 0 then
    register_hit( obj, who )
  end
end


function add_to_binder( npc, ini, scheme, section, storage )
  local new_action = this.action_process_enemy( npc, storage )
  storage.action = new_action
end


function set_combat_ignore_checker( npc, ini, scheme, section )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  st.enabled = true
  --npc:set_enemy_callback( st.action.enemy_callback, st.action )
  -- Подписываемся на hit callback-и:
  xr_logic.subscribe_action_for_events( npc, st, st.action )
end


function disable_scheme( npc, scheme )
  --npc:set_enemy_callback()
  -- Отписываемся от hit callback. Это делать обязательно, потому что
  -- иначе при переключении на другой набор схем, в котором нет
  -- перехвата боя, продолжится вызываться callback в старом
  -- подписанном action-е.
  local st = db.storage[ npc:id() ][ scheme ]
  if st then
    st.enabled = false
    xr_logic.unsubscribe_action_from_events( npc, st, st.action )
  end
end
