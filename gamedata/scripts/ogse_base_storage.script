-------------------------------------------------------------------------------
--| ogse_base_storage.script                                                |--
--| Subsystem for creating base auxiliary objects for storing arbitrary     |--
--| user data                                                               |--
--| Malandrinus, OGS Evolution Team, 2011                                   |--
--| version 1.0                                                             |--
-------------------------------------------------------------------------------

-- модуль предоставляет сервис по созданию объектов, предназначенных для хранения произвольных данных
-- объекты имеют специальный класс (CUST_ST <-> clsid.custom_storage) и секцию 'custom_storage' 
-- и служат единственной цели хранить в них данные. Объекты создаются таким образом, чтобы никогда
-- не выходить в онлайн. Данные сохраняются в нетпакете серверного объекта.
-- данный модуль предоставляет только самый базовый сервис и является основой для построения 
-- более сложных систем.
-- Работа с объектами хранения происходит по следующему алгоритму.
-- 1. Запрашивается создание объекта-хранилища с помощью функции 
--    ogse_base_storage.get_storage(key)
--    здесь key - уникальный строковый идентификатор, однозначно соответствующий 
--    конкретному объекту-хранилищу. При первом получении объект создаётся невидимо 
--    для пользователя. При этом данный ключ записывается в кастомдату объекта. При дальнейших
--    обращениях к объекту-хранилищу он уже будет получаться из реестра по этому ключу.
--    Примечение: пользователь должен сам следить за тем, чтобы этот идентификатор был уникальным. 
--    В качестве идеи для надёжного обеспечения уникальности этих идентификаторов можно предложить 
--    использовать утилиту генерации GUID из состава Microsoft Visual Studio
-- 2. Для записи данных в объект надо получить из него специально подготовленный нетпакет. для
--    этого есть метод storage_object:w_reset(). Данный метод возвращает ссылку на нетпакет, 
--    в котором позиция записи установлена в то-же пололжение, что и начало свободной области в
--    самом объекте-хранилище. После получения этого нетпакета надо записать в него свои данные,
--    используя стандартные методы записи класса net_packet. 
--    При сохранении игры, данные из этого нетпакета будут переписаны в объект и таким образом
--    будут сохранены.
-- 3. Для чтения данных надо получить тот-же специальный нетпакет, но уже настроенный на чтение.
--    Для этого есть метод storage_object:r_reset(), который вернёт нетпакет, в котором позиция 
--    чтения установлена в начало пользовательских данных, а позиция записи - в конец. Как и при 
--    записи, чтение осуществляется стандартными методами чтения класса net_packet. Достижение
--    конца данных определяется методом r_eof, который сам по себе просто определяет достижение или
--    превышение позиции чтения над позицией записи.
--
--    Пример возможной стратегии записи/чтения:
--    Пусть надо сохранить некие данные, к примеру строку. Допустим, эту строку использует
--    класс актора. В биндере актора в методе load (или net_spawn, или reinit, неважно, лишь бы
--    вызывался один раз в начале) делаем примерно так:
--    local st = ogse_base_storage.get_storage("external_actor_storage") -- получили (или создали) само хранилище
--    -- "external_actor_storage" - это выбранный нами идентификатор хранилища.
--    local pk = st:r_reset() -- получили нетпакет для чтения
--    if pk:r_eof() then -- если в нетпакете пусто, значит до этого ничего туда не записывали
--        self.str = "" -- читать нечего, как-то создаём строку
--    else
--        self.str = pk:r_stringZ() -- читаем строку из нетпакета
--        -- подразумевается, что если данные есть, то это именно коректная строка.
--        -- Целостность и корректность данных естественно должны обеспечиваться пользователем.
--    end
--
--    теперь строка присутствует в биндере актора, используем её, меняем и т.д.
--    для записи используем метод save того же биндера (или net_destroy, опять же неважно,
--    лишь бы вызывался один раз при сохранении):
--    local st = ogse_base_storage.get_storage("external_actor_storage") -- получили хранилище,
--    -- используя выбранный ранее идентификатор
--    local pk = st:w_reset() -- получили нетпакет на запись
--    pk:w_stringZ(self.str) -- записали туда строку
--    ...
--    всё, далее строка сама сохранится в объекте и в дальнейшем уже прочитается в коде выше.

local registry = {}

local function create_storage_object(key)
	local st_obj = alife():create("custom_storage", vector(), 0, 0)
	local pk = xs_netpk.net_alife_dynamic_object(st_obj)
	local data = pk:get()
	data.custom_data:setTable( { main = { key = key } } ) --"[main]\nkey = "..key
	pk:set(data)
	-- никогда не выйдет в онлайн
    st_obj:can_switch_online(false)
    st_obj:can_switch_offline(true)
	registry[key] = st_obj
	return st_obj
end

function get_storage(key)
	local st_obj = registry[key]
	if not st_obj then
		st_obj = create_storage_object(key)
	end
	return st_obj
end

function storage_exist(key)
	return registry[key] ~= nil
end


-- Внимание! Крайне желательно не использовать удаление этих объектов. По неизвестной причине 
-- иногда зависает на удалении (редко, но к сожалению недостаточно, чтобы это было незаметно)
--[[function remove_storage(key)
	local st_obj = registry[key]
	ASSERT(st_obj, "ogse_base_storage.remove_storage: trying to remove storage which is not exist, key="..tostring(key))
	registry[key] = nil
	alife():release(st_obj, true)
end]]

-- Из-за отсутствия в классе нетпакета метода w_seek приходится имитировать его действие.
-- Ограничение данного метода - устанавливает позицию записи не менее, чем в 2.
-- Также заполняет все пространство до указанной позиции каким-либо значением, 
-- в данном случае 123. В данном случае это неважно, поскольку эта область не используется.
local function w_seek(packet, pos)
	packet:w_begin() -- устанавливаем позицию чтения в начало. Точнее не в начало, 
	while packet:w_tell() ~= pos do
		packet:w_u8(123)
	end
end
-- класс специального серверного объекта для хранения данных
class "se_custom_storage" (cse_alife_dynamic_object)
function se_custom_storage:__init(section) super(section)
	self.st_packet = net_packet()
	self.zero_pos = 0
end
-- получение нетпакета, подготовленного для записи в него данных
-- в нетпакете места будет ровно столько, сколько в самом объекте
-- (чтобы не было возможности записать больше, чем может хранить объект)
function se_custom_storage:w_reset()
	-- синхронизируем позицию записи служебного нетпакета с началом свободной области в нашем объекте
	w_seek(self.st_packet, self.zero_pos)
	return self.st_packet -- возвращаем подготовленный для записи нетпакет
end
-- получение пакета с данными, ранее сохранёнными в объекте
function se_custom_storage:r_reset()
	-- устанавливаем позицию чтения в начало наших данных
	self.st_packet:r_seek(self.zero_pos)
	return self.st_packet -- возвращаем подготовленный для чтения пакет
end
-- при загрузке игры каждый объект зарегистрирует себя в глобальном хранилище
-- свой идентификатор объект прочитает из своей же кастомдаты, где мы сохранили его ранее
-- в секции main с именем параметра key
function se_custom_storage:on_register()
	cse_alife_dynamic_object.on_register(self)
	local sini = self:spawn_ini()
	if sini:section_exist("main") then
		ASSERT(sini:line_exist("main", "key"), "se_custom_storage:on_register: storage object found with uninitialized custom data. Section main exists, but has no 'key' parameter.")
		registry[sini:r_string("main", "key")] = self
	end
end

-- при загрузке объекта его сохранённые данные будут прочитаны в специальный нетпакет
function se_custom_storage:STATE_Read(packet, size)
	cse_alife_dynamic_object.STATE_Read(self, packet, size)
	self.zero_pos = packet:r_tell() -- позиция в нетпакете, с которой можно записывать свои данные
	self:w_reset() -- готовим пакет под данные
	while not packet:r_eof() do -- читаем данные из объекта
		self.st_packet:w_u8(packet:r_u8()) -- и сохраняем их в отдельном пакете
	end
	self.end_pos = packet:w_tell() -- сохраняем позицию конца данных
end
-- при сохранении объекта в него будут скопированы данные из специального пакете
function se_custom_storage:STATE_Write(packet)
	cse_alife_dynamic_object.STATE_Write(self, packet)
	self:r_reset() -- готовим специальный пакет для чтения
	while not self.st_packet:r_eof() do -- переписываем из него данные в нетпакет объекта
		packet:w_u8(self.st_packet:r_u8())
	end
end
function se_custom_storage:can_save() -- этот объект всегда будет сохраняться
	return true
end
