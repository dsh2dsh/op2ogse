-- -*- mode: lua; coding: windows-1251-dos -*-

-- Этот скрипт эмулирует поглощение энергии хита артефактами,
-- размещенными на поясе.  Каждый артефакт, находящийся под контролем
-- скрипта, способен поглотить определенное кол-во энергии, после
-- чего, он преобразуется в булыжник.

local our_hits = {              -- какие типы хита будут обрабатываться
  [ hit.explosion ] = {
    [ "max"  ] = 10,           -- порог поглощения
    [ "sect" ] = "explosion_immunity",
  },
  [ hit.fire_wound ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "fire_wound_immunity",
    [ "ignored_outfit_protection" ] = false,
  },
  [ hit.strike ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "strike_immunity",
  },
  [ hit.wound ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "wound_immunity",
  },
  [ hit.burn ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "burn_immunity",
  },
  [ hit.chemical_burn ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "chemical_burn_immunity",
  },
  [ hit.shock ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "shock_immunity",
  },
  [ hit.radiation ] = {
    [ "max"  ] = 100,
    [ "sect" ] = "radiation_immunity",
  },
  [ hit.telepatic ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "telepatic_immunity",
  },
  [ "bleeding" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "bleeding_restore_speed",
  },
  [ "health" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "health_restore_speed",
  },
  [ "power" ] = {
    [ "max"  ] = 1000,
    [ "sect" ] = "power_restore_speed",
  },
  [ "radiation" ] = {
    [ "max"  ] = 500,
    [ "sect" ] = "radiation_restore_speed",
  },
}


function attach( sm )
  sm:subscribe({ signal = "on_actor_before_hit", fun = this.before_hit })
  sm:subscribe({ signal = "on_first_update",     fun = this.on_first_update })
  sm:subscribe({ signal = "on_use",              fun = this.on_use  })
end


local pt
function on_first_update()
  pt = { game.get_game_time():get() }
  local sm = ogse_signals.get_mgr()
  sm:subscribe({
    signal = "on_update", fun = this.process_hits,
    [ "script_name" ] = ( script_name() .. ".process_hits" )
  })
  sm:subscribe({
    signal = "on_update", fun = this.process_arts,
    [ "script_name" ] = ( script_name() .. ".process_arts" )
  })
end


local got_hits = {}
local has_hit  = false
local new_hit  = {}
local psy_block_t

function before_hit( hit_data, p_s_hit, p_ignore_flags )
  local hit_type = hit_data.hit_type
  local our_hit  = our_hits[ hit_type ]
  local power    = hit_data.power
  if our_hit and power > 0 then
    local real_power = calc_real_hit_power( our_hit, hit_data )
    if real_power > 0 then
      if got_hits[ hit_type ] then
        got_hits[ hit_type ] = got_hits[ hit_type ] + real_power
      else
        got_hits[ hit_type ] = real_power
      end
      has_hit = true
      new_hit[ hit_type ] = true
    end
    if our_hit.ignored_outfit_protection then
      apply_outfit_protection( hit_data, p_s_hit )
    end
    if hit_data.hit_type == hit.telepatic
      and
      psy_block_t and time_global() < psy_block_t
    then
      power = 0
      write_memory_float( power, p_s_hit, hit_offset.power )
    end
  end
end


function apply_outfit_protection( hit_data, p_s_hit )
  if db.actor and db.actor:alive() then
    local outfit_item = db.actor:item_in_slot( 6 )
    if outfit_item then
      local koef    = hit_data.power / 5
      if     koef < 0.1 then
        koef = 0.1
      elseif koef > 1 then
        koef = 1
      end
      local imm_val = db.actor:get_current_outfit_protection(
        hit_data.hit_type
      ) * koef
      if imm_val > 0 then
        write_memory_float(
          hit_data.power * ( 1 - imm_val ),
          p_s_hit,
          hit_offset.power
        )
      end
    end
  end
end


function calc_real_hit_power( our_hit, hit_data )
  local hit_power = hit_data.power
  -- вычислить хит до его поглощения артефактами
  local hit_immunity = inventory.on_belt_hit_immunity( our_hit.sect )
  if hit_immunity > 0 then
    hit_power = hit_power / ( 1 - hit_immunity )
  end
  return hit_power
end


local absorbations   = {}
local need_addl_keys = {
  [ "bleeding_restore_speed"  ] =  1,
  [ "health_restore_speed"    ] =  1,
  [ "power_restore_speed"     ] =  1,
  [ "radiation_restore_speed" ] = -1,
}
function get_absorbations( af )
  local af_sect = af:section()
  if not absorbations[ af_sect ] then
    local absorb_sect = get_string( af_sect, "hit_absorbation_sect" )
    if absorb_sect then
      if not absorbations[ af_sect ] then
        absorbations[ af_sect ] = {}
        for _, k in ipairs( get_section_keys( absorb_sect ) ) do
          local absorb_val = 1 - get_float( absorb_sect, k, 1 )
          if absorb_val > 0 then
            absorbations[ af_sect ][ k ] = absorb_val
          end
        end
      end
    end
    for k, v in pairs( need_addl_keys ) do
      local val = get_float( af_sect, k, 0 )
      if     v > 0 and val > 0 then
        absorbations[ af_sect ][ k ] = val
      elseif v < 0 and val < 0 then
        absorbations[ af_sect ][ k ] = math.abs( val )
      end
    end
  end
  return absorbations[ af_sect ]
end


function process_hits()
  local previous_check_time = game.CTime()
  previous_check_time:set( unpack( pt ) )
  local current_time = game.get_game_time()
  local dt = current_time:diffSec( previous_check_time )
  pt = { current_time:get() }

  if
    db.actor:get_bleeding() > 0
    or new_hit[ hit.explosion     ]
    or new_hit[ hit.fire_wound    ]
    or new_hit[ hit.strike        ]
    or new_hit[ hit.wound         ]
    or new_hit[ hit.chemical_burn ]
  then
    local hit_type = "bleeding"
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + dt
    else
      got_hits[ hit_type ] = dt
    end
    has_hit = true
  end

  if
    db.actor.health < 1
    or new_hit[ hit.explosion  ]
    or new_hit[ hit.fire_wound ]
    or new_hit[ hit.strike     ]
    or new_hit[ hit.wound      ]
  then
    local hit_type = "health"
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + dt
    else
      got_hits[ hit_type ] = dt
    end
    has_hit = true
  end

  if
    db.actor.power < 0.99
    or db.actor:is_actor_running()
    or db.actor:is_actor_sprinting()
    or db.actor:is_actor_climbing()
  then
    local hit_type = "power"
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + dt
    else
      got_hits[ hit_type ] = dt
    end
    has_hit = true
  end

  if
    db.actor.radiation > 0
    or new_hit[ hit.radiation ]
    or arc_radiation.get_inv_arts_radiation() > 0
  then
    local hit_type = "radiation"
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + dt
    else
      got_hits[ hit_type ] = dt
    end
    has_hit = true
  end

  new_hit = {}
end


function process_arts()
  ogse_signals.get_mgr():reschedule( 1000 )
  if not has_hit then return end
  local empty       = {}
  local master_coef = 4 - level.get_game_difficulty()
  for i = 0, db.actor:belt_count() - 1 do
    local af = db.actor:item_on_belt( i )
    if af:is_artefact() then
      local af_sect = af:section()
      local absorbs = get_absorbations( af )
      if absorbs then
        local cond_diff = 0
        for hit_type, hit_power in pairs( got_hits ) do
          local our_hit = our_hits[ hit_type ]
          if absorbs[ our_hit.sect ] then
            local absorb_val = absorbs[ our_hit.sect ] * hit_power
            cond_diff = cond_diff + (
              absorb_val / ( our_hit.max * master_coef )
            )
          end
        end
        if cond_diff > 0 then
          if af:condition() > cond_diff then
            set_condition_on_update( af, af:condition() - cond_diff )
          else
            table.insert( empty, af )
          end
        end
      end
    end
  end
  for _, af in ipairs( empty ) do
    degrade_artefact( af )
  end
  for hit_type, hit_power in pairs( got_hits ) do
    got_hits[ hit_type ] = 0
  end
  has_hit = false
end


function on_use( obj, sobj )
  if obj:section() == "vodka" then
    if psy_block_t and time_global() < psy_block_t then
      psy_block_t = psy_block_t   + 60000
    else
      psy_block_t = time_global() + 60000
    end
    dsh_sleep.change_gg_need_sleep( 30 )
  end
end


function degrade_artefact( af )
  zero_all_af_effects( af )
  dsh.set_condition( af, 0 )
end


function set_condition_on_update( obj, cond )
  obj:set_condition( cond )
  dsh.exec_on_update(
    function( id, name )
      local obj = level.object_by_id( id )
      if obj and obj:name() == name then
        dsh.set_condition( obj, cond )
      end
    end,
    obj:id(), obj:name()
  )
end
