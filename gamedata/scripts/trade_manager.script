-- -*- mode: lua; coding: windows-1251-dos -*-

local trade_manager = {}
function trade_init( npc, cfg )
  if not trade_manager[ npc:id() ] then trade_manager[ npc:id() ] = {} end
  local tt = trade_manager[ npc:id() ]
  if tt.inited then return end
  log2( "TRADE INIT[%s]", npc:name() )
  tt.cfg_ltx = cfg
  tt.config  = dsh.cached_ini_file( cfg )
	
  -- коэфициенты покупки
  local str = get_string( "trader", "buy_condition", nil, tt.config )
  ASSERT(
    str,
   "Incorrect trader settings. Cannot find buy_condition. [%s]->[%s]",
   npc:name(), cfg
  )
  tt.buy_condition = xr_logic.parse_condlist(
    npc, "trade_manager", "buy_condition", str
  )
	
  -- коэфициенты продажи
  str = get_string( "trader", "sell_condition", nil, tt.config )
  ASSERT(
    str,
    "Incorrect trader settings. Cannot find sell_condition. [%s]->[%s]",
    npc:name(), cfg
  )
  tt.sell_condition = xr_logic.parse_condlist(
    npc, "trade_manager", "sell_condition", str
  )
	
  -- список закупки
  str = get_string( "trader", "buy_supplies", nil, tt.config )
  if str then
    tt.buy_supplies = xr_logic.parse_condlist(
      npc, "trade_manager", "buy_supplies", str
    )
  else 
    tt.buy_supplies = nil
  end

  tt.inited = true
end


local last_update_t
function update( npc )
  local tt = trade_manager[ npc:id() ]
  if not tt then return end
  if last_update_t and last_update_t > time_global() then return end
  last_update_t = time_global() + 1

  if tt.update_time and tt.update_time > time_global() then
    return
  end
  tt.update_time = time_global() + math.random( 1800, 3600 ) * 1000
	
  local str = xr_logic.pick_section_from_condlist(
    db.actor, npc, tt.buy_condition
  )
  if tt.current_buy_condition ~= str then
    log2( "TRADE [%s]: buy condition = %s", npc:name(), str )
    npc:buy_condition( tt.config, str )
    tt.current_buy_condition = str
  end

  str = xr_logic.pick_section_from_condlist( db.actor, npc, tt.sell_condition )
  if tt.current_sell_condition ~= str then
    log2( "TRADE [%s]: sell condition = %s", npc:name(), str )
    npc:sell_condition( tt.config, str )
    tt.current_sell_condition = str
  end

  if tt.buy_supplies then
    if
      tt.resuply_time
      and tt.resuply_time:diffSec( game.get_game_time() ) > 0
    then
      return
    end
    str = xr_logic.pick_section_from_condlist(db.actor, npc, tt.buy_supplies )
    if tt.current_buy_supplies ~= str then
      log2( "TRADE [%s]: buy_supplies = %s", npc:name(), str )
      npc:buy_supplies( tt.config, str )
      tt.current_buy_supplies = str
    end
    tt.resuply_time = game.get_game_time()
      + seconds2ctime( math.random( 3, 12 ) * 3600 )
  end
end


function save( obj, packet )
  local tt = trade_manager[ obj:id() ]

  --' Сохраняем присутствует ли инициализированная торговля в принципе.
  if tt then
    packet:w_bool( true )
  else
    log2( "TRADE SAVE [%s]: ignored", obj:name() )
    packet:w_bool( false )
    return
  end

  packet:w_stringZ( tt.cfg_ltx )

  log2(
    "TRADE SAVE [%s]: current_buy_condition = %s",
    obj:name(), tostring( tt.current_buy_condition )
  )
  if tt.current_buy_condition then
    packet:w_stringZ( tt.current_buy_condition )
  else
    packet:w_stringZ( "" )
  end

  log2(
    "TRADE SAVE [%s]: current_sell_condition = %s",
    obj:name(), tostring( tt.current_sell_condition )
  )
  if tt.current_sell_condition then
    packet:w_stringZ( tt.current_sell_condition )
  else
    packet:w_stringZ( "" )
  end

  log2(
    "TRADE SAVE [%s]: current_buy_supplies = %s",
    obj:name(), tostring( tt.current_buy_supplies )
  )
  if tt.current_buy_supplies then
    packet:w_stringZ( tt.current_buy_supplies )
  else
    packet:w_stringZ( "" )
  end

  local cur_tm = time_global()
  if tt.update_time then
    log2(
      "TRADE SAVE [%s]: update_time = %s",
      obj:name(), tt.update_time - cur_tm
    )
    packet:w_s32( tt.update_time - cur_tm )
  else
    packet:w_s32( -1 )
  end

  if tt.resuply_time then
    log2(
      "TRADE SAVE [%s]: resuply_time = %s",
      obj:name(), tt.resuply_time:diffSec( game.get_game_time() ) * 1000
    )
    packet:w_s32( tt.resuply_time:diffSec( game.get_game_time() ) * 1000 )
  else
    packet:w_s32( -1 )
  end
end


function load( obj, packet )
  local a = packet:r_bool()
  if a == false then
    log2( "TRADE LOAD [%s]: ignored", obj:name() )
    return
  end

  trade_manager[ obj:id() ] = {}
  local tt = trade_manager[ obj:id() ]

  tt.cfg_ltx = packet:r_stringZ()
  log2( "TRADE LOAD [%s]: cfg_ltx = %s", obj:name(), tostring( tt.cfg_ltx ) )
  tt.config = dsh.cached_ini_file( tt.cfg_ltx )

  a = packet:r_stringZ()
  log2(
    "TRADE LOAD [%s]: current_buy_condition = %s", obj:name(), tostring( a )
  )
  if a ~= "" then
    tt.current_buy_condition = a
    obj:buy_condition( tt.config, a )
  end
	
  a = packet:r_stringZ()
  log2(
    "TRADE LOAD [%s]: current_sell_condition = %s", obj:name(), tostring( a )
  )
  if a ~= "" then
    tt.current_sell_condition = a
    obj:sell_condition( tt.config, a )
  end

  a = packet:r_stringZ()
  log2(
    "TRADE LOAD [%s]: current_buy_supplies = %s", obj:name(), tostring( a )
  )
  if a ~= "" then tt.current_buy_supplies = a end

  local cur_tm = time_global()
  a = packet:r_s32()
  log2(
    "TRADE LOAD [%s]: update_time = %s", obj:name(), tostring( a )
  )
  if a ~= -1 then tt.update_time = cur_tm + a end

  a = packet:r_s32()
  log2(
    "TRADE LOAD [%s]: resuply_time = %s", obj:name(), tostring( a )
  )
  if a ~= -1 then
    tt.resuply_time = game.get_game_time() + seconds2ctime( a / 1000 )
  end
end
