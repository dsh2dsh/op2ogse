-- -*- mode: lua; coding: windows-1251-dos -*-
---------------------- Инициализация расширений движка ------------------------
RvP()

excluded_restrictors = {
		["agr_factory_skirmish_defence"] = true,
		["pri_followers_wave1_out_restr"] = true,
		["pri_followers_wave2_out_restr"] = true,
		["pri_followers_wave3_out_restr"] = true,
		["pri_followers_wave4_out_restr"] = true,
		["pri_followers_wave5_out_restr"] = true,
		["pri_followers_wave6_out_restr"] = true,
		["pri_followers_wave7_out_restr"] = true,
		["agr_nii_sr_building"] = true,
		["agr_nii_3_floor"] = true,
		["agr_nii_space_restrictor"] = true,
		["agr_factory_skirmish"] = true,
		["mil_freedom_gulag_defense_res"] = true,
		["yantar_bunker_space_restrictor"] = true,
		["val_lager_bandits_nedostroyka_restrictor"] = true,
		["val_lager_bandits_main_side_restrictor"] = true,
		["val_lager_bandits_main_building_restrictor"] = true,
		["pri_monolith_kolos_restr"] = true,
		["pri_monolith_base_restr"] = true,
		["sar_patrol_restrictor"] = true,
		["rad_tramplin_sniper_restrictor"] = true,
		["bar_arena_restrictor"] = true
	}

pairs_old = pairs
pairs = function(t)
     if not t or type(t)~="table" then
          log1("!! error, try to call 'pairs' with " .. tostring(t) .. " param")
          log1(debug.traceback())
          return
     end
     return pairs_old(t)
end


if type(SetLog) == "function" and os and os.clock() < 30 then
	local name = getFS():update_path("$logs$", "_ogse.log")
	SetLog(name)
	log1("--SetLogCallback to file " .. name)
end
--
local dir 		= "$fs_root$"
local ext_path 	= "bin\\extensions"
local path  	= getFS():update_path(dir, ext_path)

package.cpath = package.cpath..";"..path.."\\?.dll"

local function IsDll(fname)
	return fname:sub(-4) == ".dll"
end

if type(init_external_libs) == "function" then
	init_external_libs()
end

--лучше наверное оставить в главном модуле lfs и грузить им.
if not lfs then
	fail("check lfs namespace")
end
for file in lfs.dir(path) do
	log1("file: "..file)
	if file ~= "." and file ~= ".." then
		if IsDll(file) then
			local mod = file:sub(1, -5)
			log1("--try to load " .. file)
			log1("fname: "..mod)
			local rez, msg = pcall(require, mod)
			if (not(not rez)) then
				log1("~~    loaded")
			else
				log1("!!    error, msg : " .. tostring(msg))
			end
		end
	end
end

if os and os.clock() < 30 then
	log1("~~        _G : os.clock() = " .. tostring(os.clock()) .. "    math.randomseed()")
	math.randomseed(os.time())
end

local additional_libraries = {
	--["luaXml"] = true
}
prefetch("luaxml")

for k,v in pairs(additional_libraries) do
	if v then
			log1("--try to load " .. k)
			local rez, msg = pcall(require, k)
			if (not(not rez)) then
				log1("~~    loaded")
			else
				log1("!!    error, msg : " .. tostring(msg))
			end
	end
end

set_static_rescale_factor(device().height / device().width / 0.75)

-- жуткая затычка для проблемы с большими целыми числами при сложении в Lua
-- родное сложение начинает округлять и терять часть суммы, а функция sum_args
-- при тривиальном использовании в ряде случаев отсекает аргументы со значения 0x80000000
-- здесь сделано так, что этот эффект не происходит. Функция очень медленная,
-- использовать только в связке с функцией получения значения по абсолютному адресу
-- и по возможности вообще избегать.
function sum_args_ex(base, offs)
	local base_s = string.format("%08x", base)
	local b1_s = base_s:sub(1,4)
	--log1(b1_s)
	local b2_s = base_s:sub(5,8)
	--log1(b2_s)
	local b1 = tonumber(b1_s, 16)
	local b2 = tonumber(b2_s, 16)
	local res = sum_args(bit.lshift(b1, 16), sum_args(b2, offs))
	--log3("sum_args_ex: %s, %x, %x", base_s, offs, res)
	return res
end
-- FIX Nazgool ------------------------------------------------------------------
-- Возможно подобные функции уже где-то и есть, но я пока не нашёл.

-- Проверки
function isTable   (obj) return type(obj) == 'table'    end
function isBoolean (obj) return type(obj) == 'boolean'  end
function isNumber  (obj) return type(obj) == 'number'   end
function isFunction(obj) return type(obj) == 'function' end
function isString  (obj) return type(obj) == 'string'   end
function isUserdata(obj) return type(obj) == 'userdata' end
function isThread  (obj) return type(obj) == 'thread'   end
function isNil     (obj) return       obj == nil        end -- не false, а именно nil
-- Проверка - пуста ли таблица или строка
-- Если параметр 'space' не nil/false, то строка, состоящая только из пробельных символов и(или) неразрывного пробела будет считаться пустой.
function isEmpty(obj, space)
    if isString(obj) then
        if space then return not obj:match('[^%s\160]+') end
        return #obj == 0
    end
    if isTable(obj) then return next(obj) == nil end
    return false
end
-- является ли таблица массивом
function isArray(obj)
    if not isTable(obj) then return false end
	local n=0
	for _ in pairs(obj) do n=n+1 end
    return n <= #obj
end

-- Приведение значения переменной 'val' к булевому значению
function toBoolean(val)
    return not not val
end

if (jit == nil) then
  profiler.setup_hook ()
end

schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
--  filename - имя файла, в котором реализована схема, без расширения
--  scheme - имя схемы
function load_scheme(filename, scheme, stype)
  schemes[scheme] = filename
  stypes[scheme] = stype
end
-------======= ini reading functions by sapsan =======------
iniLines = {
    ["float"]   = {},
    ["u32"]   = {},
    ["string"]  = {},
    ["string_wq"]  = {},
    ["boolean"] = {},
    ["line"] = {}
}
iniOtherLines = {}
iniStat = {}
iniCaching = true
--iniStatistic = true
iniStatistic = false
--iniSections = {} -- если пустая - кешируется ВСЁ!
iniSections = { -- если пустая - кешируется ВСЁ!
    ["af_ameba_slug "]              = true,
    ["af_blood"]                    = true,
    ["af_electra_sparkler"]         = true,
    ["af_gravi"]                    = true,
    ["af_medusa"]                   = true,
    ["af_vyvert"]                   = true,
    ["art_acumm"]                   = true,
    ["ammo_11.43x23_hydro"]         = true,
    ["ammo_12x70_buck"]             = true,
    ["ammo_12x76_dart"]             = true,
    ["ammo_12x76_zhekan"]           = true,
    ["ammo_5.45x39_ap"]             = true,
    ["ammo_5.45x39_fmj"]            = true,
    ["ammo_5.56x45_ap"]             = true,
    ["ammo_5.56x45_ss190"]          = true,
    ["ammo_9x18_fmj"]               = true,
    ["ammo_9x18_pmm"]               = true,
    ["ammo_9x19_fmj"]               = true,
    ["ammo_9x19_pbp"]               = true,
    ["ammo_9x39_ap"]                = true,
    ["ammo_9x39_pab9"]              = true,
    ["ammo_9x39_sp5"]               = true,
    ["ammo_m209"]                   = true,
    ["ammo_vog-25"]                 = true,
    ["ammo_vog-25p"]                = true,
    ["antirad"]                     = true,
    ["balalaika_a"]                 = true,
    ["bandage"]                     = true,
    ["bandit_gaz_outfit_m1"]        = true,
    ["bandit_master_outfit"]        = true,
    ["bandit_outfit"]               = true,
    ["beer_a"]                      = true,
    ["bolt"]                        = true,
    ["bread"]                       = true,
    ["breakable_object"]            = true,
    ["cigara"]                      = true,
    ["climable_object"]             = true,
    ["conserva"]                    = true,
    ["device_pda"]                  = true,
    ["device_torch"]                = true,
    ["energy_drink"]                = true,
    ["flaska"]                      = true,
    --["generic_sell"]                = true,
    ["grenade_f1"]                  = true,
    ["grenade_gd-05"]               = true,
    ["grenade_rgd5"]                = true,
    ["guitar_a"]                    = true,
    ["harmonica_a"]                 = true,
    ["inventory_box"]               = true,
    ["killer_outfit"]               = true,
    ["kolbasa"]                     = true,
    ["lights_hanging_lamp"]         = true,
    ["logic"]                       = true,
    ["medkit"]                      = true,
    ["medkit_army"]                 = true,
    ["medkit_scientic"]             = true,
    ["mob_home"]                    = true,
    ["monolit_exoskeleton"]         = true,
    ["monolit_gaz_outfit_m1"]       = true,
    ["mutant_dog_tail"]             = true,
    ["mutant_face_tushkano"]        = true,
    ["mutant_spleen_rat"]           = true,
    ["ph_door@locked"]              = true,
    ["ph_door@open"]                = true,
    ["ph_idle@enable"]              = true,
    ["ph_skeleton_object"]          = true,
    ["physic_destroyable_object"]   = true,
    ["physic_object"]               = true,
    --["random_task"]                 = true,
    --["remark@val_rob_leader_call"]  = true,
    ["respawn"]                     = true,
    ["sandwich"]                    = true,
    ["smart_terrain"]               = true,
    ["space_restrictor"]            = true,
    ["stalker"]                     = true,
    ["stalker_outfit"]              = true,
    ["suvorotka"]                   = true,
    ["sweetness"]                   = true,
    ["vodka"]                       = true,
    ["oceanic815"]                  = true,
    --["walker@val_rob_leader_start"] = true,
    ["wpn_abakan"]                  = true,
    ["wpn_addon_grenade_launcher"]  = true,
    ["wpn_addon_grenade_launcher_m203"] = true,
    ["wpn_ak47"]                    = true,
    ["wpn_ak74 "]                   = true,
    ["wpn_ak74u"]                   = true,
    ["wpn_beretta_m1"]              = true,
    ["wpn_bm16"]                    = true,
    ["wpn_fort"]                    = true,
    ["wpn_g36"]                     = true,
    ["wpn_groza"]                   = true,
    ["wpn_l85"]                     = true,
    ["wpn_lr300"]                   = true,
    ["wpn_m16a2_sk1"]               = true,
    ["wpn_m4super90"]               = true,
    ["wpn_mp5"]                     = true,
    ["wpn_pb"]                      = true,
    ["wpn_pm"]                      = true,
    ["wpn_tavor"]                   = true,
    ["wpn_sig220"]                  = true,
    ["wpn_sig550"]                  = true,
    ["wpn_spas12"]                  = true,
    ["wpn_val"]                     = true,
    ["wpn_walther"]                 = true,
    ["yad"]                         = true
}
iniSectionsCount = 0
for sect, val in pairs(iniSections) do
    iniSectionsCount = iniSectionsCount + 1
end
-- if not iniLines then iniLines = {} end
-- if not iniOtherLines then iniOtherLines = {} end
--cfg_get_number(char_ini, section, field, object, mandatory, default_val)
--getIniValueFloat(sect, line, default, iniFileName)

--cfg_get_string(char_ini, section, field, object, mandatory, gulag_name, default_val)
--getIniValueString(sect, line, default, iniFileName)
-- getIniValueString("trader", "sell_condition", "", "misc\\trade_generic.ltx")
sys_ini = system_ini()
function getIniValueFloat(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueFloat: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["float"] or not iniOtherLines[iniFileName]["float"][sect] or not iniOtherLines[iniFileName]["float"][sect][line]) or
                (not iniLines["float"][sect] or not iniLines["float"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("float", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_float(sect, line)
                else
                    sectLines[line] = default
                end
            end

            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["float"][sect][line]
            else
                return iniLines["float"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_float(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueU32(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueU32: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["u32"] or not iniOtherLines[iniFileName]["u32"][sect] or not iniOtherLines[iniFileName]["u32"][sect][line]) or
                (not iniLines["u32"][sect] or not iniLines["u32"][sect][line]) then
                -- amk.dump_table(iniLines)
                local ini, sectLines = getIniValuePrepare("u32", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_u32(sect, line)
                else
                    sectLines[line] = default
                end
            end
        
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["u32"][sect][line]
            else
                return iniLines["u32"][sect][line]
            end
         else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_u32(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueString(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueString: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string"] or not iniOtherLines[iniFileName]["string"][sect] or not iniOtherLines[iniFileName]["string"][sect][line]) or
                (not iniLines["string"] or not iniLines["string"][sect] or not iniLines["string"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string"][sect][line]
            else
                return iniLines["string"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueStringWQ(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueStringWQ: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string_wq"] or not iniOtherLines[iniFileName]["string_wq"][sect] or not iniOtherLines[iniFileName]["string_wq"][sect][line]) or
                (not iniLines["string_wq"] or not iniLines["string_wq"][sect] or not iniLines["string_wq"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string_wq", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string_wq(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string_wq"][sect][line]
            else
                return iniLines["string_wq"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string_wq(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueBool(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueBool: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["boolean"] or not iniOtherLines[iniFileName]["boolean"][sect] or iniOtherLines[iniFileName]["boolean"][sect][line] == nil) or
                (not iniLines["boolean"][sect] or iniLines["boolean"][sect][line] == nil) then
                local ini, sectLines = getIniValuePrepare("boolean", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_bool(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["boolean"][sect][line]
            else
                return iniLines["boolean"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_bool(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function iniLinesCount(sect, iniFileName)
   -- get_console():execute("load ~~~ iniCaching iniLinesCount: "..tostring(sect)..", "..tostring(iniFileName))
    if sect then
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or not iniOtherLines[iniFileName]["line"][sect]["count"]) or
                (not iniLines["line"] or not iniLines["line"][sect] or not iniLines["line"][sect]["count"]) then
                --get_console():execute("load ~~~ iniCaching iniLinesCount: 1")
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                
                if iniLineSectionExist(sect, iniFileName) then
                    sectLines["count"] = ini:line_count(sect)
                else
                    sectLines["count"] = 0
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["count"]
            else
                return iniLines["line"][sect]["count"]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) then
                return ini:line_count(sect)
            else
                return 0
            end
        end
    else
        return 0
    end
end

function iniLineSectionExist(sect, iniFileName)
    --get_console():execute("load ~~~ iniCaching iniLineSectionExist: "..tostring(sect)..", "..tostring(iniFileName))
    if sect then
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or iniOtherLines[iniFileName]["line"][sect]["exist"] == nil) or
                (not iniLines["line"] or not iniLines["line"][sect] or iniLines["line"][sect]["exist"] == nil) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                sectLines["exist"] = (ini and ini:section_exist(sect))
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["exist"] -- > -1
            else
                return iniLines["line"][sect]["exist"] -- > -1
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            return (ini and ini:section_exist(sect))
        end
    else
        return false
    end
end

function getIniLine(sect, lineNumber, defaultKey, defaultValue, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniLine: "..tostring(sect)..", "..tostring(lineNumber)..", "..tostring(defaultKey)..", "..tostring(defaultValue)..", "..tostring(iniFileName))
    if sect and lineNumber then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or not iniOtherLines[iniFileName]["line"][sect]["lines"] or not iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber]) or
                (not iniLines["line"] or not iniLines["line"][sect] or not iniLines["line"][sect]["lines"] or not iniLines["line"][sect]["lines"][lineNumber]) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                if not sectLines["lines"] then
                    sectLines["lines"] = {}
                end
                local result, key, value = ini:r_line(sect, lineNumber, defaultKey, defaultValue)
                sectLines["lines"][lineNumber] = {result, key, value}
            end
            
            -- amk.dump_table(iniLines)
            local t
            if iniFileName then
                t = iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber]
            else
                t = iniLines["line"][sect]["lines"][lineNumber]
            end
            return t[1], t[2], t[3]
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) then
                return ini:r_line(sect, lineNumber, defaultKey, defaultValue)
            else
                return false, defaultKey, defaultValue
            end
        end
    else
        return false, defaultKey, defaultValue
    end
end

function getIniValuePrepare(valueType, sect, iniFileName)
    local ini
    local sectLines
    if iniFileName then
        ini = ini_file(iniFileName)
        if not iniOtherLines[iniFileName] then
            iniOtherLines[iniFileName] = {}
        end
        if not iniOtherLines[iniFileName][valueType] then
            iniOtherLines[iniFileName][valueType] = {}
        end
        if not iniOtherLines[iniFileName][valueType][sect] then
            iniOtherLines[iniFileName][valueType][sect] = {}
        end
        sectLines = iniOtherLines[iniFileName][valueType][sect]
    else
        ini = sys_ini
        if not iniLines[valueType] then
            iniLines[valueType] = {}
        end
        if not iniLines[valueType][sect] then
            iniLines[valueType][sect] = {}
        end
        sectLines = iniLines[valueType][sect]
    end
	return ini, sectLines
end
-------======= / ini reading functions by sapsan =======------
----------------------------------------------------------------------

function printf(fmt,...)
--[[ Раскомментить это для включения расширенного лога
	local con = get_console() 
	con:execute(string.gsub(string.format(fmt,...), " ", "_")) 
	con:execute("flush") 
--]]

--[[
  local arg={...}
  if arg==nil or arg[0]==nil then
    mylog(fmt)
  else
    mylog(string.format(fmt,...))
  end
--]]
end

local bufferedmessages={}

function mylog(msg)
--[[
  if msg==nil then
    return 
  end
  if db and db.actor then
    if bufferedmessages then
      for k,v in ipairs(bufferedmessages) do
        db.actor:give_game_news(v, "ui\\ui_iconsTotal", Frect():set(0,0,200,200), 0, 15000)
      end
      bufferedmessages=nil
    end
  db.actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(0,0,200,200), 0, 15000)
  else
    if bufferedmessages then
      table.insert(bufferedmessages,msg)
    end
  end
]]
  if get_console() then
    get_console():execute("load "..tostring(msg))
    get_console():execute("flush")
  end 
end

function dbglog(fmt,...)
  local msg = string.format(fmt, ...)
  local msg_no_ws = string.gsub(msg, "%s", "_")
  get_console():execute("dbg:" .. msg_no_ws)
end


function validate_enemy_object( enemy )
  if not ( enemy and enemy.clsid ) then return false, nil end
  if not ( IsStalker( enemy ) or IsMonster( enemy) ) then 
    return false, nil
  end
  if enemy.health == nil or enemy.health <= 0 then 
    return false, nil
  end
  -- это грязный хак чтобы выяснить не попался ли нам серверный объект
  if enemy.m_story_id ~= nil then
    local id = enemy.id
    local enemy_gameobj = level.object_by_id( id )
    if not enemy_gameobj then
      return false, nil
    else	
      return true, enemy_gameobj
    end
  else	
    return true, enemy
  end
end


function parse_data(str)
	local string_parts = {}
	if str == nil then
		string_parts[1] = nil
		return string_parts
	end
	local str_beg,str_end
	str_end = str
	local split_pos = find_split_pos(str_end)
	while split_pos ~= nil do
		str_beg, str_end = split_string(str_end,split_pos)
		table.insert(string_parts,str_beg)
		split_pos = find_split_pos(str_end)
	end
	table.insert(string_parts,str_end)
	return string_parts
end

function find_split_pos(str)
	local split_pos = string.find(str,",")
	if split_pos == nil then
		return nil
	end
	local br1_pos = string.find(str,"(",1,true)
	local br2_pos = string.find(str,")",1,true)
	if br1_pos ~= nil and br2_pos ~= nil and br1_pos < br2_pos and split_pos > br1_pos then
		local str_end1 = string.sub(str,(br2_pos +1),string.len(str))
		if string.find(str_end1,",") ~= nil then
			split_pos = br2_pos + string.find(str_end1,",")
		else
			split_pos = nil
		end
	end
	return split_pos
end

function split_string(str,split_pos)
	local str_beg = (string.sub(str,1,split_pos-1))
	local str_end = string.sub(str,(split_pos+1),string.len(str))
	return str_beg,str_end
end

----------------------------------------------------------------------
if nil == time_global then
  time_global = function () return device():time_global() end
end

function wait_game(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = game.time() + time_to_wait
        while game.time() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function wait(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = time_global() + time_to_wait
        while time_global() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function action_first(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,true)
    end
    return  entity_action(act)
end

function round (value)
    local min = math.floor (value)
    local max = min + 1
    if value - min > max - value then return max end
    return min
end

function debug_get_level_object(obj_name)
    local res = level.debug_object(obj_name)
    while res == nil do

-- НЕ ЗАКОММЕНТАРИВАЙТЕ, ИНАЧЕ НЕ БУДЕТ ВИДНО ОШИБОК ПРИ РАССТАНОВКЕ ОБЪЕКТОВ!
        printf("get_level_object() is waiting for object \"%s\"", obj_name)

        res         = level.object(obj_name)
        wait        ()
    end
    return          res
end

function debug_get_actor()
    local res       = level.debug_actor()
    while res == nil do
        res         = level.debug_actor()
        wait        ()
    end
    return          res
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--// Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
  return obj1:position():distance_to(obj2:position())
end


--' Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
  local aa = alife()
  if aa == nil then
    return false
  end
  return aa:has_info(0, info_id)
end


--------------------------------------------------
-- іласс LUA реализуі   ий Finite State Machine
-- для управления персонажами
--------------------------------------------------
class 'FSM'

--  инициализация путем задания объекта Non-Player Character
function FSM:__init(script_name, npc_obj)
    -- указатель на подконтрольнvй NPC
    self.npc = npc_obj
    -- строка - имя скрипта, которvй запускает игру
    self.script_name = script_name
    -- матрица, задаі   ая граф переходов состояний
    -- реализуется как двумерная таблица
    self.transition_matrix = {[0] = {}}
    -- номер теку   его состояния
    self.current_state = 0

    -- флаг того, что машина вклічена
    self.machine_running = true

    printf("inialization FSM for NPC %s", self.npc:name())
end

function FSM:is_running()
    return self.machine_running
end

function FSM:start()
    printf("starting FSM for %s", self.npc:name())
    self.machine_running = true
end

function FSM:stop()
    printf("stoping FSM for %s", self.npc:name())
    self.machine_running = false
    self:reset_script_control()
end


--  добавление указателя на булеву
--  функциі условия перехода
function FSM:set_transition(from_state_num, to_state_num, cond_func)
    printf("in setting transition %d, %d ", from_state_num, to_state_num)

    if self.transition_matrix[from_state_num] == nil then
       self.transition_matrix[from_state_num] = {[to_state_num] = cond_func}
    else
       self.transition_matrix[from_state_num][to_state_num] = cond_func
    end
end

-- единичная проверка FSM
function FSM:run()
    local transition_vector = self.transition_matrix[self.current_state]
    table.foreach(transition_vector,
                  function(to_state_num, cond_func)
                        if cond_func(self.npc, self) == true then
                            printf("transition from %d to %d", self.current_state, to_state_num)

                            if to_state_num == 0 then
                                self:reset_script_control()
                            end

                            --if  self.current_state == 0 then
                            --  self:set_script_control()
                            --end

                            self.current_state = to_state_num
                            return true
                        end
                        return nil
                  end)
end


-- запуск бесконечного цикла FSM
function FSM:run_loop()
    printf("running FSM loop for NPC %s", self.npc:name())

    while self:is_running() do
        local transition_vector = self.transition_matrix[self.current_state]
        table.foreach(transition_vector,
                      function(to_state_num, cond_func)
                            if cond_func(self.npc, self) == true then
                                printf("transition from %d to %d", self.current_state, to_state_num)

                                if to_state_num == 0 then
                                    self:reset_script_control()
                                end

                                --if  self.current_state == 0 then
                                --  self:set_script_control()
                                --end

                                self.current_state = to_state_num
                                return true
                            end
                            return nil
                      end)
        if self.npc:alive () == false then
           self.npc:script (false, self.script_name)
           return
           end
        wait()
    end
end

-- взятие под контроль скрипта NPC (переход из нулевого состояния)
function FSM:set_script_control()
    printf("set script control for FSM of NPC %s", self.npc:name())
    self.npc:script(true, self.script_name)
end

-- отпускание из под контроля скрипта NPC (переход в нулевое состояние)
function FSM:reset_script_control()
    printf("reset script control for FSM of NPC %s", self.npc:name())
    self.npc:script(false, self.script_name)
end

--------------------------------------------------
-- end of  class 'FSM'
--------------------------------------------------

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

class "script_object"

function script_object:__init(self,name,script,...)
  self.action         = action(nil,...)
  self.object_name    = name
  self.script_name    = script
  self.object         = nil
end

function script_object:update()
    local                   obj = self.object
    self.object             = level.object(self.object_name)
    if ((obj == nil) and (self.object ~= nil)) then
        self.object:script  (true,self.script_name)
        self.object:command (self.action,false)
    end
end

--
-- передача персонажу информации
--

function GiveInfoViaPda(obj_receiver, obj_sender, info_number)
    obj_receiver:give_info_portion_via_pda(info_number, obj_sender)
end


--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- іонстанта, которуі использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- =азвание скрипта, которvй в даннvй момент находится в отладке
-- (в этом скрипте будут срабатvвать вvзовv функции debug_log)
debug_script_name = ""

-- Tvводит в лог строчку, если script_name == debug_script_name
-- Lспользуется для отрадки сценариев
function debug_log(script_name, fmt, ...)
  if debug_script_name == script_name then
    log(string.format(fmt, ...))
  end
end

-- +сли в даннvй момент вvполняется какое-то действие, прерvвает его и отклічает скриптовvй режим
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
    local arg = {...}
    local r = math.random(1, #arg)
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, #arg do
        act:set_action(arg[i])
    end
    return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
  if (obj ~= nil) then
    obj_last_actions[obj] = action_name
    obj:command(act, false)
  end
end

function last_action(obj)
  return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function update_action (npc, script, ...)
    local arg = {...}
    if npc == nil then return end
    local act = npc:action ()
    if arg.n == 0 then return end

    if act == nil then act = entity_action () end

    for a = 1, arg.n, 1 do
        if arg[a] ~= nil then act:set_action (arg[a]) end
    end
    reset_action (npc, script)
    npc:command (act, false)

end


function set_current_time (hour, min, sec)
    local current_time_factor = level.get_time_factor ()

    printf ("Need time : %d:%d:%d", hour, min, sec)

    local current_time = game.time ()
    local c_day = math.floor (current_time / 86400000)
    local c_time = current_time - c_day * 86400000
    local n_time = (sec + min * 60 + hour * 3600) * 1000

    if c_time > n_time then c_day = c_day + 1 end
    n_time = n_time + c_day * 86400000

    level.set_time_factor (10000)
    while game.time () < n_time do wait () end

    level.set_time_factor (current_time_factor)
end



if (editor() == false) then
class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.max_power  = dest_power
end

function pp_effector:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.max_power.dual.h         * d
    dual.v          = self.max_power.dual.v         * d

    noise.grain     = self.max_power.noise.grain        * d
    noise.intensity     = self.max_power.noise.intensity    * d
    noise.fps       = self.max_power.noise.fps      * d

    base.r          = self.max_power.color_base.r       * d
    base.g          = self.max_power.color_base.g       * d
    base.b          = self.max_power.color_base.b       * d

    gray.r          = self.max_power.color_gray.r       * d
    gray.g          = self.max_power.color_gray.g       * d
    gray.b          = self.max_power.color_gray.b       * d

    add.r           = self.max_power.color_add.r        * d
    add.g           = self.max_power.color_add.g        * d
    add.b           = self.max_power.color_add.b        * d

    pp.gray         = self.max_power.gray           * d
    pp.blur         = self.max_power.blur           * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return              true
end

function pp_effector:finished()
    return          self.stop_time < time_global()
end

--
-- postprocess for rainbow
--
class "pp_linear_lerp" (effector)

function pp_linear_lerp:__init(effector_type,start_time,life_time,start_power,dest_power) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.min_power  = start_power
    self.max_power  = dest_power
end

function pp_linear_lerp:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.min_power.dual.h         + (self.max_power.dual.h        - self.min_power.dual.h     )   * d
    dual.v          = self.min_power.dual.v         + (self.max_power.dual.v        - self.min_power.dual.v     )   * d

    noise.grain     = self.min_power.noise.grain        + (self.max_power.noise.grain       - self.min_power.noise.grain    )   * d
    noise.intensity     = self.min_power.noise.intensity    + (self.max_power.noise.intensity   - self.min_power.noise.intensity)   * d
    noise.fps       = self.min_power.noise.fps      + (self.max_power.noise.fps         - self.min_power.noise.fps  )   * d

    base.r          = self.min_power.color_base.r       + (self.max_power.color_base.r      - self.min_power.color_base.r   )   * d
    base.g          = self.min_power.color_base.g       + (self.max_power.color_base.g      - self.min_power.color_base.g   )   * d
    base.b          = self.min_power.color_base.b       + (self.max_power.color_base.b      - self.min_power.color_base.b   )   * d

    gray.r          = self.min_power.color_gray.r       + (self.max_power.color_gray.r      - self.min_power.color_gray.r   )   * d
    gray.g          = self.min_power.color_gray.g       + (self.max_power.color_gray.g      - self.min_power.color_gray.g   )   * d
    gray.b          = self.min_power.color_gray.b       + (self.max_power.color_gray.b      - self.min_power.color_gray.b   )   * d

    add.r           = self.min_power.color_add.r        + (self.max_power.color_add.r       - self.min_power.color_add.r    )   * d
    add.g           = self.min_power.color_add.g        + (self.max_power.color_add.g       - self.min_power.color_add.g    )   * d
    add.b           = self.min_power.color_add.b        + (self.max_power.color_add.b       - self.min_power.color_add.b    )   * d

    pp.gray         = self.min_power.gray           + (self.max_power.gray          - self.min_power.gray       )   * d
    pp.blur         = self.min_power.blur           + (self.max_power.blur          - self.min_power.blur       )   * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return          true
end

function pp_linear_lerp:finished()
    return          self.stop_time < time_global()
end
--
-- end of postprocess for rainbow
--

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
-- зарезервированv id с номерами от 0 до 256 для создания стандартнvх эвалуаторов.

--Constant evaluator
class "const_evaluator" (property_evaluator)

function const_evaluator:__init (name, value) super (nil, name)
    self.value = value
end

function const_evaluator:evaluate()
    return          self.value
end

--Wait evaluator
class "wait_evaluator" (property_evaluator)

function wait_evaluator:__init (wait_time) super ()
    self.wait_time = wait_time
    self.first_call = true
    self.current_time = 0
end

function wait_evaluator:evaluate ()
    if self.first_call == true then
       self.first_call = false
       self.current_time = device ():time_global ()
       return false
    end

    local t = device():time_global () - self.current_time;
    if t > self.wait_time then return true end
    return false
end
--------------------------------------------------------------------------------
class "enabled_evaluator" (property_evaluator)

function enabled_evaluator:__init (name, storage) super ()
    self.a = storage
end

function enabled_evaluator:evaluate()
    return  self.a.enabled
end

end -- end of editor() == false


function str_split (str)

    local strlen = string.len (str)

    local parts = {{}, {}, {}, {}}
    local cpart = 1

    for a = 1, strlen, 1 do
        local char = string.byte (str, a)
        if char ~= 95 then
           table.insert (parts[cpart], char)
        else
           cpart = cpart + 1
           if cpart > 4 then break end
        end
    end

    if cpart ~= 4 then return "unknown", "stalker", 0, 0 end

    local str1 = string.char ()
    local str2 = string.char ()
    local str3 = string.char ()
    local str4 = string.char ()

    local ref = parts[1]
    for a = 1, #ref, 1 do
        str1 = string.format ("%s%c", str1, ref[a])
    end

    ref = parts[2]
    for a = 1, #ref, 1 do
        str2 = string.format ("%s%c", str2, ref[a])
    end

    ref = parts[3]
    for a = 1, #ref, 1 do
        str3 = string.format ("%s%c", str3, ref[a])
    end

    ref = parts[4]
    for a = 1, #ref, 1 do
        str4 = string.format ("%s%c", str4, ref[a])
    end

    printf ("%s %s %d %d", str1, str2, str3, str4)
    return str1, str2, (str3 + 1) - 1, (str4 + 1) - 1
end

function random_number (min_value, max_value)
    math.randomseed (device ():time_global ())
    if min_value == nil and max_value == nil then
      return math.random ()
    else
      return math.random (min_value, max_value)
    end
end

-- ‚аҐ¬п бгв®Є ў ¬б
-- —гЈ ©
local ms_per_day = 24 * 60 * 60 * 1000
function day_time()
    return math.mod( game.time(), ms_per_day )
end

--Time in hours
function local_hours()
    return math.floor( math.mod( game.time()/1000, 86400 )/ 3600 )
end

function r_bool(spawn_ini, section, line, default)
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_bool( section, line )
	else
		return default
	end
end

function r_str(spawn_ini, section, line, default)
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_string( section, line )
	else
		return default
	end
end

function r_num(spawn_ini, section, line, default)
	if spawn_ini:line_exist( section, line ) then
		return spawn_ini:r_float( section, line )
	else
		return default
	end
end

--/ парсит строку вида "ааа, ббб, ввв ..." в таблицу { "ааа", "ббб", "ввв", ... }
function parse_names( s )
	local t = {}
	for name in s:gmatch("[^,%s]+" ) do
		table.insert( t, name )
	end
    return t
end


function parse_key_value( s )
    local t = {}
  if s == nil then
    return nil
  end
    local key, nam = nil, nil
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
    if key == nil then
      key = name
    else
      t[key] = name
      key = nil
    end
    end
    return t
end


-- Ї абЁв бва®Єг ўЁ¤  "n1, n2, n3..." ў в Ў«Ёжг { n1, n2, n3, ... } Ј¤Ґ n1, n2, n3... - жҐ«лҐ зЁб« 
-- —гЈ ©
--[[function parse_nums( s )
    local t = {}

    for entry in string.gfind( s, "([%w_\\]+)%p*" ) do
        table.insert( t, tonumber( entry ) )
    end

    return t
end]]

--/ парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
function parse_nums( s )
    local t = {}
    for i,entry in ipairs(parse_names( s )) do
		local v = tonumber( entry )
		if not v then
			--log1("xxxxxxxxxxxxxxxxxxxxxxxxxx")
			--log3("parse_nums: '%s', stopped at %d:'%s'", tostring(s), i, tostring(entry))
			--ASSERT(v, "parse_nums: '%s', stopped at %d:'%s'", tostring(s), i, tostring(entry))
			abort("aaaaaaaaaaaaaaa")
		end
		table.insert(t,  v)
    end
    return t
end
--[[function r_2nums(ini, section, line, default1, default2)
	if ini:line_exist(section, line) then
		local s = ini:r_string(section, line)
		local at, to, num1, num2 = string.find(s, "([%d%.]+)%s*,%s*([%d%.]+)")
		return (tonumber(num1) or default1), (tonumber(num2) or default2)
	else
		return default1, default2
	end
end]]
function r_2nums( spawn_ini, section, line, def1, def2 )
	--log3("r_2nums: %s, %s", section, line)
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local s = spawn_ini:r_string( section, line )
		--log3("r_2nums: %s", s)
		local t = parse_nums( s )
		ASSERT(#t<=2, "r_2nums: incorrect line '%s'", tostring(s))
		return (t[1] or def1), (t[2] or def2)
	else
		return def1, def2
	end
end
function r_2strings( spawn_ini, section, line, def1, def2 )
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local s = spawn_ini:r_string( section, line )
		--log3("r_2nums: %s", s)
		local t = parse_names( s )
		ASSERT(#t<=2, "r_2nums: incorrect line '%s'", tostring(s))
		return (t[1] or def1), (t[2] or def2)
	else
		return def1, def2
	end
end
-- Їа®ўҐапҐв, Ґбвм «Ё ®ЎкҐЄв ў ®­« ©­Ґ
function is_object_online(obj_id)
	return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
    if npc == nil then return nil end
	if npc and npc.id then
		if type(npc.id) == "function" then
			local id = npc:id()
			local sobj = alife():object(id)
			if sobj then
				return npc:clsid()
			else
--				log1(debug.traceback())
--				log2("!!DEBUG_GETCLSID NO_SRVOBJ ["..tostring(id)..", %s]", tostring( npc:name() ))
				return nil
			end
		elseif type(npc.id) == "number" then
			return npc:clsid()
		else
			log1(debug.traceback())
			log1("!!DEBUG_GETCLSID GET_SOMETHING_STRANGE")
			return nil
		end
	else
		log1(debug.traceback())
		log1("!!DEBUG_GETCLSID DEAD_ON_ARRIVAL")
		return nil
	end
--    if is_object_online(npc:id()) then
--      return npc:clsid()
--    else
--        return nil
--    end
end

--[[ Їа®ўҐапҐв ®аг¦ЁҐ «Ё нв® (ЇҐаҐ¤ ў вм game_object)
function isWeapon(object)
    local id = get_clsid(object)
    if id == nil then return false end

    if id == clsid.wpn_vintorez_s then return true
    elseif id == clsid.wpn_ak74_s then return true
    elseif id == clsid.wpn_lr300_s then return true
    elseif id == clsid.wpn_hpsa_s then return true
    elseif id == clsid.wpn_pm_s then return true
    elseif id == clsid.wpn_shotgun_s then return true
    elseif id == clsid.wpn_bm16_s then return true
    elseif id == clsid.wpn_svd_s then return true
    elseif id == clsid.wpn_svu_s then return true
    elseif id == clsid.wpn_rpg7_s then return true
    elseif id == clsid.wpn_val_s then return true
    elseif id == clsid.wpn_walther_s then return true
    elseif id == clsid.wpn_usp45_s then return true
    elseif id == clsid.wpn_groza_s then return true
    elseif id == clsid.wpn_knife_s then return true
    elseif id == clsid.wpn_grenade_launcher then return true
    elseif id == clsid.wpn_grenade_f1 then return true
    elseif id == clsid.wpn_grenade_rpg7 then return true
    elseif id == clsid.wpn_grenade_rgd5 then return true
    elseif id == clsid.wpn_grenade_fake then return true
    else return false end
end]]
--[[local clsid_weapon_full = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_fn2000]              = true,
    [clsid.wpn_fort]                = true,
    [clsid.wpn_grenade_f1]          = true,
    [clsid.wpn_grenade_fake]        = true,
    [clsid.wpn_grenade_launcher]    = true,
    [clsid.wpn_grenade_rgd5]        = true,
    [clsid.wpn_grenade_rpg7]        = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_knife_s]             = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
    [clsid.wpn_rg6_s]               = true,
    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true,
}]]
function isWeapon (object, class_id)
	if object and (string.find(object:name(), "wpn_binoc") or string.find(object:name(), "bolt")) then
	return false end
	local id = class_id or get_clsid(object)
	return IAmAWeapon[id] == true
end
function isWeaponFireOnly(object)
local clsid_weapon_fireonly = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_fn2000]              = true,
    [clsid.wpn_fort]                = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
    [clsid.wpn_rg6_s]               = true,
    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true,
}
    return (object and clsid_weapon_fireonly[object:clsid()])
end
IAmAWeapon = {}
function IAmAWeaponInit()
    IAmAWeapon = {
		[clsid.wpn_ak74_s]              = true,
		[clsid.wpn_bm16_s]              = true,
		[clsid.wpn_grenade_f1]          = true,
		[clsid.wpn_grenade_fake]        = true,
		[clsid.wpn_grenade_launcher]    = true,
		[clsid.wpn_grenade_rgd5]        = true,
		[clsid.wpn_grenade_rpg7]        = true,
		[clsid.wpn_groza_s]             = true,
		[clsid.wpn_hpsa_s]              = true,
		[clsid.wpn_knife_s]             = true,
		[clsid.wpn_lr300_s]             = true,
		[clsid.wpn_pm_s]                = true,
		[clsid.wpn_rpg7_s]              = true,
		[clsid.wpn_shotgun_s]           = true,
		[clsid.wpn_svd_s]               = true,
		[clsid.wpn_svu_s]               = true,
		[clsid.wpn_usp45_s]             = true,
		[clsid.wpn_val_s]               = true,
		[clsid.wpn_vintorez_s]          = true,
		[clsid.wpn_walther_s]           = true
    }
end
IAmAWeaponFireOnly = {}
function IAmAWeaponFireOnlyInit()
    IAmAWeaponFireOnly = {
		[clsid.wpn_ak74_s]              = true,
		[clsid.wpn_bm16_s]              = true,
		[clsid.wpn_fn2000]              = true,
		[clsid.wpn_fort]                = true,
		[clsid.wpn_groza_s]             = true,
		[clsid.wpn_hpsa_s]              = true,
		[clsid.wpn_lr300_s]             = true,
		[clsid.wpn_pm_s]                = true,
		[clsid.wpn_rg6_s]               = true,
		[clsid.wpn_rpg7_s]              = true,
		[clsid.wpn_shotgun_s]           = true,
		[clsid.wpn_svd_s]               = true,
		[clsid.wpn_svu_s]               = true,
		[clsid.wpn_usp45_s]             = true,
		[clsid.wpn_val_s]               = true,
		[clsid.wpn_vintorez_s]          = true,
		[clsid.wpn_walther_s]           = true
    }
end
function isMagazinedWeapon(object)
local clsid_magazined_weapon = {
    [clsid.wpn_ak74_s]              = true,
    [clsid.wpn_bm16_s]              = true,
    [clsid.wpn_groza_s]             = true,
    [clsid.wpn_hpsa_s]              = true,
    [clsid.wpn_lr300_s]             = true,
    [clsid.wpn_pm_s]                = true,
--    [clsid.wpn_rpg7_s]              = true,
    [clsid.wpn_shotgun_s]           = true,
    [clsid.wpn_svd_s]               = true,
    [clsid.wpn_svu_s]               = true,
    [clsid.wpn_usp45_s]             = true,
    [clsid.wpn_val_s]               = true,
    [clsid.wpn_vintorez_s]          = true,
    [clsid.wpn_walther_s]           = true,
    [clsid.wpn_binocular_s]         = true,
    [clsid.wpn_rg6_s]               = true,
}
    return (object and clsid_magazined_weapon[object:clsid()])
end

--Tvчисляет yaw в радианах
function yaw( v1, v2 )
    return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) )
end

function yaw_degree( v1, v2 )
    return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
    return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/math.sqrt((v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

--//Вращает вектор вокруг оси y против часовой стрелки

function vector_rotate_y (v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- очистка таблицы
function clear_table (t)
    local table_remove = table.remove
    while #t > 0 do
          table_remove (t, #t)
    end
end

--€бЇ®«м§гҐв ¤«п ¬®­бва®ў. ‚лЎ®а в®зЄЁ, Єг¤  Ё¤вЁ ў ­ҐЄ®в®а®¬ а ¤ЁгбҐ Ё зв®Ў в®зЄ  Ўл«  ¤ «миҐ ­  а ббв®п­ЁЁ
-- min_radius ®в вҐЄгйҐ© Ї®§ЁжЁЁ(Ґб«Ё нв® Ї®«гзЁвбп). center_id - жҐ­ва Ї®§ЁжЁЁ, ў®ЄагЈ Є®в®а®© ¦ЁўҐ¬,
-- position_id - вгЄгй п Ї®§ЁжЁп, radius - ў Є Є®¬ а ¤ЁгбҐ ўлЎЁа вм в®зЄг, min_radius - ¬Ё­Ё¬ «м­®Ґ а ббв®п­ЁҐ, ®в вҐЄгйҐ© Ї®§ЁжЁЁ ¤® ­®ў®© в®зЄЁ.
function new_point(center_id, position_id,radius, min_radius)
    local math_random = math.random
    local dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
    local pos = level.vertex_in_direction(center_id, dir, radius)
    local i   = 1

    while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
        dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
        pos = level.vertex_in_direction(center_id, dir, radius)
        i   = i + 1
    end

    return (level.vertex_position(pos))
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

function object_type(obj)
    local otype = get_clsid(obj)
    local type

    if  otype == clsid.actor or
        otype == clsid.script_stalker or
        otype == clsid.script_trader
    then
        type = "stalker"
    elseif  otype == clsid.crow or
        otype == clsid.zombie or
        otype == clsid.flesh or
        otype == clsid.controller or
        otype == clsid.bloodsucker or
        otype == clsid.burer or
        otype == clsid.fracture or
        otype == clsid.chimera or
        otype == clsid.boar or
        otype == clsid.flesh_group or
        otype == clsid.dog_red or
        otype == clsid.dog_black or
        otype == clsid.cat or
        otype == clsid.pseudo_gigant
    then
        type = "monstr"
    elseif  otype == clsid.wpn_fn2000 or
        otype == clsid.wpn_ak74 or
        otype == clsid.wpn_lr300 or
        otype == clsid.wpn_hpsa or
        otype == clsid.wpn_pm or
        otype == clsid.wpn_fort or
        otype == clsid.wpn_binocular or
        otype == clsid.wpn_shotgun or
        otype == clsid.wpn_svd or
        otype == clsid.wpn_svu or
        otype == clsid.wpn_rpg7 or
        otype == clsid.wpn_val or
        otype == clsid.wpn_vintorez or
        otype == clsid.wpn_walther or
        otype == clsid.wpn_usp45 or
        otype == clsid.wpn_groza or
        otype == clsid.wpn_knife or
        otype == clsid.wpn_scope or
        otype == clsid.wpn_silencer or
        otype == clsid.wpn_grenade_launcher or
        otype == clsid.obj_physic or
        otype == clsid.obj_breakable or
        otype == clsid.device_pda or
        otype == clsid.device_torch or
        otype == clsid.device_detector_simple or
        otype == clsid.obj_bolt or
        otype == clsid.obj_medkit or
        otype == clsid.obj_food or
        otype == clsid.obj_bottle or
        otype == clsid.obj_antirad or
        otype == clsid.obj_explosive or
        otype == clsid.obj_document or
        otype == clsid.obj_attachable or
        otype == clsid.wpn_grenade_f1 or
        otype == clsid.wpn_grenade_rpg7 or
        otype == clsid.wpn_grenade_rgd5 or
        otype == clsid.wpn_grenade_fake or
        otype == clsid.equ_scientific or
        otype == clsid.equ_stalker or
        otype == clsid.equ_military or
        otype == clsid.equ_exo or
        otype == clsid.wpn_ammo or
        otype == clsid.wpn_ammo_vog25 or
        otype == clsid.wpn_ammo_og7b or
        otype == clsid.wpn_ammo_m209
    then
        type = "item"
    else
        type = "none"
    end

    -- Їа®ўҐапҐ¬ ­Ґ вагЇ «Ё нв®
    if type == "stalker" or
       type == "monstr" then
        if obj:alive() == false then
            type = "corpse"
        end
    end

    return type
end


--// Является ли оbj монстром
function is_object_monster(obj)
  local otype = get_clsid(obj)
  if(otype == clsid.crow      or
    otype == clsid.zombie   or
    otype == clsid.flesh    or
    otype == clsid.controller or
    otype == clsid.bloodsucker  or
    otype == clsid.burer    or
    otype == clsid.fracture    or
    otype == clsid.chimera    or
    otype == clsid.boar     or
    otype == clsid.dog_red    or
    otype == clsid.dog_black  or
	otype == clsid.cat		or

    otype == clsid.poltergeist  or
    otype == clsid.pseudo_gigant  )
  then
    return true
  end

  return false
end

--ў®§ўа й Ґв Їа®Ё§ў®«м­го в®зЄг ЇгвЁ г Є®в®а®© гбв ­®ў«Ґ­ ЎЁв
function point_with_bit(patrol_path, bit, old_point)      -- old_point - Ё­¤ҐЄб в®зЄЁ, Є®в®аго ­Ґ ­ ¤® ўлЎЁа вм,
  local points = {}                                       -- Ї а ¬Ґва ­Ґ ®Ўп§ вҐ«м­л©( ­ ЇаЁ¬Ґа вҐЄгйҐ© в®зЄЁ )

    for i = 0, patrol_path:count()-1 do
      --„®Ў®ў«пҐ¬ ў в Ў«Ёжг в®зЄЁ б ­г¦­л¬ ЎЁв®¬
      if( patrol_path:flag(i, bit)) then
            --„®Ў ў«пҐ¬ в®зЄг Ґб«Ё old_point == nil Ё«Ё ­®ў п в®зЄ  ­Ґ б®ўЇ ¤ Ґв б old_point
            if old_point == nil or old_point ~= i then
                table.insert(points, patrol_path:point(i))
            end
        end
    end

    local number_point = #points

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return points[1]
    else
        return points[math.random(1, number_point)]
    end
end

--ў®§ўа й Ґв Їа®Ё§ў®«м­го в®зЄг ЇгвЁ г Є®в®а®© гбв ­®ў«Ґ­ ЎЁв
function point_with_bit_id(patrol_path, bit, old_point)        -- old_point - Ё­¤ҐЄб в®зЄЁ, Є®в®аго ­Ґ ­ ¤® ўлЎЁа вм,
    local points = {}                                          -- Ї а ¬Ґва ­Ґ ®Ўп§ вҐ«м­л©( ­ ЇаЁ¬Ґа вҐЄгйҐ© в®зЄЁ )

    for i = 0, patrol_path:count()-1 do
      --„®Ў®ў«пҐ¬ ў в Ў«Ёжг в®зЄЁ б ­г¦­л¬ ЎЁв®¬
      if( patrol_path:flag(i, bit)) then
            --„®Ў ў«пҐ¬ в®зЄг Ґб«Ё old_point == nil Ё«Ё ­®ў п в®зЄ  ­Ґ б®ўЇ ¤ Ґв б old_point
            if old_point == nil or old_point ~= i then
                table.insert(points, i)
            end
        end
    end

    local number_point = #(points)

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return patrol_path:level_vertex_id(points[1])
    else
        return patrol_path:level_vertex_id(points[math.random(1, number_point)])
    end
end

--‚®§ўа й Ґв Ё­¤ҐЄб б ¬®© Ў«Ё¦­Ґ© в®зЄЁ ЇгвЁ б § ¤ ­л¬ ЎЁв®¬, ®в вҐЄгйҐ© в®зЄЁ
function near_point_with_bit(point, patrol_path, bit)
    local new_point = nil
    local index     = nil
    local dist      = 1000.0

    for i = 0, patrol_path:count()-1 do
        if( patrol_path:flag(i, bit) ) then
            if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
                -- б«Ё нв  в®зЄ  ЇҐаў п Ё§ ­ иҐ¤иЁебп, «ЁЎ® ®в ­ҐҐ Їгвм Ў«Ё¦Ґ, в® § Ї®¬Ё­ Ґ¬ ҐҐ
                new_point   = patrol_path:point(i)
                index       = i
                dist        = new_point:distance_to(point)
             end
        end
    end

    return index
end

--/ ђҐЄгабЁў­ п а бЇҐз вЄ  в Ў«Ёжл
function print_table(table, subs)
	do return end -- ўбс а ў­® нв® ­Ґ а Ў®в Ґв,   ўл§лў Ґвбп ¬­®Ј® ®вЄг¤ 
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	for k,v in pairs(table) do
		if type(v) == "table" then
			printf(sub.."%s:", tostring(k))
			print_table(v, sub.."    ")
		elseif type(v) == "function" then
			printf(sub.."%s:function", tostring(k))
		elseif type(v) == "userdata" then
			printf(sub.."%s:userdata", tostring(k))
		elseif type(v) == "boolean" then
			if v == true then
				printf(sub.."%s:true", tostring(k))
			else
				printf(sub.."%s:false", tostring(k))
			end
		else
			if v ~= nil then
				printf(sub.."%s:%s", tostring(k),v)
			else
				printf(sub.."%s:nil", tostring(k),v)
			end
		end
	end
end

--/ ђҐЄгабЁў­ п а бЇҐз вЄ  в Ў«Ёжл
function print_table_inlog(table, subs)
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	for k,v in pairs(table) do
		if type(v) == "table" then
			log1(sub.." "..tostring(k)..": table")
			print_table_inlog(v, sub.."    ")
		elseif type(v) == "function" then
			log1(sub.." "..tostring(k)..": function")
		elseif type(v) == "userdata" then
			log1(sub.." "..tostring(k)..": userdata")
		elseif type(v) == "boolean" then
			if v == true then
				log1(sub.." "..tostring(k)..": true")
			else
				log1(sub.." "..tostring(k)..": false")
			end
		else
			if v ~= nil then
				log1(sub.." "..tostring(k)..": "..tostring(v))
			else
				log1(sub.." "..tostring(k)..": is NIL")
			end
		end
	end
end

--/ ђҐЄгабЁў­ п а бЇҐз вЄ  в Ў«Ёжл
function print_table_inlog_v2(table, subs)
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	for k,v in pairs(table) do
		if type(v) == "table" then
			log1(sub.." "..tostring(k)..": table")
			print_table_inlog_v2(v, sub.."    ")
		elseif type(v) == "function" then
			log1(sub.." "..tostring(k)..": function")
		elseif type(v) == "userdata" then
			log1(sub.." "..tostring(k)..": userdata")
		elseif type(v) == "boolean" then
			if v == true then
				log1(sub.." "..tostring(k)..": true")
			else
				log1(sub.." "..tostring(k)..": false")
			end
		else
			if v ~= nil then
				log1(sub.." "..tostring(k)..": "..tostring(v))
			else
				log1(sub.." "..tostring(k)..": is NIL")
			end
		end
	end
end

-------------------------------------------------------------------------------------------
function switch_online (id)
    if id == -1 then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (id, true)
       sim:set_switch_offline (id, false)
    end
end
-------------------------------------------------------------------------------------------
function switch_offline (npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
function get_actor_id()
  if(level.actor() == nil) then return -1 end
  return level.actor():id()
end
-------------------------------------------------------------------------------------------
function IsMonster (object, class_id)
    local id = class_id or get_clsid (object)
    return IAmAMonster[ id ] or false
--[[
	local monsters = {
		[clsid.boar_s] = true,
		[clsid.bloodsucker_s] = true,
		[clsid.dog_s] = true,
		[clsid.flesh_s] = true,
		[clsid.pseudodog_s] = true,
		[clsid.psy_dog_s] = true,
		[clsid.burer_s] = true,
		[clsid.cat_s] = true,
		[clsid.chimera_s] = true,
		[clsid.controller_s] = true,
		[clsid.fracture_s] = true,
		[clsid.poltergeist_s] = true,
		[clsid.gigant_s] = true,
		[clsid.zombie_s] = true,
		[clsid.tushkano_s] = true,
		[clsid.snork_s] = true
	}
	return monsters[id] or false
]]
--[[    if id == clsid.boar_s or
       id == clsid.bloodsucker_s or
       id == clsid.dog_s or
       id == clsid.flesh_s or
       id == clsid.pseudodog_s or
       id == clsid.psy_dog_s or
       id == clsid.burer_s or
       id == clsid.cat_s or
       id == clsid.chimera_s or
       id == clsid.controller_s or
       id == clsid.fracture_s or
       id == clsid.poltergeist_s or
       id == clsid.gigant_s or
       id == clsid.zombie_s or
       id == clsid.tushkano_s or
       id == clsid.snork_s
    then
      return true
  end
    return false]]
end
-------------------------------------------------------------------------------------------
function IsActor (object, class_id)
		local id = class_id or get_clsid(object)
		if id then
			return id == clsid.actor
		end
		return false
end
-------------------------------------------------------------------------------------------
function IsStalker (object, class_id)
    local id = class_id or get_clsid (object)
    return IAmAStalker[ id ] or false
--[[    if id == clsid.actor or id == clsid.script_stalker then
       return true
    end
    return false]]
--[[
	local Stalkers = {
	 [clsid.actor] = true,
	 [clsid.script_stalker] = true
	}
	return Stalkers[id] or false
]]
end
IAmAStalker = {}
function IAmAStalkerInit()
    IAmAStalker = {
        [clsid.actor] = true,
        [clsid.script_stalker] = true
    }
end
IAmAMonster = {}
function IAmAMonsterInit()
    IAmAMonster = {
		[clsid.bloodsucker] 			= true,
		[clsid.boar] 					= true,
		[clsid.dog_red] 				= true,
		[clsid.dog_black] 				= true,
		[clsid.flesh] 					= true,
		[clsid.burer] 					= true,
		[clsid.cat] 					= true,
		[clsid.chimera] 				= true,
		[clsid.controller] 				= true,
		[clsid.fracture] 				= true,
		[clsid.poltergeist] 			= true,
		[clsid.zombie] 					= true,
		[clsid.snork] 					= true,
		[clsid.tushkano] 				= true,
		[clsid.psy_dog] 				= true,
		[clsid.psy_dog_phantom] 		= true,	
		[clsid.pseudo_gigant] 			= true,	
		[clsid.bloodsucker_s] 			= true,
		[clsid.boar_s] 					= true,
		[clsid.dog_s] 					= true,
		[clsid.flesh_s] 				= true,
		[clsid.pseudodog_s] 			= true,
		[clsid.burer_s] 				= true,
		[clsid.cat_s] 					= true,
		[clsid.chimera_s] 				= true,
		[clsid.controller_s] 			= true,
		[clsid.fracture_s] 				= true,
		[clsid.poltergeist_s] 			= true,
		[clsid.gigant_s] 				= true,
		[clsid.zombie_s] 				= true,
		[clsid.snork_s] 				= true,
		[clsid.tushkano_s] 				= true,
		[clsid.psy_dog_s] 				= true,
		[clsid.psy_dog_phantom_s] 		= true
    }
end
-------------------------------------------------------------------------------------------
local indoor_levels = {
  [ "av_peshera"            ] = true,
  [ "jupiter_underground"   ] = true,
  [ "l03u_agr_underground"  ] = true,
  [ "l04u_labx18"           ] = true,
  [ "l08u_brainlab"         ] = true,
  [ "l10u_bunker"           ] = true,
  [ "l12u_sarcofag"         ] = true,
  [ "l12u_control_monolith" ] = true,
  [ "labx8"                 ] = true,
  [ "peshera"               ] = true,
  [ "warlab"                ] = true,
}
function isIndoor( lname )
  return indoor_levels[ lname ] or false
end
-------------------------------------------------------------------------------------------
function level_object_by_sid( sid )
  local sim = alife()

  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return level.object_by_id( se_obj.id )
    end
  end

  return nil
end

-------------------------------------------------------------------------------------------
function isKnife(object, class_id)
		local id = class_id or get_clsid(object)
		if id == clsid.wpn_knife or id == clsid.wpn_knife_s then
			return true
		end
		return false
end
-------------------------------------------------------------------------------------------
function isRegisteredLevel(game_vertex_id)
	local level_id = game_graph():vertex(game_vertex_id):level_id()
	return (level_id > 0 and level_id < 24) -- при добавлении новых локаций увеличить счетчик
end
-------------------------------------------------------------------------------------------
function id_by_sid( sid )
  local sim = alife()

  if sim then
    local se_obj = sim:story_object( sid )
    if se_obj then
      return se_obj.id
    end
  end

  return nil
end

-- быстрый if
function iif(t,t1,t2)
	if t then
		return t1
	else
		return t2
	end
end

function level_object_by_sid( sid )
	local id = id_by_sid( sid )
	if id then
		return level.object_by_id(id)
	end
	return nil
end

local crash_counter = 0
local crash_text = game.translate_string("msg_crash_text")

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	log1("info-"..fmt)
	local message = string.format(fmt, ...)
--[=[
	for i = 0,9 do
		log1(msg_crash[i])
	end
	ogse_debug.dump_actor_codes()
--]=]
	log1(debug.traceback())
--	log1("ПОСЛЕДНЕЕ СООБЩЕНИЕ СИСТЕМЫ OFFLINE_ALIFE: "..amk_offline_alife.last_debug_message)
	log1("ОПИСАНИЕ ОШИБКИ: "..message)
	get_console():execute("flush")

--[=[
	local hud = get_hud()
	local critical = hud:GetCustomStatic("btr_critical")
	if not critical then
		hud:AddCustomStatic("btr_critical", true)
		critical = hud:GetCustomStatic("btr_critical"):wnd()
		critical:SetText(crash_text)
	end	
--]=]
	
	if crash_counter == 0 then
		crash_counter = crash_counter + 1	
		log3("ABORT: fail(message)")
		fail(message)
	elseif crash_counter == 1 then
		crash_counter = crash_counter + 1
		log3("ABORT: 1/crash")	
		local crash
		local ooops = 1/crash
	elseif crash_counter == 2 then
		crash_counter = crash_counter + 1
		log3("ABORT: string.format")	
		string.format("%s")		
	elseif crash_counter == 3 then
		crash_counter = crash_counter + 1
		log3("ABORT: log3")	
		log3("%s")		
	else
	
		crash_counter = crash_counter + 1
		log3("get_console():execute quit")
		get_console():execute("quit")
	end
end


function set_inactivate_input_time( delta )
  dsh.set_inactivate_input_time( delta )
end


-- Принимает: позицию положения, позицию куда смотреть, время сна в минутах.
function set_sleep_relocate(point, look, timeout)
  db.storage[db.actor:id()].sleep_relocate_time = game.get_game_time()
  db.storage[db.actor:id()].sleep_relocate_idle = timeout*60
  db.storage[db.actor:id()].sleep_relocate_point = point
  db.storage[db.actor:id()].sleep_relocate_look = look

  --set_inactivate_input_time(timeout*60)
  --db.actor:actor_sleep(0, timeout)
end

-- проверяет целую часть числа на нечётность
function odd( x )
  return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--' Усталость
function on_actor_critical_power()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_11_weakness")
  end
  if not has_alife_info("encyclopedy_tutorial_weakness") then
    db.actor:give_info_portion("encyclopedy_tutorial_weakness")
  end
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_8_wound")
  end
  if not has_alife_info("encyclopedy_tutorial_wound") then
    db.actor:give_info_portion("encyclopedy_tutorial_wound")
  end
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_6_radiation")
  end
  if not has_alife_info("encyclopedy_tutorial_radiation") then
    db.actor:give_info_portion("encyclopedy_tutorial_radiation")
  end
end

--' Заклинило оружие
function on_actor_weapon_jammed()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_9_weapon")
  end
  if not has_alife_info("encyclopedy_tutorial_weapon") then
    db.actor:give_info_portion("encyclopedy_tutorial_weapon")
  end
end

--' не может ходить изза веса
function on_actor_cant_walk_weight()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_14_overload")
  end
  if not has_alife_info("encyclopedy_tutorial_overload") then
    db.actor:give_info_portion("encyclopedy_tutorial_overload")
  end
end

--' пси воздействие
function on_actor_psy()
end

function set_actor_rank(rank)
  if rank == "novice" then
    db.actor:set_character_rank(0)
  elseif rank == "stalker" then
    db.actor:set_character_rank(300)
  elseif rank == "veteran" then
    db.actor:set_character_rank(600)
  elseif rank == "master" then
    db.actor:set_character_rank(900)
  end
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end

  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()

  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end


function start_game_callback()
  dsh_cfg.on_game_start()
  task_manager.clear_task_manager()
  treasure_manager.clear_treasure_manager()
  dialog_manager.fill_phrase_table() 

  --AMK UTILS--
  amk.on_game_start(obj)
  amk_utils.start_game()
  --AMK UTILS--

  m_netpk.attach() -- инициализация модуля m_netpk

  -- xStream -- sandbox init --
  xs_sandbox.init()
  event( "game_start" ):trigger()
end


--[[ Этой таблицей не нужно пользоваться. Здесь не все секции, и их нужно каждый раз дописывать при добавлении новых патронов. 
Она убрана из treasure_manager.script и не используется. Если нужно определить патроны по секции, используйте функцию ниже.
ammo_section = {}
ammo_section["ammo_9x18_fmj"]		= true
ammo_section["ammo_9x18_pbp"]		= true
ammo_section["ammo_9x18_pmm"]		= true
ammo_section["ammo_9x19_fmj"]		= true
ammo_section["ammo_9x19_pbp"]		= true
ammo_section["ammo_5.45x39_fmj"]	= true
ammo_section["ammo_5.45x39_ap"]		= true
ammo_section["ammo_5.56x45_ss190"]	= true
ammo_section["ammo_5.56x45_ap"]		= true
ammo_section["ammo_5.7x28_fmj"]		= true
ammo_section["ammo_5.7x28_ap"]		= true
ammo_section["ammo_7.62x54_7h1"]	= true
ammo_section["ammo_7.62x54_ap"]		= true
ammo_section["ammo_7.62x54_7h14"]	= true
ammo_section["ammo_9x39_pab9"]		= true
ammo_section["ammo_gauss"]			= true
ammo_section["ammo_super_gauss"]		= true
ammo_section["ammo_9x39_ap"]		= true
ammo_section["ammo_9x39_sp5"]		= true
ammo_section["ammo_11.43x23_fmj"]	= true
ammo_section["ammo_11.43x23_hydro"]	= true
ammo_section["ammo_12x70_buck"]		= true
ammo_section["ammo_12x76_dart"]		= true
ammo_section["ammo_12x76_zhekan"]	= true
ammo_section["ammo_7.62x25_p"]		= true
ammo_section["ammo_7.62x25_ps"]		= true
ammo_section["ammo_7.62x51_fmj"]	= true
ammo_section["ammo_7.62x51_ap"]		= true
ammo_section["ammo_7.62x54r"]	= true
ammo_section["ammo_minigun"]		= true
ammo_section["ammo_5.7x28_ss190"]		= true
ammo_section["ammo_arboltl"]		= true
ammo_section["ammo_igl"]		= true
ammo_section["ammo_7.62x51box"]		= true
ammo_section["ammo_12.7x108"]		= true
]]
function ammo_section( section )
  return get_string( section, "class" ) == "AMMO"
end

function ASSERT(cond, msg, ...)
	if not cond then
		abort(msg, ...)
	end
end
-- служебные функции для чтения параметров из секций объектов
function get_string(section, param, def_val, ini_file)
	ASSERT(section, "get_string: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string(section, param)
	else
		return def_val
	end
end
function get_string_wq(section, param, def_val, ini_file)
	ASSERT(section, "get_string: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string_wq(section, param)
	else
		return def_val
	end
end
function get_u32(section, param, def_val, ini_file)
	ASSERT(section, "get_u32: section not defined, param="..tostring(param))
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_u32: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_u32(section, param)
	else
		return def_val
	end
end
function get_bool(section, param, def_val, ini_file)
	ASSERT(section, "get_bool: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_bool: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_bool(section, param)
	else
		return not (not def_val)
	end
end
function get_float(section, param, def_val, ini_file)
	ASSERT(section, "get_float: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_float: section '"..section.."' doesn't exist for param="..param)
	if ini:line_exist(section, param) then
		return ini:r_float(section, param)
	else
		return def_val
	end
end
-- получить класс из секции, полезно в том случае, если нет объекта (и недоступен метод clsid), а есть только имя секции
function get_class(section)
	ASSERT(section, "get_class: section parameter is not defined")
	ASSERT(sys_ini:section_exist(section), "get_class: section '"..section.."' doesn't exist")
	ASSERT(sys_ini:line_exist(section, "class"), "get_class: there is no 'class' parameter in the section '"..section.."'")
	return sys_ini:r_clsid(section, "class")
end
-- делит строку в виде "aaa,bbb,ccc" на строки "aaa", "bbb", "ccc" и возвращает их в виде массива
function split_comma_separated_list(s)
	local res = {}
	for v in string.gmatch(s, "[^,]+") do
		table.insert(res, v)
	end
	return res
end
-- читает время, сохранённое в виде строки со значениями, разделёнными запятой, и конвертирует в значение класса CTime
function unpack_time_from_string(str_time)
	local time_values = {}
	for i,s in ipairs(split_comma_separated_list(str_time)) do
		local value = tonumber(s)
		ASSERT(value, "unpack_time_from_string: problem with unpacking saved time '%s', value #%d (%s)", str_time, i, tostring(s))
		table.insert(time_values, value)
	end
	ASSERT(#time_values == 7, "unpack_time_from_string: packed time '%s' has wrong number of components. Must be equal to seven.")
	local res = game.CTime()
	res:set(unpack(time_values))
	return res
end
-- упаковать время в виде объекта CTime в строку значений, разделённых запятой
function pack_time_to_string(t)
	ASSERT(t, "pack_time_to_string: t is a nil reference")
	return table.concat({t:get()}, ',')
end
-- читает строку вида "s1,s2,s3" и парсит на строковые значения, разделённые запятой, в таблицу вида {s1, s2, s3}
function get_names(section, param, ini_file)
	ASSERT(section, "get_names: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_names: section '"..section.."' doesn't exist")
	local s = ini:r_string(section, param)
	return split_comma_separated_list(s)
end
-- читает строку вида "s1,s2,s3" и парсит на численные значения, разделённые запятой, в таблицу вида {n1, n2, n3}
function get_numbers(section, param, ini_file)
	local t = {}
	for i,sv in ipairs(get_names(section, param, ini_file)) do
		local v = tonumber(sv)
		ASSERT(v, "get_numbers: can not convert to number item ["..i.."]: "..tostring(sv))
		table.insert(t, v)
	end
	return t
end

function get_section_keys( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
    local _, key, v = ini:r_line( section, i )
      table.insert( t, key )
  end
  return t
end

function get_section_keys_and_values( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
  local _, key, v = ini:r_line( section, i, "", "" )
    t[ key ] = v
  end
  return t
end

function get_vector(section, param, def_val, ini_file)
	ASSERT(section, "get_vector: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return vector():set(tonumber(pos[1]), tonumber(pos[2]), tonumber(pos[3]))
	else 
		if def_val then
			return def_val
		else
			return vector():set(0,0,0)
		end
	end
end

-- значение по умолчанию должно задаваться таблицей {num1, num2}
function get_vector2(section, param, def_val, ini_file)
	ASSERT(section, "get_vector2: section not defined, param=%s", param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector2: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return tonumber(pos[1]), tonumber(pos[2])
	else
		return def_val and unpack(def_val)
	end
end

-- Берём параметры иконки из конфигов
function get_inventory_icon_rect(sect)
	return 50*sys_ini:r_u32(sect, "inv_grid_x"), 50*sys_ini:r_u32(sect, "inv_grid_y"), 50*sys_ini:r_u32(sect, "inv_grid_width"), 50*sys_ini:r_u32(sect, "inv_grid_height")
end
-- получить номер локации по номеру глобального вертекса
function location_id_by_gvid( gvid )
  if gvid and game_graph():valid_vertex_id( gvid ) then
    return game_graph():vertex( gvid ):level_id()
  end
end
-- получить номер локации для клиентского объекта
function object_location_id( obj )
  local gvid = obj.game_vertex_id
    and obj:game_vertex_id() or obj.m_game_vertex_id
  return location_id_by_gvid( gvid )
end
function object_level_name(obj)
  local lid = object_location_id( obj )
  if lid then
    return level_system_name_by_lid( lid )
  end
end
function level_system_name_by_lid( lid )
  if lid then
    return alife():level_name( lid )
  end
end
function level_name_by_level_system_name(lname)
	return game.translate_string(lname)
	--string.lower(lname))
end
--системное имя уровня
function level_system_name_by_gvid(gvid)
	return level_system_name_by_lid(location_id_by_gvid(gvid))
end
--Внятное имя уровня (не системное, а то, которое изображается на карте):
function level_name_by_gvid(gvid)
	return level_name_by_level_system_name(level_system_name_by_gvid(gvid))
end

function clear_log()
	get_console():execute("clear_log")	
end
function flush_log()
	get_console():execute("flush")
end
-- просто удобная обёртка для log1
function log2(fmt,...)
	ASSERT(fmt, "log2: has no format string")
	log1(fmt:format(...))
end
-- делает дополнительную работу по конвертации некоторых параметров, которые не воспринимаются родной функцией string.format
-- невоспринимаемые параметры (nil, boolean, userdata) должны в строке формата стоять как %s (потому, что будут заменены на строки)
-- работает медленней, чем log2
function log3(fmt,...)
	ASSERT(fmt, "log3: has no format string")
	local args = {...}
	for i=1,#args do -- Цикл ipairs здесь не работает, поскольку останавливается на первом _значении_ nil, что исключает возможность иметь nil-аргументы
		local arg = args[i]
		local typ = type(arg)
		if typ == "boolean" then
			args[i] = tostring(arg)
		elseif typ == "userdata" then
			args[i] = "userdata"
		elseif typ == "table" then
			args[i] = "table"
		elseif typ == "nil" then
			args[i] = "nil"
		end
	end
	local res,msg = pcall(log2, fmt, unpack(args))
	if not res then
		log1("log3 failed:\n"..msg)
	end
end

function get_item_weight_by_section(section)
	local res = get_float(section, "inv_weight")
	ASSERT(res, "get_item_weight_by_section: there is no 'inv_weight' parameters in section '"..section.."'")
	return res
end

function get_ammo_weight_by_section(section, count)
	local box_weight = get_item_weight_by_section(section)
	local box_size = get_int(section, "box_size", 0)
	ASSERT(box_size > 0, "get_ammo_weight_by_section: 'box_size' parameters in section '"..section.."' is zero or missed")
	return box_weight * count / box_size
end

function print_vector(name, v)
	log1(string.format("%s: %9.3f, %9.3f, %9.3f", name, v.x, v.y, v.z))
end
function print_matrix(name, m)
	log1(name..":")
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.i.x, m.i.y, m.i.z, m._14_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.j.x, m.j.y, m.j.z, m._24_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.k.x, m.k.y, m.k.z, m._34_))
	log1(string.format("[%9.3f, %9.3f, %9.3f, %9.3f]", m.c.x, m.c.y, m.c.z, m._44_))
end
function time2string(time, fmt, order)
	ASSERT(time, "[_g.time2string] 'time' is a nil reference")
	local a,b = time:get_value()
	if not fmt then
		return time:timeToString(game.CTime.TimeToMilisecs).." "..time:dateToString(game.CTime.DateToDay)..string.format(" [%04x %04x]", a,b)
	else
		local y,m,d,h,min,s,ms = time:get()
		local args = {y=y,m=m,d=d,h=h,min=min,s=s,ms=ms,a=a,b=b}
		if order then
			args = {args[order[1]], args[order[2]], args[order[3]], args[order[4]], args[order[5]], args[order[6]], args[order[7]], args[order[8]], args[order[9]]}
		end
		return fmt:format(unpack(args))
	end
end
function print_time(title, time)
	log1(title..": "..time2string(time))
end
local fs = getFS()
function check_module(module_name)
	local script_name = fs:update_path("$game_scripts$", module_name..".script")
	local res, err = loadfile(script_name)
	if res then
		log1("module: '"..script_name.."' is correct")
	else
		log1("module: "..script_name.."\nerror: "..err)
	end
	return res, err
end

function seconds2ctime(time_sec)
	local s,ms = math.modf(time_sec)
	local t = game.CTime()
	t:setHMSms(0,0,s,ms*1000)
	return t
end

-- надёжнее, чем device().aspect_ratio, поскольку не зависит от инициализированности рендера
-- однако медленная. Не рекомендуется использовать часто
function get_aspect_ratio()
	local s =  get_console():get_string("vid_mode")
	local sw,sh = string.match(s, "(%d+)x(%d+)")
	return tonumber(sh)/tonumber(sw)
end
----------------------------------------------------------------------
-- Работа с актором
----------------------------------------------------------------------
-- константы для функций get_actor_flags и set_actor_flags
actor_flags = {
	invincible     =  1,
	invisible      =  2, -- useless
	always_run     =  4,
	unlimited_ammo =  8,
	run_backward   = 16,
	autopickup     = 32,
	psp            = 64, -- вид от третьего лица
}
function set_actor_invincible(invincible)
	local flags = get_actor_flags()
	local mask = actor_flags.invincible
	set_actor_flags(invincible and bit_or(flags, mask) or bit_and(flags, bit_not(mask)))
end

-- получение некоторых значений с плавающей запятой
-- параметры бега
function get_walk_accel()         return db.actor:get_actor_float(1440) end
function get_jump_speed()         return db.actor:get_actor_float(1444) end
function get_run_factor()         return db.actor:get_actor_float(1448) end
function get_run_back_factor()    return db.actor:get_actor_float(1452) end
function get_walk_back_factor()   return db.actor:get_actor_float(1456) end
function get_crouch_factor()      return db.actor:get_actor_float(1460) end
function get_climb_factor()       return db.actor:get_actor_float(1464) end
function get_sprint_factor()      return db.actor:get_actor_float(1468) end
function get_walk_strafe_factor() return db.actor:get_actor_float(1472) end
function get_run_strafe_factor()  return db.actor:get_actor_float(1476) end
-- параметры стрельбы
function get_disp_base()          return db.actor:get_actor_float(1484) end -- в радианах
function get_disp_aim()           return db.actor:get_actor_float(1488) end -- в радианах
function get_disp_vel_factor()    return db.actor:get_actor_float(1492) end
function get_disp_accel_factor()  return db.actor:get_actor_float(1496) end
function get_disp_crouch_factor() return db.actor:get_actor_float(1500) end
function get_disp_crouch_no_accel_factor()  return db.actor:get_actor_float(1504) end
-- получение некоторых целых и логических значений
-- режим прицеливания
function zoom_mode() return bit_and(db.actor:get_actor_int(nil, 1480), 1) end -- возвращает 0/1

-- установка некоторых значений
-- параметры бега
function set_sprint_factor(v)      db.actor:set_actor_float(nil, v, 1468) end
function set_jump_speed(v)         db.actor:set_actor_float(nil, v, 1444) end
function set_walk_accel(v)         db.actor:set_actor_float(nil, v, 1440) end
function set_run_factor(v)         db.actor:set_actor_float(nil, v, 1448) end
function set_run_back_factor(v)    db.actor:set_actor_float(nil, v, 1452) end
function set_walk_back_factor(v)   db.actor:set_actor_float(nil, v, 1456) end
function set_crouch_factor(v)      db.actor:set_actor_float(nil, v, 1460) end
function set_climb_factor(v)       db.actor:set_actor_float(nil, v, 1464) end
function set_walk_strafe_factor(v) db.actor:set_actor_float(nil, v, 1472) end
function set_run_strafe_factor(v)  db.actor:set_actor_float(nil, v, 1476) end
-- параметры стрельбы
function set_disp_base(v)          db.actor:set_actor_float(nil, v, 1484) end -- в радианах
function set_disp_aim( v ) db.actor:set_actor_float( nil, v, 1488 ) end

function set_jump_power( v )
  db.actor:set_actor_condition_float( nil, v, 276 )
end
function set_jump_weight_power( v )
  db.actor:set_actor_condition_float( nil, v, 288 )
end
function set_overweight_jump_k( v )
  db.actor:set_actor_condition_float( nil, v, 300 )
end

function set_walk_power( v )
  db.actor:set_actor_condition_float( nil, v, 284 )
end
function set_walk_weight_power( v )
  db.actor:set_actor_condition_float( nil, v, 292 )
end
function set_overweight_walk_k( v )
  db.actor:set_actor_condition_float( nil, v, 296 )
end

function get_actor_power_max()
  return db.actor:get_actor_condition_float( 104 )
end
function set_actor_power_max( v )
  return db.actor:set_actor_condition_float( nil, v, 104 )
end

local body_states = { -- флажки состояния тела актора
[1]		= "fwd",
[2]		= "back",
[4]		= "l_strafe",
[8]		= "r_strafe",
[16]	= "crouch",
[32]	= "accel",
[64]	= "turn",
[128]	= "jump",
[256]	= "fall",
[512]	= "landing",
[1024]	= "landing2",
[2048]	= "climb",
[4096]	= "sprint",
[8192]	= "l_lookout",
[16384]	= "r_lookout"
}
-- получения флагов состояния тела актора
function actor_body_state()
	local body_state = body_states[db.actor:get_actor_int(nil, 1432)]
	if body_state ~= nil then
		return body_state
	else
		return ""
	end
end
-- установка флагов состояния тела актора
function set_actor_body_state(flags_to_set, value)
	local current_flags = db.actor:get_actor_int(nil, 1432)
	local new_flags = value and bit_or(current_flags, flags_to_set) or bit_and(current_flags, bit_not(flags_to_set))
	db.actor:set_actor_int(1432, new_flags)
end
local anomaly_invisibility_flag = tonumber("80000000", 16)
-- установка невидимости сталкера со стороны аномалий
function set_anomaly_invisibility(npc, vis)
	local fl = npc:get_actor_relation_flags()
	fl:set(anomaly_invisibility_flag, vis)
	npc:set_actor_relation_flags(fl)
end
-- получение статуса невидимости сталкера со стороны аномалий
function get_anomaly_invisibility(npc)
	local fl = npc:get_actor_relation_flags()
	return fl:test(anomaly_invisibility_flag)
end
-- поверхностное (простое) клонирование таблицы: 
--  создаётся копия таблицы и копии всех элементов без их клонирования,
--  т.е. для ссылочных типов обе таблицы будут содержать ссылки на одни и те же данные
--  метатаблицы не копируются
function table.clone_simple(tbl)
	local res = {}
	for k,v in pairs(tbl) do
		res[k] = v
	end
	return res
end

function get_day_time_sec(t)
	local y,m,d,h,min,s,ms = t:get()
	return h * 3600.0 + min * 60.0 + s + ms * 1e-3
end

-- получить текушее игровое время от начала суток, измеренное в часах (значение в пределах [0, 24) )
function get_game_day_time_h()
	local gt = game.get_game_time()
	local y,m,d,h,min,sec,ms = gt:get()
	return math.fmod(h + min/60.0 + (sec + 0.001*ms)/3600.0, 24.0)
end

function relation_registry.get_goodwill(who_id, to_whom_id)
	return GetGoodwill(who_id, to_whom_id)
end

function relation_registry.set_goodwill(who_id, to_whom_id, goodwill)
	ASSERT(db.actor, "relation_registry.set_goodwill: cannot call function")
	return db.actor:set_goodwill_ex(who_id, to_whom_id, goodwill)
end

function relation_registry.change_goodwill(who_id, to_whom_id, goodwill_change)
	ASSERT(db.actor, "relation_registry.change_goodwill: cannot call function")
	return db.actor:change_goodwill_ex(who_id, to_whom_id, goodwill_change)
end

rq_target = {
	rqtNone,
	rqtObject   = 1,
	rqtStatic   = 2,
	rqtShape    = 4,
	rqtObstacle = 8,
	rqtBoth     = 3, -- rqtObject + rqtStatic
	rqtDyn      = 13, -- rqtObject + rqtShape + rqtObstacle
}

ray_pick = {}
function ray_pick.init(pos_from, dir, range, flags, ignore_obj)
	ray_pick.set_pos(pos_from)
	ray_pick.set_dir(dir)
	ray_pick.set_range(range)
	ray_pick.set_flags(flags)
	ray_pick.set_object_to_ignore(ignore_obj)
end

function ray_pick.set_pos(pos)
	--print_vector("pos", pos)
	db.actor:set_vector_global_arg_2(pos)
end
function ray_pick.set_dir(dir)
	--print_vector("dir", dir)
	db.actor:set_vector_global_arg_1(dir)
end
function ray_pick.set_range(range)
	--log2("range: %7.2f", range)
	set_float_args_12(range, 0)
end
function ray_pick.set_flags(flags)
	--log2("flags: %x", flags)
	set_int_arg1(flags)
end
function ray_pick.set_object_to_ignore(obj)
	db.actor:set_object_arg_1(obj)
end
function ray_pick.check()
	return level.perform_ray_pick_query()
end

function ray_pick.get_dist()
	return level.get_ray_pick_dist()	
end

function ray_pick.get_obj()
	return level.get_ray_pick_obj()
end
function ray_pick.get_element()
	return level.get_ray_pick_element()
end

function is_16_9_mode()
	local dev = device()
	return dev.width / dev.height > 1.34
end
-- вернуть значение v, ограниченное сверху и снизу значениями l и u
function math.clamp(v, l, u)
	if v < l then 
		return l
	elseif v > u then 
		return u
	end
	return v
end
-- округление к ближайшему
function math.round(v)
	return math.floor(v + 0.5)
end

function math.lerp(x1, x2, y1, y2, x)
	return (x - x1) * (y2 - y1) / (x2 - x1)
end

function math.similar(a1, a2, tol)
	return math.abs(a1 - a2) <= tol
end
-- смещения полей в структуре SHit, т.е. параметры хита
hit_offset = {
  Time              = 0,  -- 4, insigned int
  PACKET_TYPE       = 4,  -- 2, insigned short
  DestID            = 6,  -- 2, insigned short
  power             = 8,  -- 4, float 
  dir_x             = 12, -- 4, float
  dir_y             = 16, -- 4, float
  dir_z             = 20, -- 4, float
  who               = 24, -- 4, pointer
  whoID             = 28, -- 2, insigned short
  weaponID          = 30, -- 2, insigned short
  boneID            = 32, -- 2, insigned short
  -- 2 байта на выравнивание
  p_in_bone_space_x = 36, -- 4, float
  p_in_bone_space_y = 40, -- 4, float
  p_in_bone_space_z = 44, -- 4, float
  impulse           = 48, -- 4, float
  hit_type          = 52, -- 4, unsigned int (ALife::EHitType)
  ap                = 56, -- 4, float
  aim_bullet        = 60, -- 1, bool
  -- 3 байта на выравнивание
  BulletID          = 64, -- 2, unsigned int
  SenderID          = 66, -- 2, unsigned int
}

-- коды дополнительных колбеков
callback_ex = {
	["on_key_press"]                 = 123,
	["on_key_release"]               = 124,
	["on_key_hold"]                  = 125,
	["on_mouse_wheel"]               = 126,
	["on_mouse_move"]                = 127,

	["on_belt"]                      = 130,
	["on_ruck"]                      = 131,
	["on_slot"]                      = 132,
	["on_select_item"]               = 133,
	["on_create_cell_item"]          = 136,
	["on_after_save"]                = 140,
	
	["on_goodwill_change"]           = 145,
	["on_release_npc"]               = 146,

	["on_inv_box_put_item"]          = 151,
	["entity_alive_before_hit"]      = 152,
	["dbg_gg_distance_failed"]       = 153,
	["update_addons_visibility"]     = 154,
	["update_hud_addons_visibility"] = 155,
	["on_before_use_item"]           = 156,
	["on_hud_animation_end"]         = 157,

	["pda_contact"]                  = 180,
}
inventory_item_offsets = {
	["health_influence"]    = 220,
	["power_influence"]     = 224,
	["satiety_influence"]   = 228,
	["radiation_influence"] = 232,
	["power_max_influence"] = 236,
	["wound_heal"]          = 240,
	["alcohol_influence"]   = 688,
}

-- обнуление всех эффектов съедаемого предмета
-- изменённые значения в сейве не сохраняются
-- функция предназначена в основном для использования в событии предиспользования,
-- когда эффекты предмета ещё не применены и их можно изменить, что повлияет на собственно эффект от 
-- предмета на параметры здоровья, радиации и т.п.. При этом подразумевается,
-- что предмет после использования будет удалён, поэтому вопрос о сохранении этих свойств не стоит
-- если используется подход с eat_portions_num > 1 (обычно задаётся "бесконечное" значение, типа 10000),
-- то эту функцию либо использовать нельзя, либо надо таким же образом восстанавливать свойства предмета
-- в событии использования (стандартный колбек callback.use, который в сущности является колбеком на 
-- "послеиспользование", когда эффекты предмета уже применены)
function zero_all_item_effects(item)
	ASSERT(item:is_eatable_item(), "")
	for param, offset in pairs(inventory_item_offsets) do
		-- параметр влияния алкоголя годится только для объекта-бутылки
		if param ~= "alcohol_influence" or item:is_bottle_item() then
			item:set_inventory_item_float(nil, 0.0, offset)
		end
	end
end
-- набор констант для использования в колбеках на использование и предиспользование инвентарных предметов
-- константы сигналят, что надо делать с предметом после его обработки: 
--     удалить, создать его дубликат, не делать ничего
-- это надо для упорядочения работы с инвентарными предметами при разных подходах использован*ия eat_portions_num
-- если eat_portions_num = 1 или -1, то предмет одноразовый. В этом случае, если мы хотим "сохранить" предмет
-- в инвентаре, то возвращаем post_use_action.create_new_item, в противном случае возвращаем post_use_action.do_nothing
-- если же используем подход с eat_portions_num = "бесконечность", то как раз при использовании сигналим
-- вызвавшему коду, что предмет надо удалить, т.е. возвращаем post_use_action.delete_item, в противном случае просто оставляем
-- предмет в покое (возвращаем post_use_action.do_nothing).
-- P.S.: Этот подход архитектурно не навязан. Используется по желанию. Константы вынесены сюда на тот случай,
-- если кто-то захочет использовать такую же организацию кода
post_use_action = {
	do_nothing = 0,
	delete_item = 1,
	create_new_item = 2,
}

-- установка направления взгляда актора в заданную точку
function actor_look_at_point(target_point)
	ASSERT(target_point, "actor_look_at_point: target point vector is a nil reference!")
	local look_dir = vector():sub(target_point, device().cam_pos)
	local h = look_dir:getH()
	local p = look_dir:getP()
	db.actor:set_camera_direction(vector():set(-h,-p,0))
end
local con = get_console()
function cmd(scmd, ...)
	ASSERT(scmd, "[cmd] scmd is a nil reference")
	local args = {...}
	if #args ~= 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	con:execute(scmd)
end
function get_con_float(param)
	return con:get_float(param)
end
function get_con_string(param)
	return con:get_string(param)
end

-- Управление торгуемостью и группировкой предметов в инвентаре
ii_flags = {
	drop_manual         = 1,
	can_take            = 2,
	can_trade           = 4,
	belt                = 8,
	ruck                = 16,
	ruck_default        = 32,
	using_condition     = 64,
	allow_sprint        = 128,
	useful_for_npc      = 256,
	in_interpolation    = 512,
	in_interpolate      = 1024,
	is_quest_item       = 2048,
	-- extra flags added in x-ray extensions
	always_tradable     = 4096,
	always_untradable   = 8192,
	ungroupable         = 16384,
	manual_highlighting = 32768,
}

ext_ii_flags = {
	actor_can_take         = 1,
}

function set_ext_ii_flags(item, mask, value)
	item:set_inventory_item_int16(134, flags16():assign(item:get_inventory_item_int16(nil, 134)):set(mask, value):get())
end

function set_item_forbidden_to_actor(item)
	set_ext_ii_flags(item, ext_ii_flags.actor_can_take, true)
end

function mark_grenade_non_pickable(id, item)
	set_item_forbidden_to_actor(item)
	log1("!!DEBUG_GRENKA_NONPICKABLE "..tostring(id))
	--level.client_spawn_manager():remove(id, 0)
end

-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_flags(item, mask, value)
	item:set_inventory_item_int16(132, flags16():assign(item:get_inventory_item_int16(nil, 132)):set(mask, value):get())
end
-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_custom_color_ids(item, col_idx)
	ASSERT(col_idx >=0 and col_idx <=15, "[set_ii_custom_color_ids] col_idx must be in the range [0-15]")
	local fl = bit_or(bit_and(item:get_inventory_item_int16(nil, 134), 65520), col_idx)
	item:set_inventory_item_int16(134, fl)
end
-- сделать предмет безусловно негруппируемым в окнах инвентаря
function set_item_ungroupable(item)
	set_ii_flags(item, ii_flags.ungroupable, true)
end
-- включить движковую группировку для предмета
function set_item_default_grouping(item)
	set_ii_flags(item, ii_flags.ungroupable, false)
end
-- сделать предмет безусловно продаваемым
function set_item_always_tradable(item)
	set_ii_flags(item, ii_flags.always_tradable, true)
end
-- сделать предмет безусловно непродаваемым, будет показан красным. Для избежания глюков надо также
-- выключать группируемость для этого предмета
function set_item_always_untradable(item)
	set_ii_flags(item, ii_flags.always_tradable, false)
	set_ii_flags(item, ii_flags.always_untradable, true)
end
-- включить движковую торгуемость для предмета
function set_item_tradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, true)
end
-- выключить движковую торгуемость для предмета
function set_item_untradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, false)
end
-- убрать принудительную тогумеость или неторгуемость и оставить только двидковый алгоритм
function set_item_default_tradability(item)
	set_ii_flags(item, ii_flags.always_tradable + ii_flags.always_untradable, false)
end
-- включить для предмета явную раскраску кастомным цветом
function set_item_always_highlighted(item)
	set_ii_flags(item, ii_flags.manual_highlighting, true)
end
-- использовать только движковую раскраску
function set_item_default_highlighting(item)
	set_ii_flags(item, ii_flags.manual_highlighting, false)
end

-- сбросить торгуемость для всех предметов в инвентаре актора
function reset_actor_items_tradability()
	for i = 0, db.actor:object_count() - 1 do
		set_item_default_tradability(db.actor:object(i)) 
	end
end
--отладочные обёртки для глобальных функций level.enable_input и level.disable_input
local enable_input_orig = level.enable_input
level.enable_input = function()
	--log1("level.enable_input")
	--log1(debug.traceback())
	enable_input_orig()
end
local disable_input_orig = level.disable_input
level.disable_input = function()
	--log1("level.disable_input")
	--log1(debug.traceback())
	disable_input_orig()
end
get_game_id = ogse_unist.get_game_id


-- http://www.amk-team.ru/forum/index.php?showtopic=6185&p=945289
weapon_states = {
  idle      = 0,
  fire      = 1,
  fire2     = 2,
  reload    = 3,
  showing   = 4,
  hiding    = 5,
  hidden    = 6,
  misfire   = 7,
  mag_empty = 8,
  switch    = 9
}


-- показывает, что оружие находится в соостоянии поворота для приближенного
-- прицеливания. См. xr_3da\xrGame\Weapon.h:253
-- bool IsRotatingToZoom() const { return (m_fZoomRotationFactor < 1.f); }
function wpn_IsRotatingToZoom( wpn )
  return wpn:get_wpn_float( 1016 ) < 1
end


-- af_night_star:get_go_float (byte)
-- af_night_star:set_go_float (nil, value, byte)
af_offset = {
  [ "health_restore_speed"    ] = 556,
  [ "radiation_restore_speed" ] = 560,
  [ "satiety_restore_speed"   ] = 564,
  [ "power_restore_speed"     ] = 568,
  [ "bleeding_restore_speed"  ] = 572,
  [ "burn_immunity"           ] = 580,
  [ "shock_immunity"          ] = 584,
  [ "strike_immunity"         ] = 588,
  [ "wound_immunity"          ] = 592,
  [ "radiation_immunity"      ] = 596,
  [ "telepatic_immunity"      ] = 600,
  [ "chemical_burn_immunity"  ] = 604,
  [ "explosion_immunity"      ] = 608,
  [ "fire_wound_immunity"     ] = 612,
}
local af_zero = {
  [ "health_restore_speed"    ] = 0,
  [ "radiation_restore_speed" ] = 0,
  [ "satiety_restore_speed"   ] = 0,
  [ "power_restore_speed"     ] = 0,
  [ "bleeding_restore_speed"  ] = 0,
  [ "burn_immunity"           ] = 1,
  [ "shock_immunity"          ] = 1,
  [ "strike_immunity"         ] = 1,
  [ "wound_immunity"          ] = 1,
  [ "radiation_immunity"      ] = 1,
  [ "telepatic_immunity"      ] = 1,
  [ "chemical_burn_immunity"  ] = 1,
  [ "explosion_immunity"      ] = 1,
  [ "fire_wound_immunity"     ] = 1,
}


function zero_all_af_effects( af )
  for k, offset in pairs( af_offset ) do
    af:set_go_float( nil, af_zero[ k ], offset )
  end
end


local outfit_protection_offset = {
  [ "burn_protection"          ] = 432,
  [ "shock_protection"         ] = 436,
  [ "strike_protection"        ] = 440,
  [ "wound_protection"         ] = 444,
  [ "radiation_protection"     ] = 448,
  [ "telepatic_protection"     ] = 452,
  [ "chemical_burn_protection" ] = 456,
  [ "explosion_protection"     ] = 460,
  [ "fire_wound_protection"    ] = 464
}

function set_outfit_protection( obj, k, v )
  obj:set_go_float( nil, v, outfit_protection_offset[ k ] )
end

function zero_outfit_protection( obj )
  for k, _ in pairs( outfit_protection_offset ) do
    set_outfit_protection( obj, k, 0 )
  end
end


function set_outfit_power_loss( obj, val )
  obj:set_go_float( nil, val, 480 )
end


function set_outfit_additional_inventory_weight( obj, val )
  obj:set_go_float( nil, val, 500 )
end

function set_outfit_additional_inventory_weight2( obj, val )
  obj:set_go_float( nil, val, 504 )
end


function set_inv_item_cost( obj, cost )
  obj:set_inventory_item_int( 160, cost )
end


function get_inv_item_slot( obj )
  return obj:get_inventory_item_int( nil, 156 )
end

function set_inv_item_slot( obj, slot )
  obj:set_inventory_item_int( 156, slot )
end


-- http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1002890
function normal_triangle( element ) -- нормаль треугольника
  local n = vector()
  local a = level.get_tri_vertex1( element )
  local b = level.get_tri_vertex2( element )
  local c = level.get_tri_vertex3( element )
  n.x = ( ( b.z - a.z ) * ( c.y - a.y ) ) - ( ( b.y - a.y ) * ( c.z -a.z ) )
  n.y = ( ( b.x - a.x ) * ( c.z - a.z ) ) - ( ( b.z - a.z ) * ( c.x -a.x ) )
  n.z = ( ( b.y - a.y ) * ( c.x - a.x ) ) - ( ( b.x - a.x ) * ( c.y -a.y ) )
  return n:normalize()
end


--[=[
От Malandrinus отсюда: http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1006978

Проиграть произвольную анимацию худовой модели:

db.actor:set_hud_animation_channel(2)
db.actor:set_use_hud_animation_callback(true)
db.actor:set_hud_animation_callback_param(12345)
wpn:play_hud_animation("reload", true)

Колбек на окончание анимации вызывается для актора, код колбека 157.
В колбек передаётся один целый аргумент - то число, которое было установлено
вызовом db.actor:set_hud_animation_callback_param(<целое число>).
Так можно в колбеке различать, какая именно анимация закончилась.

http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=701404
Вот пример получения/записи значений для объекта актора.

db.actor:set_actor_shared_str("test", 1392)
local sss = {
    1392,
    1396,
    1400,
    1404,
    1408,
    1412,
}
for _, s1 in ipairs(sss) do
    set_int_arg0(s1)
    local s = db.actor:get_actor_shared_str()
    log1(""..s1.." "..s)
end
--]=]


-- возвращает имя кости по ее индексу
-- http://xray-engine.org/index.php?title=X-Ray_extensions
function get_bone_name_by_id( obj, bone_id )
  set_int_arg0( bone_id )
  return obj:get_bone_name()
end

-- возвращает level_vertex_id по позиции на уровне
function level.vertex_id_by_pos( position )
  db.actor:set_vector_global_arg_1( position )
  return level.vertex_id( position )
end

-- запускает эффектор шатания камеры с заданными параметрами
function level.add_cam_effector3( total_time, amplitude, period_number, power )
  level.set_ce_time( total_time )
  level.set_ce_amplitude( amplitude )
  level.set_ce_period_number( period_number )
  level.set_ce_power( power )
  level.add_ce()
end


-- Некоторые недостающие DIK_keys
-- взято из аддона naxac
DIK_keys.MOUSE_1 = 337
DIK_keys.MOUSE_2 = 338
DIK_keys.MOUSE_3 = 339
DIK_keys.MOUSE_4 = 340
DIK_keys.MOUSE_5 = 341

key_bindings.kACTIVE_JOBS = 53
key_bindings.kMAP         = 54
key_bindings.kCONTACTS    = 55
key_bindings.kUSE_MEDKIT  = 74
