-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_first_update", fun = this.on_actor_first_update })
  sm:subscribe({ signal = "on_npc_death", fun = this.on_death     })
  -- sm:subscribe({ signal = "on_npc_first_update", fun = this.on_first_update })
  sm:subscribe({ signal = "on_npc_spawn", fun = this.on_npc_spawn })
end


function on_actor_first_update()
  ogse_signals.get_mgr():subscribe({ signal = "on_take", fun = this.on_take })
end


local npc_rnd_keys = {
  "outfit_rnd", "outfit_cond_rnd", "weapon_cond_rnd",
}

function on_npc_spawn( npc, binder )
  local sobj = alife():object( npc:id() )
  if sobj then
    local pk = get_netpk( sobj, 1 )
    if pk:isOk() then
      local data = pk:get()
      local cd   = data.custom_data:getTable()
      local cfg  = cd[ script_name() ]
      if cfg then
        binder[ script_name() ] = {}
        for _, k in ipairs( npc_rnd_keys ) do
          binder[ script_name() ][ k ] = tonumber( cfg[ k ] )
        end
      else
        cfg = {}
        for _, k in ipairs( npc_rnd_keys ) do
          cfg[ k ] = math.random()
        end
        binder[ script_name() ] = cfg
        cd[ script_name() ]     = cfg
        data.custom_data:set( cd )
        pk:set( data )
      end
    end
  end
end


function on_first_update( obj )
  if not obj:alive() then
    -- спавн друпа если не был произведен
    drop_manager( obj:id() ):create_release_item()
  end
end


function on_death( obj, who )
  drop_manager( obj:id(), who:id() ):create_release_item()
end


local total_debug = false
function write_log( str, ... )
  if total_debug then
    log2( str, ... )
  end
end


local ammo_deferred_release = {}
--' Ключем является группировка персонажа. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

--' Множители и минимаксы для выпадения вещей в зависимости от уровня
local count_by_level = {}

--' Предметы, которые нельзя удалять (квестовые например)
local always_keep_item = {}

local always_offs_items = {
        ["device_torch"]=true,
        ["device_pda"]=true,
        ["hand_radio"]=true,
        ["binocular_a"]=true,
        ["wpn_knife"]=true,
        ["wpn_binoc"]=true,
        ["bolt"]=true,
        ["grenade_f1"]=true,
        ["grenade_rgd5"]=true,
        ["ammo_9x19_pbp"]=true,
        ["ammo_9x39_pab9"]=true,
        ["ammo_9x39_ap"]=true,
        ["ammo_9x18_fmj"]=true,
        ["ammo_9x18_pmm"]=true,
        ["ammo_11.43x23_fmj"]=true,
        ["ammo_5.45x39_fmj"]=true,
        ["ammo_5.45x39_ap"]=true,
        ["ammo_9x19_fmj"]=true,
        ["ammo_5.56x45_ss190"]=true,
        ["ammo_5.56x45_ap"]=true,
        ["ammo_12x70_buck"]=true,
        ["ammo_12x76_zhekan"]=true,
        ["ammo_12x76_dart"]=true,
        ["ammo_7.62x39_fmj"]=true,
        ["ammo_7.62x39_ap"]=true,
        ["ammo_12.7x108"]=true,
        ["ammo_og-7b"]=true,
        ["ammo_m209"]=true,
        ["ammo_vog-25p"]=true,
        ["ammo_igl_new"]=true,
        ["bandage"]=true,
        ["medkit"]=true,
        ["medkit_army"]=true,
        ["medkit_scientic"]=true,
        ["antirad"]=true,
        ["bread"]=true,
        ["kolbasa"]=true,
        ["conserva"]=true,
        ["vodka"]=true,
        ["sigaret"]=true,
        ["player"]=true,
        ["energy_drink"]=true,
        ["gl_test_shell"] = true,
        ["gl_test_shell_ammo_vog-25"] = true,
        ["gl_test_shell_ammo_vog-25p"] = true,
        ["gl_test_shell_ammo_m209"] = true,
        ["gl_test_shell_ammo_m208a"] = true,
        ["gl_fake_missile"] = true,
        ["gl_fake_missile_ammo_vog-25"] = true,
        ["gl_fake_missile_ammo_vog-25p"] = true,
        ["gl_fake_missile_ammo_m209"] = true,
        ["gl_fake_missile_ammo_m208a"] = true,
        ["fake_grenades_base"] = true,
        ["grenade_f1_fake"] = true,
        ["grenade_rgd5_fake"] = true,
        ["grenade_gd-05_fake"] = true,
        ["grenade_flash_fake"] = true,
        ["grenade_f1_test"] = true,
        ["grenade_rgd5_test"] = true,
        ["grenade_gd-05_test"] = true,
        ["grenade_flash_test"] = true,
}

-- эти вещи остаются с указанной вероятностью
local always_offs_items_prob = {
        ["guitar_a"]=0.01,
        ["balalaika_a"]=0.01,
        ["harmonica_a"]=0.01,
}

-- Таблица выдачи инфопорций по части имени погибшего непися.
local names_info = {
        ["snip_esc1"] = "snip_esc1_dead",
        ["snip_esc2"] = "snip_esc2_dead",
        ["snip_esc3"] = "snip_esc3_dead",
        ["snip_esc4"] = "snip_esc4_dead",
        ["snip_esc5"] = "snip_esc5_dead",
        ["snip_esc6"] = "snip_esc6_dead",
        ["snip_esc7"] = "snip_esc7_dead",
        ["snip_esc8"] = "snip_esc8_dead",
        ["snip_esc9"] = "snip_esc9_dead",
        ["snip_esc10"] = "snip_esc10_dead",
        ["snip_esc11"] = "snip_esc11_dead",
        ["snip_esc12"] = "snip_esc12_dead",
        ["naem_zahar1"] = "naem_zahar1_dead",
        ["naem_zahar2"] = "naem_zahar2_dead",
        ["naem_zahar3"] = "naem_zahar3_dead",
        ["naem_zahar4"] = "naem_zahar4_dead",
        ["naem_zahar5"] = "naem_zahar5_dead",
        ["naem_zahar6"] = "naem_zahar6_dead",
        ["ecolog_wound_bunker"] = "ucen_talk_est",
        ["mitya"] = "mitya_dead",
        ["grab_stal1"] = "grab_stal1_dead",
        ["grab_stal2"] = "grab_stal2_dead",
        ["grab_stal3"] = "grab_stal3_dead",
        ["grab_stal4"] = "grab_stal4_dead",
        ["grab_stal5"] = "grab_stal5_dead"
}

-- Таблица для проверки в лоб. Порядок не имеет значения.
local visuals = {
        ["stalker_bandit"] = "bandit_outfit",
        ["stalker_bandit_4"] = "bandit_outfit_red",
        ["stalker_bandit_2"] = "bandit_outfit_red",
        ["stalker_bandit_5"] = "bandit_outfit_blue",
        ["stalker_bandit_9"] = "bandit_outfit_blue",
        ["stalker_bandit_1"] = "bandit_outfit_red1",
        ["stalker_bandit_drunk"] = "outfit_bandit_m1",
        ["stalker_bandit_8"] = "bandit_gaz_outfit_m1",
        ["stalker_bandit_veteran"] = "bandit_veteran_outfit",
        ["stalker_bandit_borov"] = "bandit_master_outfit",
        ["stalker_bandit_master"] = "bandit_master_outfit",
        ["stalker_bandit_exoskeleton"] = "exo_bandit_outfit",
        ["stalker_do_antigas"] = "dolg_gaz_outfit_m1",
        ["stalker_do_komandir"] = "outfit_dolg_m1",
        ["stalker_do_nauchniy"] = "dolg_scientific_outfit",
        ["stalker_do_exoskeleton"] = "dolg_black_exoskeleton",
        ["stalker_nebo_balon_1"] = "nebo_heavy_outfit",
        ["stalker_nebo_rukzak"] = "nebo_light_outfit",
        ["stalker_nebo_nauchniy"] = "nebo_scientific_outfit",
        ["stalker_nebo_exoskeleton"] = "nebo_exo_outfit",               
        ["stalker_ecolog"] = "ecolog_outfit",
        ["nauchniy_1"] = "ecolog_outfit",
        ["protect_suit2"] = "ecolog_outfit",
        ["stalker_ecolog_military"] = "protection_outfit",
        ["stalker_chemical"] = "protection_outfit",
        ["nauchniy_0"] = "protection_outfit",
        ["protect_suit1"] = "protection_outfit",
        ["izgoy"] = "bandit_veteran_outfit",
        ["stalker_ki_head_1"] = "outfit_killer_m1",
        ["stalker_ki_antigas"] = "killer_gaz_outfit_m1",
        ["stalker_ki_nauchniy"] = "merc_scientific_outfit",
        ["stalker_ki_exoskeleton"] = "killer_blue_exoskeleton",
    ["stalker_fantom_exoskeleton"] = "killer_green_exoskeleton",
        ["stalker_militari_1"] = "military_outfit",
        ["stalker_militari_antigas_1"] = "military_outfit",
        ["stalker_military"] = "military_outfit",
        ["stalker_military_green"] = "military_outfit",
        ["stalker_militari_2"] = "militaryspec_outfit",
        ["stalker_militari_antigas_2"] = "militaryspec_outfit",
        ["stalker_commander"] = "militaryspec_outfit",
        ["stalker_military_black"] = "militaryspec_outfit",
        ["stalker_monolit"] = "monolit_outfit",
        ["stalker_mo_hood_9"] = "monolit_gaz_outfit_m1",
        ["stalker_mo_nauchniy"] = "monolit_scientific_outfit",
        ["stalker_mo_exo"] = "monolit_exoskeleton",
        ["stalker_mo_elite"] = "monolit_black_outfit",  
        ["stalker_hood"] = "stalker_outfit", 
        ["stalker_bar_security"] = "stalker_guard_outfit",
        ["stalker_neytral_hood_9"] = "neytral_gaz_outfit_m1",                   
        ["stalker_neytral_nauchnyu_exo"] = "exo_scientist_outfit",                      
        ["stalker_2_gas"] = "neytral_gaz_outfit_v1",
        ["stalker_3_gas"] = "neytral_gaz_outfit_v2",
        ["stalker_4_gas"] = "neytral_gaz_outfit_v3",
        ["stalker_2_mask"] = "stalker_outfit_v1",
        ["lisiy"] = "stalker_outfit_v1",
        ["stalker_2_mask"] = "stalker_outfit_v1",
        ["stalker_2_ochki"] = "stalker_outfit_v1",
        ["stalker_2_rozh1"] = "stalker_outfit_v1",
        ["stalker_2_usi"] = "stalker_outfit_v1",
        ["stalker_3_mask"] = "stalker_outfit_v2",
        ["hellcar" ] = "stalker_outfit_v2",
        ["stalker_3_mask"] = "stalker_outfit_v2",
        ["stalker_3_rozh2"] = "stalker_outfit_v2",
        ["stalker_3_usi"] = "stalker_outfit_v2",
        ["stalker_4_rozh3"] = "stalker_outfit_v3",
        ["serega"]  = "stalker_outfit_v3",
        ["stalker_4_ochki"] = "stalker_outfit_v3",
        ["stalker_prizrak"] = "outfit_stalker_m1",
        ["stalker_neytral_nauchniy"] = "scientific_outfit",
        ["stalker_scien"] = "scientific_outfit",
        ["stalker_neytral_exoskeleton"] = "exo_outfit",
        ["stalker_exoskeleton"] = "exo_outfit",
        ["green_stalker_1"] = "neytral_novice_outfit_m1",
        ["green_stalker_2"] = "novice_outfit",
        ["stalker_novice"] = "outfit_novice_m1",
        ["green_stalker_3"] = "novice_outfit_rain_1",
        ["green_stalker_4"] = "neytral_novice_outfit_cam",
        ["green_stalker_5"] = "novice_outfit_new_2",
        ["green_stalker_6"] = "novice_outfit_rain_2",
        ["green_stalker_7"] = "neytral_novice_outfit_cam_2",
        ["green_stalker_8"] = "neytral_novice_outfit_cam_3",
        ["green_stalker_9"] = "novice_outfit_new_1",
        ["green_stalker_10"] = "neytral_novice_outfit_cam_1",
        ["green_stalker_11"] = "neytral_novice_outfit_new",
        ["green_stalker_antigas"] = "neytral_novice_gaz_outfit_m1",
        ["soldier_mask"] = "outfit_soldier_m1", 
        ["soldier_obichniy"] = "outfit_soldier_m1", 
        ["stalker_soldier"] = "outfit_soldier_m1", 
        ["soldier_spetsnaz"] = "specops_outfit",
        ["stalker_specops"] = "specops_outfit",
        ["soldier_antigas"] = "outfit_specnaz_m1",
        ["stalker_zombie1"] = "bandit_outfit",
        ["stalker_zombie2"] = "dolg_outfit",
        ["zombie_fresh_1"] = "dolg_outfit",
        ["stalker_zombie3"] = "stalker_outfit",
        ["stalker_zombie6"] = "stalker_outfit",
        ["zombie_fresh_2"] = "stalker_outfit", 
        ["stalker_zombie4"] = "killer_outfit",
        ["stalker_zombie5"] = "stalker_guard_outfit",
        ["stalker_zombie7"] = "novice_outfit",
        ["stalker_zombie8"] = "neytral_novice_outfit_m1",
        ["stalker_zombie_specnaz"] = "specops_outfit",
        ["zombie_fresh_0"] = "svoboda_heavy_outfit",
        ["zombie_exoskeleton"] = "broken_exoskeleton",
    ["stalker_zp_exoskeleton"] = "voen_exo_outfit",
        ["stalker_sv_rukzak_1_1"] = "svoboda_light_outfit",
        ["stalker_sv_rukzak_3"] = "svoboda_light_outfit",
        ["stalker_svoboda_light"] = "svoboda_light_outfit",
        ["stalker_sv_rukzak_1"] = "svoboda_heavy_outfit",
        ["stalker_sv_rukzak_2"] = "svoboda_heavy_outfit",
        ["stalker_sv_rukzak_3_1"] = "svoboda_heavy_outfit",
        ["stalker_sv_cook"] = "svoboda_heavy_outfit",
        ["stalker_sv_max"] = "svoboda_heavy_outfit",
        ["stalker_svoboda_heavy"] = "svoboda_heavy_outfit",
        ["stalker_sv_hood_91"] = "svoboda_gaz_outfit_m1",
        ["stalker_sv_hood_9"] = "svoboda_heavy_gaz_outfit_m1",
        ["stalker_sv_nauchniy"] = "freedom_scientific_outfit",
        ["stalker_svs_exoskeleton"] = "outfit_lethalspeed_exo_m1",
        ["stalker_svns_exoskeleton"] = "outfit_lethalspeed_exo_m2",
        ["stalker_sv_exoskeleton"] = "svoboda_exoskeleton",
        ["stalker_sv_leader"] = "outfit_svoboda_m1"
}

-- Если ничего не нашло по прямому соответствию, то будет поиск по части названия
-- Порядок следования в таблице имеет значение!! Сортировать её нельзя!
-- Бессмысленно сначала искать по "neytral", а потом - по "stalker_neytral"!
-- Можно только наоборот.
-- Подтаблица npc_names даёт возможность указывать прямо имя непися и его индивидуальный броник
local sect_by_visual_part = {
        ["stalker_bandit"] = {
                sect = "bandit_outfit"
        },
        ["stalker_do"] = {
                sect = "dolg_outfit"
        },
        ["stalker_ki"] = {
                sect = "killer_outfit"
        },
        ["stalker_mo"] = {
                sect = "monolit_outfit"
        },
        ["neytral"] = {
                npc_names = {
                        ["esc_wolf"] = "neytral_gaz_outfit_m2",
                        ["esc_stalker_fanat"] = "neytral_gaz_outfit_m2",
                        ["esc_fox"] = "neytral_gaz_outfit_m2",
                        ["esc_provodnik"] = "neytral_gaz_outfit_m2",
                        ["gar_hellcar"] = "neytral_gaz_outfit_m2",
                        ["gar_seryi"] = "neytral_gaz_outfit_m2",
                        ["agr_krot"] = "neytral_gaz_outfit_m2"
                },
        },
        ["stalker_neytral_rukzak"] = {
                sect = "outfit_stalker_m2"
        },
        ["stalker_neytral"] = {
                sect = "stalker_outfit"
        },
        ["soldier_bandana"] = {
                sect = "outfit_soldier_m1"
        },
        ["soldier_beret"] = {
                sect = "outfit_soldier_m1"
        },
        ["stalker_sv_balon_1"] = {
                sect = "svoboda_heavy_outfit"
        }
}

-- вероятность выпадения бронежилетов и диапазон состояний выпавших
-- бронежилетов и оружия
-- condition - диапазон состояний выпавших бронежилетов и оружия
-- probability_outfit - вероятность выпадения бронежилетов
local data_by_community = {
  default = {     -- значения по-умолчанию для неизвестной группировки
    condition          = { min = 5, max = 95 },
    probability_outfit = 15,
  },
  communities = {
    [ "military" ] = {
      condition          = { min = 35, max = 75 },
      probability_outfit = 20,
    },
    [ "killer"   ] = {
      condition          = { min = 45, max = 75 },
      probability_outfit = 15,
    },
    [ "monolith" ] = {
      condition          = { min =  5, max = 45 },
      probability_outfit = 15,
    },
    [ "zombied"  ] = {
      condition          = { min = 15, max = 35 },
      probability_outfit = 15,
    },
    [ "bandit"   ] = {
      condition          = { min = 25, max = 55 },
      probability_outfit = 15,
    },
    [ "stalker"  ] = {
      condition          = { min = 25, max = 70 },
      probability_outfit = 20,
    },
    [ "dolg"     ] = {
      condition          = { min = 35, max = 70 },
      probability_outfit = 20,
    },
    [ "freedom"  ] = {
      condition          = { min = 35, max = 70 },
      probability_outfit = 20,
    },
    [ "ecolog"   ] = {
      condition          = { min = 35, max = 70 },
      probability_outfit = 20,
    },
    [ "sniper"   ] = {
      condition          = { min = 55, max = 85 },
      probability_outfit = 15,
    },
    [ "green"    ] = {
      condition          = { min = 35, max = 70 },
      probability_outfit = 15,
    },
    [ "nebo"     ] = {
      condition          = { min = 25, max = 65 },
      probability_outfit = 20,
    },
    [ "lastday"  ] = {
      condition          = { min = 25, max = 60 },
      probability_outfit = 10,
    },
  }
}

--' Предметы, относящиеся к патронам. Их надо спаунить другим методом.
local ammo_sections = {}


function init_drop_settings()
  local lsect        = "death_generic." .. level.name()
  local mul_by_level = {}
  if not sys_ini:section_exist( lsect ) then
    lsect = "death_generic.default"
  end
  for i = 0, sys_ini:line_count( lsect ) - 1 do
    local result, id, value = sys_ini:r_line( lsect, i, "", "" )
    mul_by_level[ id ] = tonumber( value )
  end

  for k, v in pairs( data_by_community.communities ) do
    -- Необходимо заполнить таблицу
    item_by_community[ k ] = {}
    local sect = "death_generic." .. k
    if sys_ini:section_exist( sect ) then
      for i = 0, sys_ini:line_count( sect ) - 1 do
        local result, id, value = sys_ini:r_line( sect, i, "", "" )
        local rnd = tonumber( value )
        if mul_by_level[ id ] then
          rnd = rnd * mul_by_level[ id ]
        end
        item_by_community[ k ][ id ] = rnd
      end
    end
  end

  -- Множители и минимаксы для выпадения вещей в зависимости от уровня
  local item_count_section = "death_generic.item_count_"
    .. level.get_game_difficulty()
  for i = 0, sys_ini:line_count( item_count_section ) - 1 do
    local result, id, value = sys_ini:r_line( item_count_section, i, "", "" )
    -- Нужно распарсить value в два значения
    local t = parse_nums( value )
    ASSERT(
      t[1],
      "Error on [death_ini] declaration. Section [%s], line [%s]",
      item_count_section, tostring(id)
    )
    local count_min = t[ 1 ]
    local count_max = t[ 2 ]
    if not count_max then count_max = count_min end
    count_by_level[ id ] = { min = count_min, max = count_max }
  end

  -- Предметы, которые нельзя удалять (квестовые например)
  for i = 0, sys_ini:line_count( "death_generic.keep_items" ) - 1 do
    local result, id, value = sys_ini:r_line(
      "death_generic.keep_items", i, "", ""
    )
    if value == "true" then
      always_keep_item[ id ] = true
    end
  end

  --' Предметы, относящиеся к патронам. Их надо спаунить другим методом.
  for i = 0, sys_ini:line_count( "death_generic.ammo_sections" ) - 1 do
    local result, id, value = sys_ini:r_line(
      "death_generic.ammo_sections", i, "", ""
    )
    ammo_sections[ id ] = true
  end
end


local level_recipient_rnd_coef = {
--  [ "l11_pripyat" ] = 0,
}

class "drop_manager"
function drop_manager:__init( npc_id, who_id )
  local npc = level.object_by_id( npc_id )
  local who
  if who_id then
    who = level.object_by_id( who_id )
  end
  self.npc = npc
  self.who = who

  if
    npc and npc:character_community() ~= "zombied"
    and who and who:id() ~= db.actor:id() and who:id() ~= npc:id()
    and ( IsStalker( who ) or IsMonster( who ) )
  then
    local rnd = ( 4 - level.get_game_difficulty() )
      * ( level_recipient_rnd_coef[ level.name() ] or 0.1 )
    local is_lucky = math.random() < rnd
    if
      watcher_act.is_quest_npc( who )
      or IsMonster( who )
      or who:character_community() == "zombied"
    then
      if is_lucky then
        self.recipient = npc
      end
    else
      if who:relation( db.actor ) ~= game_object.enemy then
        if is_lucky then
          self.recipient = npc
        else
          self.recipient = who
        end
      end
    end
  else
    self.recipient = npc
  end
end


function drop_manager:get_recipient()
  return self.recipient
end


function drop_manager:set_weapon_drop_condition( item )
  local data
  if self.npc then
    data = data_by_community.communities[ self.npc:character_community() ]
    if not data then
      data = data_by_community.default
    end
  else
    data = data_by_community.default
  end
  local cond     = data.condition
  local cond_add = 5 * ( 3 - level.get_game_difficulty() )
  self:set_weapon_condition( item, cond, cond_add )
end


local cached_wpn_info = {}
function get_ammo_for_weapon( wpn )
  local sect = wpn:section()
  if not cached_wpn_info[ sect ] then
    local t = {}
    cached_wpn_info[ sect ] = t
    local ammo_class = get_string( sect, "ammo_class"    )
    if ammo_class then
      t.ammo = {}
      for _, k in ipairs( parse_names( ammo_class ) ) do
        t.ammo[ k ] = true
      end
    end
    local grenade_class = get_string( sect, "grenade_class" )
    if grenade_class then
      t.grenade = {}
      for _, k in ipairs( parse_names( grenade_class ) ) do
        t.grenade[ k ] = true
      end
    end
  end
  return cached_wpn_info[ sect ]
end


function drop_manager:create_release_item()
  if not self.npc then return end
  --' Спрашиваем у серверного объекта генерились ли предметы
  local se_obj = alife():object( self.npc:id() )
  if not se_obj then return end
  if se_obj.death_droped then return end
  se_obj.death_droped = true

  local data = data_by_community.communities[ self.npc:character_community() ]
  if not data then
    data = data_by_community.default
  end

  local cond     = data.condition
  local cond_add = 5 * ( 3 - level.get_game_difficulty() )

  --' Запускаем итератор на удаление предметов
  local can_have_ammo = {}
  local items         = {}
  self.npc:iterate_inventory(
    function( npc, item )
      if item:is_weapon() then
        local t = get_ammo_for_weapon( item )
        if t.ammo then
          for k, _ in pairs( t.ammo ) do
            can_have_ammo[ k ] = true
          end
        end
        if
          t.grenade
          and item:is_weapon_gl()
          and (
            ogse_wpn_utils.get_grenade_launcher_status( item ) == 1
            or (
              ogse_wpn_utils.get_grenade_launcher_status( item ) == 2
              and ogse_wpn_utils.get_grenade_launcher_flag( item )
            )
          )
        then
          for k, _ in pairs( t.grenade ) do
            can_have_ammo[ k ] = true
          end
        end
      end
      local t = {
        [ "item" ] = item,
      }
      table.insert( items, t )
    end,
    self.npc
  )
  for _, t in ipairs( items ) do
    if not self:keep_item( t.item ) then
      t.item = nil
    end
  end
  --' чистим стволы и задаем им состояние
  self:npc_clear_spawn( items, cond.min, cond.max, cond_add )

  --' Проверка на отсутствие спауна лута
  local ini = self.npc:spawn_ini()
  if ini and ini:section_exist( "dont_spawn_loot" ) then
    return
  end

  --' Доспавниваем необходимое количество итемов:
  --' Необходимо составить список объектов которые могут быть
  --заспавнены для персонажа
  local spawn_items = item_by_community[ self.npc:character_community() ]
  local who         = self:get_recipient()
  if spawn_items and who then
    for k, v in pairs( spawn_items ) do
      --' По каждому объекту необходимо получить зависимости
      if can_have_ammo[ k ] or not ammo_sections[ k ] then
        --' По каждому объекту необходимо получить количество
        local number = math.random(
          count_by_level[ k ].min, count_by_level[ k ].max
        )
        --' Необходимо заспавнить нужное количество.
        create_items( who, k, number, v )
      end
    end
  end

  --' Даем письмо
  give_letter( self.npc )

  local npc_name = protected_items.get_obj_name( self.npc )
  if
    not string.find( self.npc:section(), "arena" )
    and self.npc:character_community() ~= "arena_enemy"
    and npc_name ~= "yan_specnaz_dead"
    and npc_name ~= "x16_stalker_ghost"
  then
    local vis = table.remove(
      amk.str_explode( "\\", self.npc:get_visual_name() )
    )
    if vis then
      local sect = visuals[ vis ]
      if not sect then
        for k, v in pairs( sect_by_visual_part ) do
          if string.find( vis, k ) then
            if v.sect then
              sect = v.sect
              break
            elseif v.npc_names then
              sect = v.npc_names[ npc_name ]
              if sect then break end
            end
          end
        end
      end
      if sect and who then
        local otf
        local rnd = self:get_npc_rnd( "outfit_rnd" )
        if rnd * 1000 <= data.probability_outfit * 10 then
          otf = alife():create(
            sect,
            who:position(), who:level_vertex_id(), who:game_vertex_id(),
            who:id()
          )
        end
        if otf then
          local rnd = self:get_npc_rnd( "outfit_cond_rnd" )
          level.client_spawn_manager():add(
            otf.id, -1, function( id, obj )
              rnd = cond.min + round( rnd * ( cond.max - cond.min ) )
              obj:set_condition( ( rnd + cond_add ) / 100 )
            end
          )
        end
      end
    end
  end

  if names_info[ npc_name ] then
    if db.actor:dont_has_info( names_info[ npc_name ] ) then
      db.actor:give_info_portion( names_info[ npc_name ] )
    end
  end
end


function drop_manager:get_npc_rnd( k )
  local rnd
  if self.npc then
    local cfg = self.npc:binded_object()[ script_name() ]
    ASSERT( cfg, "no cfg found for %s", self.npc:name() )
    rnd = cfg[ k ]
    ASSERT( rnd, "no rnd found for %s using %s", self.npc:name(), k )
  else
    rnd = math.random()
  end
  return rnd
end


function drop_manager:set_weapon_condition( item_in_slot, cond, cond_add )
  local ini
  if self.npc then
    ini = self.npc:spawn_ini()
  end
  if item_in_slot and not is_unique_wpn( item_in_slot:section() ) then
    item_in_slot:unload_magazine()
    if ini and ini:section_exist( "totally_broken_weapon" ) then
      -- нужен полностью убитый ствол
      item_in_slot:set_condition( 0.01 )
    else
      local rnd = self:get_npc_rnd( "weapon_cond_rnd" )
      rnd = cond.min + round( rnd * ( cond.max - cond.min ) )
      local rnd_cond = ( rnd + cond_add ) / 100
      if item_in_slot:condition() > rnd_cond then
        item_in_slot:set_condition( rnd_cond )
      end
    end
  end
end


function shedule_release( item )
  if item then
    if not ammo_deferred_release[ item:id() ] then
      ammo_deferred_release[ item:id() ] = time_global()
    end
  end
end


--' Функция вызывается для каждого предмета, если вернет false то
-- предмет удалится.  Разве ? Удаление происходит прямо внутри
-- функции, а внешнему итератору наплевать на результат (sapsan)
function drop_manager:keep_item( item )
  if
  not ( self.npc and item and alife():object( item:id() ) ) then
    return false
  end
  local section = item:section()
  if always_offs_items[ section ] or ammo_sections[ section ] then
    alife():release( alife():object( item:id() ), true )
    return false
  elseif
    always_offs_items_prob[ section ]
    and math.random() > always_offs_items_prob[ section ]
  then
    alife():release( alife():object( item:id() ), true )
    return false
  end
  return true
end


function release_deferred_ammo()
  local ini = system_ini()
  for k, v in pairs( ammo_deferred_release ) do
    local game_object = level.object_by_id( k )
    local s_obj = alife():object( k )
    if not s_obj and not game_object then
      -- если нет ни геймобъекта ни серверного - удалилось как надо
      ammo_deferred_release[ k ] = nil
    elseif s_obj and game_object then
      -- если есть и то и другое - все ок, удаляем
      local parent = game_object:parent()
      if v < time_global() then
        local size = dunin_ammo.get_ammo_size( game_object )
        local box_size = ini:r_u32( s_obj:section_name(), "box_size" )
        if size ~= box_size and size > 0 then
          -- оставим эту пачку в покое
          if not parent then
            write_log(
              "!!AMMO_DEBUG DEBUG_DELETING_AMMO_NORMAL %s", tostring( s_obj.id )
            )
            alife():release( s_obj, true )
            ammo_deferred_release[ k ] = nil
          else
            write_log(
              "!!AMMO_DEBUG DEBUG_TELEPORT_AMMO %s", tostring( s_obj.id ) )
            parent:drop_item( game_object )
          end
        elseif size == box_size then
          -- эту пачку можно сразу удалить
          if not parent then
            write_log(
              "!!AMMO_DEBUG DEBUG_DELETING_AMMO_NORMAL %s", tostring( s_obj.id )
            )
            alife():release( s_obj, true )
            ammo_deferred_release[ k ] = nil
          else
            write_log(
              "!!AMMO_DEBUG DEBUG_TELEPORT_AMMO %s", tostring( s_obj.id )
            )
            parent:drop_item( game_object )
          end
        elseif size == 0 then
          if not parent then
            write_log(
              "!!AMMO_DEBUG DEBUG_DELETING_AMMO_ZERO %s", tostring( s_obj.id )
            )
            alife():release( s_obj, true )
            ammo_deferred_release[ k ] = nil
          else
            write_log(
              "!!AMMO_DEBUG DEBUG_TELEPORT_AMMO_ZERO %s", tostring( s_obj.id )
            )
            parent:drop_item( game_object )
          end
        end
      end
    elseif s_obj then
      -- если только серверный - срочно убиваем
      write_log( "!!AMMO_DEBUG DEBUG_AMMO_SRV %s", tostring( s_obj.id ) )
      alife():release( s_obj, true )
      ammo_deferred_release[ k ] = nil
    elseif game_object then
      -- если только геймобъект - он ещё не успел сдохнуть, сцуко, не
      -- трогаем его
      write_log( "!!AMMO_DEBUG DEBUG_DELETING_ONLY_GAMEOBJ" )
      -- ammo_deferred_release[k] = nil
    end
  end
end


--' Функция спавнит необходимое число предметов
function create_items( npc, section, number, rnd )
  if not npc then return end
  if IsMonster( npc ) then
    local max_weight = get_float(
      npc:section(), "death_manager.can_eat_max_weight"
    )
    if not max_weight then return end
    if npc:get_inventory_weight() > max_weight then return end
    if get_float( section, "inv_weight" ) > max_weight then return end
  end
  if ammo_sections[ section ] then
    if number > 0 and math.random() <= rnd then
      se_respawn.create_ammo(
        section,
        npc:position(), npc:level_vertex_id(), npc:game_vertex_id(),
        npc:id(),
        number
      )
    end
  else
    for i = 1, number do
      --' Проверяем вероятность появить каждый объект в отдельности
      if math.random() <= rnd then
        return alife():create(
          section,
          npc:position(), npc:level_vertex_id(), npc:game_vertex_id(),
          npc:id()
        )
      end
    end
  end
end


-- чистка оружия и других предметов, которые спавнятся через секцию
-- spawn в конфиге непися
function drop_manager:npc_clear_spawn( items, cond_min, cond_max, cond_add )
  local npc            = self.npc
  local who            = self:get_recipient()
  local active_item    = npc:active_item()
  local ammos          = {}
  local release_items  = {}
  local transfer_items = {}
  for _, t in ipairs( items ) do
    if t.item then
      local item    = t.item
      local section = item:section()
      if item:is_weapon() and not is_unique_wpn( section ) then
        if who then
          item:unload_magazine()
          local rnd_cond = (
            math.random( cond_min, cond_max ) + cond_add
          ) / 100
          if item:condition() > rnd_cond then
            item:set_condition( rnd_cond )
          end
          if who:id() ~= npc:id() then
            if active_item and item:id() == active_item:id() then
              npc:move_to_ruck( item )
            end
            table.insert( transfer_items, item )
          end
        else
          table.insert( release_items, item )
        end
      elseif ammo_sections[ section ] then
        -- чистим патроны
        if count_by_level[ section ] then
          local number = math.random(
            count_by_level[ section ].min, count_by_level[ section ].max
          )
          if number > 0 then
            table.insert( ammos, { sect = section, cnt = number } )
          end
        end
        table.insert( release_items, item )
      else
        if
          ( not watcher_act.do_not_touch( item ) )
          and ( not is_unique_wpn( section ) )
        then
          if who then
            if who:id() ~= npc:id() then
              table.insert( transfer_items, item )
            end
          else
            table.insert( release_items, item )
          end
        end
      end
    end
  end
  for _, item in ipairs( release_items ) do
    local found = level.object_by_id( item:id() )
    if found and found:parent():id() == npc:id() then
      ogse.remove_item_from_inventory( item, npc )
    end
  end
  for _, item in ipairs( transfer_items ) do
    local found = level.object_by_id( item:id() )
    if found and found:parent():id() == npc:id() then
      npc:transfer_item( item, who )
    end
  end
  -- доспавниваем взамен удаленных патронов
  if who then
    for k, v in pairs( ammos ) do
      create_items( who, v.sect, v.cnt, 1 )
    end
  end
end


function is_unique_wpn( sect )
  return get_bool( sect, "death_manager.unique_wpn", false )
end


-- Письма
local letters_ini   = ini_file( "misc\\letters.ltx" )
local total_letters = 43        -- всего писем

function give_letter( npc )
  if math.random() > 0.02 then return end
  if get_letter( npc ) then
    alife():create( "letter", vector():set( 0, 0, 0 ), 0, 0, npc:id() )
  end
end


-- Рандомное письмо
function get_letter( npc )
  local avail_letters = {}
  local j = 0
  for i = 1, total_letters do
    if
      ( not has_alife_info( "letter_" .. i ) )
      and
      (
        ( not letters_ini:line_exist( "letter_" .. i, "communities" ) )
        or string.find(
          letters_ini:r_string( "letter_" .. i, "communities" ),
          npc:character_community()
        )
      )
    then
      -- подходит по community
      j = j + 1
      avail_letters[ j ] = i
    end
  end
  if j > 0 then
    -- есть письмо
    db.actor:give_info_portion(
      "letter_" .. avail_letters[ math.random( table.getn( avail_letters ) ) ]
    )
  end
  return j > 0
end


function on_take( obj )
  if obj:section() == "letter" then
    ogse.remove_item_from_inventory( obj )
    archievements.acv_count_event( "acv_ptln", 30, "Почтальон" )
    return true
  end
end
